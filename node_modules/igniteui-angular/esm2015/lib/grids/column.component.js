/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import * as tslib_1 from "tslib";
import { ChangeDetectionStrategy, ChangeDetectorRef, Component, ContentChild, ContentChildren, Input, QueryList, TemplateRef, forwardRef } from '@angular/core';
import { DataType } from '../data-operations/data-util';
import { GridBaseAPIService } from './api.service';
import { IgxDateSummaryOperand, IgxNumberSummaryOperand, IgxSummaryOperand } from './summaries/grid-summary';
import { IgxRowComponent } from './row.component';
import { IgxCellEditorTemplateDirective, IgxCellHeaderTemplateDirective, IgxCellTemplateDirective, IgxFilterCellTemplateDirective } from './grid.common';
import { DefaultSortingStrategy } from '../data-operations/sorting-strategy';
import { getNodeSizeViaRange, flatten } from '../core/utils';
import { IgxBooleanFilteringOperand, IgxNumberFilteringOperand, IgxDateFilteringOperand, IgxStringFilteringOperand, IgxFilteringOperand } from '../data-operations/filtering-condition';
import { DeprecateProperty } from '../core/deprecateDecorators';
import { DisplayDensity } from '../core/displayDensity';
/**
 * **Ignite UI for Angular Column** -
 * [Documentation](https://www.infragistics.com/products/ignite-ui-angular/angular/components/grid.html#columns-configuration)
 *
 * The Ignite UI Column is used within an `igx-grid` element to define what data the column will show. Features such as sorting,
 * filtering & editing are enabled at the column level.  You can also provide a template containing custom content inside
 * the column using `ng-template` which will be used for all cells within the column.
 */
export class IgxColumnComponent {
    /**
     * @param {?} gridAPI
     * @param {?} cdr
     */
    constructor(gridAPI, cdr) {
        this.gridAPI = gridAPI;
        this.cdr = cdr;
        /**
         * Sets/gets the `header` value.
         * ```typescript
         * let columnHeader = this.column.header;
         * ```
         * ```html
         * <igx-column [header] = "'ID'"></igx-column>
         * ```
         *
         * \@memberof IgxColumnComponent
         */
        this.header = '';
        /**
         * Sets/gets whether the column is sortable.
         * Default value is `false`.
         * ```typescript
         * let isSortable = this.column.sortable;
         * ```
         * ```html
         * <igx-column [sortable] = "true"></igx-column>
         * ```
         * \@memberof IgxColumnComponent
         */
        this.sortable = false;
        /**
         * Sets/gets whether the column is groupable.
         * Default value is `false`.
         * ```typescript
         * let isGroupable = this.column.groupable;
         * ```
         * ```html
         * <igx-column [groupable] = "true"></igx-column>
         * ```
         * \@memberof IgxColumnComponent
         */
        this.groupable = false;
        /**
         * Sets/gets whether the column is editable.
         * Default value is `false`.
         * ```typescript
         * let isEditable = this.column.editable;
         * ```
         * ```html
         * <igx-column [editable] = "true"></igx-column>
         * ```
         * \@memberof IgxColumnComponent
         */
        this.editable = null;
        /**
         * Sets/gets whether the column is filterable.
         * Default value is `true`.
         * ```typescript
         * let isFilterable = this.column.filterable;
         * ```
         * ```html
         * <igx-column [filterable] = "false"></igx-column>
         * ```
         * \@memberof IgxColumnComponent
         */
        this.filterable = true;
        /**
         * Sets/gets whether the column is resizable.
         * Default value is `false`.
         * ```typescript
         * let isResizable = this.column.resizable;
         * ```
         * ```html
         * <igx-column [resizable] = "true"></igx-column>
         * ```
         * \@memberof IgxColumnComponent
         */
        this.resizable = false;
        /**
         * Sets/gets whether the column is movable.
         * Default value is `false`.
         * ```typescript
         * let isMovable = this.column.movable;
         * ```
         * ```html
         * <igx-column [movable] = "true"></igx-column>
         * ```
         * \@memberof IgxColumnComponent
         */
        this.movable = false;
        this._calcWidth = null;
        /**
         * Sets/gets the class selector of the column header.
         * ```typescript
         * let columnHeaderClass = this.column.headerClasses;
         * ```
         * ```html
         * <igx-column [headerClasses] = "'column-header'"></igx-column>
         * ```
         * \@memberof IgxColumnComponent
         */
        this.headerClasses = '';
        /**
         * Sets/gets the class selector of the column group header.
         * ```typescript
         * let columnHeaderClass = this.column.headerGroupClasses;
         * ```
         * ```html
         * <igx-column [headerGroupClasses] = "'column-group-header'"></igx-column>
         * ```
         * \@memberof IgxColumnComponent
         */
        this.headerGroupClasses = '';
        /**
         * Sets/gets whether the column filtering should be case sensitive.
         * Default value is `true`.
         * ```typescript
         * let filteringIgnoreCase = this.column.filteringIgnoreCase;
         * ```
         * ```html
         * <igx-column [filteringIgnoreCase] = "false"></igx-column>
         * ```
         * \@memberof IgxColumnComponent
         */
        this.filteringIgnoreCase = true;
        /**
         * Sets/gets whether the column sorting should be case sensitive.
         * Default value is `true`.
         * ```typescript
         * let sortingIgnoreCase = this.column.sortingIgnoreCase;
         * ```
         * ```html
         * <igx-column [sortingIgnoreCase] = "false"></igx-column>
         * ```
         * \@memberof IgxColumnComponent
         */
        this.sortingIgnoreCase = true;
        /**
         * Sets/gets the data type of the column values.
         * Default value is `string`.
         * ```typescript
         * let columnDataType = this.column.dataType;
         * ```
         * ```html
         * <igx-column [dataType] = "'number'"></igx-column>
         * ```
         * \@memberof IgxColumnComponent
         */
        this.dataType = DataType.String;
        /**
         * Sets/gets whether the column is `searchable`.
         * Default value is `true`.
         * ```typescript
         * let isSearchable =  this.column.searchable';
         * ```
         * ```html
         *  <igx-column [searchable] = "false"></igx-column>
         * ```
         * \@memberof IgxColumnComponent
         */
        this.searchable = true;
        /**
         * Sets/gets the parent column.
         * ```typescript
         * let parentColumn = this.column.parent;
         * ```
         * ```typescript
         * this.column.parent = higherLevelColumn;
         * ```
         * \@memberof IgxColumnComponent
         */
        this.parent = null;
        /**
         * @hidden
         */
        this._pinned = false;
        /**
         * @hidden
         */
        this._summaries = null;
        /**
         * @hidden
         */
        this._filters = null;
        /**
         * @hidden
         */
        this._sortStrategy = DefaultSortingStrategy.instance();
        /**
         * @hidden
         */
        this._hidden = false;
        /**
         * @hidden
         */
        this._disableHiding = false;
        /**
         * @hidden
         */
        this._disablePinning = false;
        /**
         * @hidden
         */
        this._defaultMinWidth = '';
        /**
         * @hidden
         */
        this._hasSummary = false;
        this._vIndex = NaN;
    }
    /**
     * Gets a value indicating whether the summary for the column is enabled.
     * ```typescript
     * let hasSummary = this.column.hasSummary;
     * ```
     * \@memberof IgxColumnComponent
     * @return {?}
     */
    get hasSummary() {
        return this._hasSummary;
    }
    /**
     * Sets a value indicating whether the summary for the column is enabled.
     * Default value is `false`.
     * ```html
     * <igx-column [hasSummary] = "true"></igx-column>
     * ```
     * \@memberof IgxColumnComponent
     * @param {?} value
     * @return {?}
     */
    set hasSummary(value) {
        this._hasSummary = value;
        if (this.grid) {
            this.grid.summaryService.recalculateSummaries();
        }
    }
    /**
     * Gets whether the column is hidden.
     * ```typescript
     * let isHidden = this.column.hidden;
     * ```
     * \@memberof IgxColumnComponent
     * @return {?}
     */
    get hidden() {
        return this._hidden;
    }
    /**
     * Sets the column hidden property.
     * Default value is `false`.
     * ```typescript
     * <igx-column [hidden] = "true"></igx-column>
     * ```
     * \@memberof IgxColumnComponent
     * @param {?} value
     * @return {?}
     */
    set hidden(value) {
        if (this._hidden !== value) {
            this._hidden = value;
            if (this.grid) {
                this.grid.resetCaches();
                this.grid.endEdit(false);
            }
            // TODO: Simplify
            this.check();
            if (this.grid) {
                this.grid.refreshSearch(true);
                this.grid.summaryService.resetSummaryHeight();
                this.grid.reflow();
                this.grid.filteringService.refreshExpressions();
            }
            if (this.columnLayoutChild && this.parent.hidden !== value) {
                this.parent.hidden = value;
            }
        }
    }
    /**
     * Gets whether the hiding is disabled.
     * ```typescript
     * let isHidingDisabled =  this.column.disableHiding;
     * ```
     * \@memberof IgxColumnComponent
     * @return {?}
     */
    get disableHiding() {
        return this._disableHiding;
    }
    /**
     * Enables/disables hiding for the column.
     * Default value is `false`.
     * ```typescript
     * <igx-column [hidden] = "true"></igx-column>
     * ```
     * \@memberof IgxColumnComponent
     * @param {?} value
     * @return {?}
     */
    set disableHiding(value) {
        if (this._disableHiding !== value) {
            this._disableHiding = value;
            this.check();
        }
    }
    /**
     * Gets whether the pinning is disabled.
     * ```typescript
     * let isPinningDisabled =  this.column.disablePinning;
     * ```
     * \@memberof IgxColumnComponent
     * @return {?}
     */
    get disablePinning() {
        return this._disablePinning;
    }
    /**
     * Enables/disables pinning for the column.
     * Default value is `false`.
     * ```typescript
     * <igx-column [pinned] = "true"></igx-column>
     * ```
     * \@memberof IgxColumnComponent
     * @param {?} value
     * @return {?}
     */
    set disablePinning(value) {
        if (this._disablePinning !== value) {
            this._disablePinning = value;
            this.check();
        }
    }
    /**
     * Gets the `width` of the column.
     * ```typescript
     * let columnWidth = this.column.width;
     * ```
     * \@memberof IgxColumnComponent
     * @return {?}
     */
    get width() {
        return this.widthSetByUser ? this._width : this.defaultWidth;
    }
    /**
     * Sets the `width` of the column.
     * ```html
     * <igx-column [width] = "'25%'"></igx-column>
     * ```
     * \@memberof IgxColumnComponent
     * @param {?} value
     * @return {?}
     */
    set width(value) {
        if (value) {
            this._calcWidth = null;
            this.calcPixelWidth = NaN;
            this.widthSetByUser = true;
            this._width = value;
            if (this.grid) {
                this.cacheCalcWidth();
            }
        }
    }
    /**
     * @hidden
     * @return {?}
     */
    get calcWidth() {
        return this.getCalcWidth();
    }
    /**
     * Sets/gets the minimum `width` of the column.
     * Default value is `88`;
     * ```typescript
     * let columnMinWidth = this.column.minWidth;
     * ```
     * ```html
     * <igx-column [minWidth] = "'15%'"></igx-column>
     * ```
     * \@memberof IgxColumnComponent
     * @param {?} value
     * @return {?}
     */
    set minWidth(value) {
        /** @type {?} */
        const minVal = parseFloat(value);
        if (Number.isNaN(minVal)) {
            return;
        }
        this._defaultMinWidth = value;
    }
    /**
     * @return {?}
     */
    get minWidth() {
        return !this._defaultMinWidth ? this.defaultMinWidth : this._defaultMinWidth;
    }
    /**
     * Gets the column index.
     * ```typescript
     * let columnIndex = this.column.index;
     * ```
     * \@memberof IgxColumnComponent
     * @return {?}
     */
    get index() {
        return this.grid.columns.indexOf(this);
    }
    /**
     * Gets whether the column is `pinned`.
     * ```typescript
     * let isPinned = this.column.pinned;
     * ```
     * \@memberof IgxColumnComponent
     * @return {?}
     */
    get pinned() {
        return this._pinned;
    }
    /**
     * Sets whether the column is pinned.
     * Default value is `false`.
     * ```html
     * <igx-column [pinned] = "true"></igx-column>
     * ```
     * \@memberof IgxColumnComponent
     * @param {?} value
     * @return {?}
     */
    set pinned(value) {
        if (this._pinned !== value) {
            if (this.grid && this.width && !isNaN(parseInt(this.width, 10))) {
                value ? this.pin() : this.unpin();
                return;
            }
            /* No grid/width available at initialization. `initPinning` in the grid
               will re-init the group (if present)
            */
            this._pinned = value;
        }
    }
    /**
     * Gets the column `summaries`.
     * ```typescript
     * let columnSummaries = this.column.summaries;
     * ```
     * \@memberof IgxColumnComponent
     * @return {?}
     */
    get summaries() {
        return this._summaries;
    }
    /**
     * Sets the column `summaries`.
     * ```typescript
     * this.column.summaries = IgxNumberSummaryOperand;
     * ```
     * \@memberof IgxColumnComponent
     * @param {?} classRef
     * @return {?}
     */
    set summaries(classRef) {
        this._summaries = new classRef();
        if (this.grid) {
            this.grid.summaryService.removeSummariesCachePerColumn(this.field);
            ((/** @type {?} */ (this.grid)))._summaryPipeTrigger++;
            this.grid.summaryService.recalculateSummaries();
        }
    }
    /**
     * Gets the column `filters`.
     * ```typescript
     * let columnFilters = this.column.filters'
     * ```
     * \@memberof IgxColumnComponent
     * @return {?}
     */
    get filters() {
        return this._filters;
    }
    /**
     * Sets the column `filters`.
     * ```typescript
     * this.column.filters = IgxBooleanFilteringOperand.instance().
     * ```
     * \@memberof IgxColumnComponent
     * @param {?} instance
     * @return {?}
     */
    set filters(instance) {
        this._filters = instance;
    }
    /**
     * Gets the column `sortStrategy`.
     * ```typescript
     * let sortStrategy = this.column.sortStrategy'
     * ```
     * \@memberof IgxColumnComponent
     * @return {?}
     */
    get sortStrategy() {
        return this._sortStrategy;
    }
    /**
     * Sets the column `sortStrategy`.
     * ```typescript
     * this.column.sortStrategy = new CustomSortingStrategy().
     *
     * class CustomSortingStrategy extends SortingStrategy {
     * ...
     * }
     * ```
     * \@memberof IgxColumnComponent
     * @param {?} classRef
     * @return {?}
     */
    set sortStrategy(classRef) {
        this._sortStrategy = classRef;
    }
    /**
     * Gets the function that compares values for grouping.
     * ```typescript
     * let groupingComparer = this.column.groupingComparer'
     * ```
     * \@memberof IgxColumnComponent
     * @return {?}
     */
    get groupingComparer() {
        return this._groupingComparer;
    }
    /**
     * Sets a custom function to compare values for grouping.
     * Subsequent values in the sorted data that the function returns 0 for are grouped.
     * ```typescript
     * this.column.groupingComparer = (a: any, b: any) => { return a === b ? 0 : -1; }
     * ```
     * \@memberof IgxColumnComponent
     * @param {?} funcRef
     * @return {?}
     */
    set groupingComparer(funcRef) {
        this._groupingComparer = funcRef;
    }
    /**
     * Gets the default minimum `width` of the column.
     * ```typescript
     * let defaultMinWidth =  this.column.defaultMinWidth;
     * ```
     * \@memberof IgxColumnComponent
     * @return {?}
     */
    get defaultMinWidth() {
        if (!this.grid) {
            return '80';
        }
        switch (this.grid.displayDensity) {
            case DisplayDensity.cosy:
                return '64';
            case DisplayDensity.compact:
                return '56';
            default:
                return '80';
        }
    }
    /**
     * Returns a reference to the `bodyTemplate`.
     * ```typescript
     * let bodyTemplate = this.column.bodyTemplate;
     * ```
     * \@memberof IgxColumnComponent
     * @return {?}
     */
    get bodyTemplate() {
        return this._bodyTemplate;
    }
    /**
     * Sets the body template.
     * ```html
     * <ng-template #bodyTemplate igxCell let-val>
     *    <div style = "background-color: yellowgreen" (click) = "changeColor(val)">
     *       <span> {{val}} </span>
     *    </div>
     * </ng-template>
     * ```
     * ```typescript
     * \@ViewChild("'bodyTemplate'", {read: TemplateRef })
     * public bodyTemplate: TemplateRef<any>;
     * this.column.bodyTemplate = this.bodyTemplate;
     * ```
     * \@memberof IgxColumnComponent
     * @param {?} template
     * @return {?}
     */
    set bodyTemplate(template) {
        this._bodyTemplate = template;
        if (this.grid) {
            this.grid.cdr.markForCheck();
        }
    }
    /**
     * Returns a reference to the header template.
     * ```typescript
     * let headerTemplate = this.column.headerTemplate;
     * ```
     * \@memberof IgxColumnComponent
     * @return {?}
     */
    get headerTemplate() {
        return this._headerTemplate;
    }
    /**
     * Sets the header template.
     * ```html
     * <ng-template #headerTemplate>
     *   <div style = "background-color:black" (click) = "changeColor(val)">
     *       <span style="color:red" >{{column.field}}</span>
     *   </div>
     * </ng-template>
     * ```
     * ```typescript
     * \@ViewChild("'headerTemplate'", {read: TemplateRef })
     * public headerTemplate: TemplateRef<any>;
     * this.column.headerTemplate = this.headerTemplate;
     * ```
     * \@memberof IgxColumnComponent
     * @param {?} template
     * @return {?}
     */
    set headerTemplate(template) {
        this._headerTemplate = template;
        if (this.grid) {
            this.grid.cdr.markForCheck();
        }
    }
    /**
     * Returns a reference to the inline editor template.
     * ```typescript
     * let inlineEditorTemplate = this.column.inlineEditorTemplate;
     * ```
     * \@memberof IgxColumnComponent
     * @return {?}
     */
    get inlineEditorTemplate() {
        return this._inlineEditorTemplate;
    }
    /**
     * Sets the inline editor template.
     * ```html
     * <ng-template #inlineEditorTemplate igxCellEditor let-cell="cell">
     *     <input type="string" [(ngModel)]="cell.value"/>
     * </ng-template>
     * ```
     * ```typescript
     * \@ViewChild("'inlineEditorTemplate'", {read: TemplateRef })
     * public inlineEditorTemplate: TemplateRef<any>;
     * this.column.inlineEditorTemplate = this.inlineEditorTemplate;
     * ```
     * \@memberof IgxColumnComponent
     * @param {?} template
     * @return {?}
     */
    set inlineEditorTemplate(template) {
        this._inlineEditorTemplate = template;
        if (this.grid) {
            this.grid.cdr.markForCheck();
        }
    }
    /**
     * Returns a reference to the `filterCellTemplate`.
     * ```typescript
     * let filterCellTemplate = this.column.filterCellTemplate;
     * ```
     * \@memberof IgxColumnComponent
     * @return {?}
     */
    get filterCellTemplate() {
        return this._filterCellTemplate;
    }
    /**
     * Sets the quick filter template.
     * ```html
     * <ng-template #filterCellTemplate IgxFilterCellTemplate let-column="column">
     *    <input (input)="onInput()">
     * </ng-template>
     * ```
     * ```typescript
     * \@ViewChild("'filterCellTemplate'", {read: TemplateRef })
     * public filterCellTemplate: TemplateRef<any>;
     * this.column.filterCellTemplate = this.filterCellTemplate;
     * ```
     * \@memberof IgxColumnComponent
     * @param {?} template
     * @return {?}
     */
    set filterCellTemplate(template) {
        this._filterCellTemplate = template;
    }
    /**
     * Gets the cells of the column.
     * ```typescript
     * let columnCells =  this.column.cells;
     * ```
     * \@memberof IgxColumnComponent
     * @return {?}
     */
    get cells() {
        return this.grid.rowList.filter((row) => row instanceof IgxRowComponent)
            .map((row) => {
            if (row.cells) {
                return row.cells.filter((cell) => cell.columnIndex === this.index);
            }
        }).reduce((a, b) => a.concat(b), []);
    }
    /**
     * Gets the column visible index.
     * If the column is not visible, returns `-1`.
     * ```typescript
     * let visibleColumnIndex =  this.column.visibleIndex;
     * ```
     * \@memberof IgxColumnComponent
     * @return {?}
     */
    get visibleIndex() {
        if (!isNaN(this._vIndex)) {
            return this._vIndex;
        }
        /** @type {?} */
        const unpinnedColumns = this.grid.unpinnedColumns.filter(c => !c.columnGroup);
        /** @type {?} */
        const pinnedColumns = this.grid.pinnedColumns.filter(c => !c.columnGroup);
        /** @type {?} */
        let col = this;
        /** @type {?} */
        let vIndex = -1;
        if (this.columnGroup) {
            col = (/** @type {?} */ (this.allChildren.filter(c => !c.columnGroup)[0]));
        }
        if (this.columnLayoutChild) {
            return this.parent.childrenVisibleIndexes.find(x => x.column === this).index;
        }
        if (!this.pinned) {
            /** @type {?} */
            const indexInCollection = unpinnedColumns.indexOf(col);
            vIndex = indexInCollection === -1 ? -1 : pinnedColumns.length + indexInCollection;
        }
        else {
            vIndex = pinnedColumns.indexOf(col);
        }
        this._vIndex = vIndex;
        return vIndex;
    }
    /**
     * Returns a boolean indicating if the column is a `ColumnGroup`.
     * ```typescript
     * let columnGroup =  this.column.columnGroup;
     * ```
     * \@memberof IgxColumnComponent
     * @return {?}
     */
    get columnGroup() {
        return false;
    }
    /**
     * Returns a boolean indicating if the column is a `ColumnLayout` for multi-row layout.
     * ```typescript
     * let columnGroup =  this.column.columnGroup;
     * ```
     * \@memberof IgxColumnComponent
     * @return {?}
     */
    get columnLayout() {
        return false;
    }
    /**
     * Returns a boolean indicating if the column is a child of a `ColumnLayout` for multi-row layout.
     * ```typescript
     * let columnLayoutChild =  this.column.columnLayoutChild;
     * ```
     * \@memberof IgxColumnComponent
     * @return {?}
     */
    get columnLayoutChild() {
        return this.parent && this.parent.columnLayout;
    }
    /**
     * Returns the children columns collection.
     * Returns an empty array if the column does not contain children columns.
     * ```typescript
     * let childrenColumns =  this.column.allChildren;
     * ```
     * \@memberof IgxColumnComponent
     * @return {?}
     */
    get allChildren() {
        return [];
    }
    /**
     * Returns the level of the column in a column group.
     * Returns `0` if the column doesn't have a `parent`.
     * ```typescript
     * let columnLevel =  this.column.level;
     * ```
     * \@memberof IgxColumnComponent
     * @return {?}
     */
    get level() {
        /** @type {?} */
        let ptr = this.parent;
        /** @type {?} */
        let lvl = 0;
        while (ptr) {
            lvl++;
            ptr = ptr.parent;
        }
        return lvl;
    }
    /**
     * @return {?}
     */
    get isLastPinned() {
        return this.grid.pinnedColumns[this.grid.pinnedColumns.length - 1] === this;
    }
    /**
     * @return {?}
     */
    get gridRowSpan() {
        return this.rowEnd && this.rowStart ? this.rowEnd - this.rowStart : 1;
    }
    /**
     * @return {?}
     */
    get gridColumnSpan() {
        return this.colEnd && this.colStart ? this.colEnd - this.colStart : 1;
    }
    /**
     * Returns the filteringExpressionsTree of the column.
     * ```typescript
     * let tree =  this.column.filteringExpressionsTree;
     * ```
     * \@memberof IgxColumnComponent
     * @return {?}
     */
    get filteringExpressionsTree() {
        return (/** @type {?} */ (this.grid.filteringExpressionsTree.find(this.field)));
    }
    /**
     * @hidden
     * \@internal
     * @return {?}
     */
    resetCaches() {
        this._vIndex = NaN;
        if (this.grid) {
            this.cacheCalcWidth();
        }
    }
    /**
     * @hidden
     * @return {?}
     */
    ngAfterContentInit() {
        if (this.cellTemplate) {
            this._bodyTemplate = this.cellTemplate.template;
        }
        if (this.headTemplate) {
            this._headerTemplate = this.headTemplate.template;
        }
        if (this.editorTemplate) {
            this._inlineEditorTemplate = this.editorTemplate.template;
        }
        if (this.filterCellTemplateDirective) {
            this._filterCellTemplate = this.filterCellTemplateDirective.template;
        }
        if (!this.summaries) {
            switch (this.dataType) {
                case DataType.String:
                case DataType.Boolean:
                    this.summaries = IgxSummaryOperand;
                    break;
                case DataType.Number:
                    this.summaries = IgxNumberSummaryOperand;
                    break;
                case DataType.Date:
                    this.summaries = IgxDateSummaryOperand;
                    break;
                default:
                    this.summaries = IgxSummaryOperand;
                    break;
            }
        }
        if (!this.filters) {
            switch (this.dataType) {
                case DataType.Boolean:
                    this.filters = IgxBooleanFilteringOperand.instance();
                    break;
                case DataType.Number:
                    this.filters = IgxNumberFilteringOperand.instance();
                    break;
                case DataType.Date:
                    this.filters = IgxDateFilteringOperand.instance();
                    break;
                case DataType.String:
                default:
                    this.filters = IgxStringFilteringOperand.instance();
                    break;
            }
        }
    }
    /**
     * @hidden
     * @param {?} isRow
     * @param {?} isIE
     * @return {?}
     */
    getGridTemplate(isRow, isIE) {
        if (isRow) {
            /** @type {?} */
            const rowsCount = this.grid.multiRowLayoutRowSize;
            return isIE ?
                `(1fr)[${rowsCount}]` :
                `repeat(${rowsCount},1fr)`;
        }
        else {
            return this.getColumnSizesString(this.children);
        }
    }
    /**
     * @param {?} children
     * @return {?}
     */
    getInitialChildColumnSizes(children) {
        /** @type {?} */
        const columnSizes = [];
        // find the smallest col spans
        children.forEach(col => {
            if (!col.colStart) {
                return;
            }
            /** @type {?} */
            const newWidthSet = col.widthSetByUser && columnSizes[col.colStart - 1] && !columnSizes[col.colStart - 1].widthSetByUser;
            /** @type {?} */
            const newSpanSmaller = columnSizes[col.colStart - 1] && columnSizes[col.colStart - 1].colSpan > col.gridColumnSpan;
            /** @type {?} */
            const bothWidthsSet = col.widthSetByUser && columnSizes[col.colStart - 1] && columnSizes[col.colStart - 1].widthSetByUser;
            /** @type {?} */
            const bothWidthsNotSet = !col.widthSetByUser && columnSizes[col.colStart - 1] && !columnSizes[col.colStart - 1].widthSetByUser;
            if (columnSizes[col.colStart - 1] === undefined) {
                // If nothing is defined yet take any column at first
                // We use colEnd to know where the column actually ends, because not always it starts where we have it set in columnSizes.
                columnSizes[col.colStart - 1] = {
                    ref: col,
                    width: col.widthSetByUser || this.grid.columnWidthSetByUser ? parseInt(col.calcWidth, 10) : null,
                    colSpan: col.gridColumnSpan,
                    colEnd: col.colStart + col.gridColumnSpan,
                    widthSetByUser: col.widthSetByUser
                };
            }
            else if (newWidthSet || (newSpanSmaller && ((bothWidthsSet) || (bothWidthsNotSet)))) {
                // If a column is set already it should either not have width defined or have width with bigger span than the new one.
                /**
                 *  If replaced column has bigger span, we want to fill the remaining columns
                 *  that the replacing column does not fill with the old one.
                 **/
                if (bothWidthsSet && newSpanSmaller) {
                    // Start from where the new column set would end and apply the old column to the rest depending on how much it spans.
                    // We have not yet replaced it so we can use it directly from the columnSizes collection.
                    // This is where colEnd is used because the colStart of the old column is not actually i + 1.
                    for (let i = col.colStart - 1 + col.gridColumnSpan; i < columnSizes[col.colStart - 1].colEnd - 1; i++) {
                        if (!columnSizes[i] || !columnSizes[i].widthSetByUser) {
                            columnSizes[i] = columnSizes[col.colStart - 1];
                        }
                        else {
                            break;
                        }
                    }
                }
                // Replace the old column with the new one.
                columnSizes[col.colStart - 1] = {
                    ref: col,
                    width: col.widthSetByUser || this.grid.columnWidthSetByUser ? parseInt(col.calcWidth, 10) : null,
                    colSpan: col.gridColumnSpan,
                    colEnd: col.colStart + col.gridColumnSpan,
                    widthSetByUser: col.widthSetByUser
                };
            }
            else if (bothWidthsSet && columnSizes[col.colStart - 1].colSpan < col.gridColumnSpan) {
                // If the column already in the columnSizes has smaller span, we still need to fill any empty places with the current col.
                // Start from where the smaller column set would end and apply the bigger column to the rest depending on how much it spans.
                // Since here we do not have it in columnSizes we set it as a new column keeping the same colSpan.
                for (let i = col.colStart - 1 + columnSizes[col.colStart - 1].colSpan; i < col.colStart - 1 + col.gridColumnSpan; i++) {
                    if (!columnSizes[i] || !columnSizes[i].widthSetByUser) {
                        columnSizes[i] = {
                            ref: col,
                            width: col.widthSetByUser || this.grid.columnWidthSetByUser ? parseInt(col.calcWidth, 10) : null,
                            colSpan: col.gridColumnSpan,
                            colEnd: col.colStart + col.gridColumnSpan,
                            widthSetByUser: col.widthSetByUser
                        };
                    }
                    else {
                        break;
                    }
                }
            }
        });
        // Flatten columnSizes so there are not columns with colSpan > 1
        for (let i = 0; i < columnSizes.length; i++) {
            if (columnSizes[i] && columnSizes[i].colSpan > 1) {
                /** @type {?} */
                let j = 1;
                // Replace all empty places depending on how much the current column spans starting from next col.
                for (; j < columnSizes[i].colSpan && i + j + 1 < columnSizes[i].colEnd; j++) {
                    if (columnSizes[i + j] &&
                        ((!columnSizes[i].width && columnSizes[i + j].width) ||
                            (!columnSizes[i].width && !columnSizes[i + j].width && columnSizes[i + j].colSpan <= columnSizes[i].colSpan) ||
                            (!!columnSizes[i + j].width && columnSizes[i + j].colSpan <= columnSizes[i].colSpan))) {
                        // If we reach an already defined column that has width and the current doesn't have or
                        // if the reached column has bigger colSpan we stop.
                        break;
                    }
                    else {
                        /** @type {?} */
                        const width = columnSizes[i].widthSetByUser ?
                            columnSizes[i].width / columnSizes[i].colSpan :
                            columnSizes[i].width;
                        columnSizes[i + j] = {
                            ref: columnSizes[i].ref,
                            width: width,
                            colSpan: 1,
                            colEnd: columnSizes[i].colEnd,
                            widthSetByUser: columnSizes[i].widthSetByUser
                        };
                    }
                }
                // Update the current column width so it is divided between all columns it spans and set it to 1.
                columnSizes[i].width = columnSizes[i].widthSetByUser ?
                    columnSizes[i].width / columnSizes[i].colSpan :
                    columnSizes[i].width;
                columnSizes[i].colSpan = 1;
                // Update the index based on how much we have replaced. Subtract 1 because we started from 1.
                i += j - 1;
            }
        }
        return columnSizes;
    }
    /**
     * @param {?} children
     * @return {?}
     */
    getFilledChildColumnSizes(children) {
        /** @type {?} */
        const columnSizes = this.getInitialChildColumnSizes(children);
        // fill the gaps if there are any
        /** @type {?} */
        const result = [];
        for (let i = 0; i < columnSizes.length; i++) {
            if (columnSizes[i] && !!columnSizes[i].width) {
                result.push(columnSizes[i].width + 'px');
            }
            else {
                result.push(parseInt(this.grid.getPossibleColumnWidth(), 10) + 'px');
            }
        }
        return result;
    }
    /**
     * @protected
     * @param {?} children
     * @return {?}
     */
    getColumnSizesString(children) {
        /** @type {?} */
        const res = this.getFilledChildColumnSizes(children);
        return res.join(' ');
    }
    /**
     * @return {?}
     */
    getResizableColUnderEnd() {
        if (this.columnLayout || !this.columnLayoutChild || this.columnGroup) {
            return [{ target: this, spanUsed: 1 }];
        }
        /** @type {?} */
        const columnSized = this.getInitialChildColumnSizes(this.parent.children);
        /** @type {?} */
        const targets = [];
        /** @type {?} */
        const colEnd = this.colEnd ? this.colEnd : this.colStart + 1;
        for (let i = 0; i < columnSized.length; i++) {
            if (this.colStart <= i + 1 && i + 1 < colEnd) {
                targets.push({ target: columnSized[i].ref, spanUsed: 1 });
            }
        }
        /** @type {?} */
        const targetsSquashed = [];
        for (let j = 0; j < targets.length; j++) {
            if (targetsSquashed.length && targetsSquashed[targetsSquashed.length - 1].target.field === targets[j].target.field) {
                targetsSquashed[targetsSquashed.length - 1].spanUsed++;
            }
            else {
                targetsSquashed.push(targets[j]);
            }
        }
        return targetsSquashed;
    }
    /**
     * Pins the column at the provided index in the pinned area. Defaults to index `0` if not provided.
     * Returns `true` if the column is successfully pinned. Returns `false` if the column cannot be pinned.
     * Column cannot be pinned if:
     * - Is already pinned
     * - index argument is out of range
     * - The pinned area exceeds 80% of the grid width
     * ```typescript
     * let success = this.column.pin();
     * ```
     * \@memberof IgxColumnComponent
     * @param {?=} index
     * @return {?}
     */
    pin(index) {
        // TODO: Probably should the return type of the old functions
        // should be moved as a event parameter.
        if (this.grid) {
            this.grid.endEdit(true);
        }
        if (this._pinned) {
            return false;
        }
        if (this.parent && !this.parent.pinned) {
            return this.topLevelParent.pin(index);
        }
        /** @type {?} */
        const grid = ((/** @type {?} */ (this.grid)));
        /** @type {?} */
        const hasIndex = index !== undefined;
        if (hasIndex && (index < 0 || index >= grid.pinnedColumns.length)) {
            return false;
        }
        /** @type {?} */
        const width = parseInt(this.width, 10);
        if (!this.parent && (grid.getUnpinnedWidth(true) - width < grid.unpinnedAreaMinWidth)) {
            return false;
        }
        this._pinned = true;
        this._unpinnedIndex = grid._unpinnedColumns.indexOf(this);
        index = index !== undefined ? index : grid._pinnedColumns.length;
        /** @type {?} */
        const targetColumn = grid._pinnedColumns[index];
        /** @type {?} */
        const args = { column: this, insertAtIndex: index, isPinned: true };
        grid.onColumnPinning.emit(args);
        if (grid._pinnedColumns.indexOf(this) === -1) {
            grid._pinnedColumns.splice(args.insertAtIndex, 0, this);
            if (grid._unpinnedColumns.indexOf(this) !== -1) {
                grid._unpinnedColumns.splice(grid._unpinnedColumns.indexOf(this), 1);
            }
        }
        if (hasIndex) {
            grid._moveColumns(this, targetColumn);
        }
        if (this.columnGroup) {
            this.allChildren.forEach(child => child.pin());
            grid.reinitPinStates();
        }
        grid.resetCaches();
        grid.cdr.detectChanges();
        if (this.columnLayoutChild) {
            this.grid.columns.filter(x => x.columnLayout).forEach(x => x.populateVisibleIndexes());
        }
        this.grid.filteringService.refreshExpressions();
        this.grid.refreshSearch(true);
        return true;
    }
    /**
     * Unpins the column and place it at the provided index in the unpinned area. Defaults to index `0` if not provided.
     * Returns `true` if the column is successfully unpinned. Returns `false` if the column cannot be unpinned.
     * Column cannot be unpinned if:
     * - Is already unpinned
     * - index argument is out of range
     * ```typescript
     * let success = this.column.unpin();
     * ```
     * \@memberof IgxColumnComponent
     * @param {?=} index
     * @return {?}
     */
    unpin(index) {
        if (this.grid) {
            this.grid.endEdit(true);
        }
        if (!this._pinned) {
            return false;
        }
        if (this.parent && this.parent.pinned) {
            return this.topLevelParent.unpin(index);
        }
        /** @type {?} */
        const grid = ((/** @type {?} */ (this.grid)));
        /** @type {?} */
        const hasIndex = index !== undefined;
        if (hasIndex && (index < 0 || index >= grid._unpinnedColumns.length)) {
            return false;
        }
        index = (index !== undefined ? index :
            this._unpinnedIndex !== undefined ? this._unpinnedIndex : this.index);
        this._pinned = false;
        /** @type {?} */
        const targetColumn = grid._unpinnedColumns[index];
        grid._unpinnedColumns.splice(index, 0, this);
        if (grid._pinnedColumns.indexOf(this) !== -1) {
            grid._pinnedColumns.splice(grid._pinnedColumns.indexOf(this), 1);
        }
        if (hasIndex) {
            grid._moveColumns(this, targetColumn);
        }
        if (this.columnGroup) {
            this.allChildren.forEach(child => child.unpin());
        }
        grid.reinitPinStates();
        grid.resetCaches();
        /** @type {?} */
        const insertAtIndex = grid._unpinnedColumns.indexOf(this);
        /** @type {?} */
        const args = { column: this, insertAtIndex, isPinned: false };
        grid.onColumnPinning.emit(args);
        grid.cdr.detectChanges();
        if (this.columnLayoutChild) {
            this.grid.columns.filter(x => x.columnLayout).forEach(x => x.populateVisibleIndexes());
        }
        this.grid.filteringService.refreshExpressions();
        this.grid.refreshSearch(true);
        return true;
    }
    /**
     * Returns a reference to the top level parent column.
     * ```typescript
     * let topLevelParent =  this.column.topLevelParent;
     * ```
     * \@memberof IgxColumnComponent
     * @return {?}
     */
    get topLevelParent() {
        /** @type {?} */
        let parent = this.parent;
        while (parent && parent.parent) {
            parent = parent.parent;
        }
        return parent;
    }
    /**
     * @hidden
     * @protected
     * @return {?}
     */
    check() {
        if (this.grid) {
            this.grid.markForCheck();
        }
    }
    /**
     * Returns a reference to the header of the column.
     * ```typescript
     * let column = this.grid.columnList.filter(c => c.field === 'ID')[0];
     * let headerCell = column.headerCell;
     * ```
     * \@memberof IgxColumnComponent
     * @return {?}
     */
    get headerCell() {
        return this.grid.headerCellList.find((header) => header.column === this);
    }
    /**
     * Returns a reference to the filter cell of the column.
     * ```typescript
     * let column = this.grid.columnList.filter(c => c.field === 'ID')[0];
     * let filterell = column.filterell;
     * ```
     * \@memberof IgxColumnComponent
     * @return {?}
     */
    get filterCell() {
        return this.grid.filterCellList.find((filterCell) => filterCell.column === this);
    }
    /**
     * Returns a reference to the header group of the column.
     * \@memberof IgxColumnComponent
     * @return {?}
     */
    get headerGroup() {
        return this.grid.headerGroupsList.find((headerGroup) => headerGroup.column === this);
    }
    /**
     * Autosize the column to the longest currently visible cell value, including the header cell.
     * ```typescript
     * \@ViewChild('grid') grid: IgxGridComponent;
     *
     * let column = this.grid.columnList.filter(c => c.field === 'ID')[0];
     * column.autosize();
     * ```
     * \@memberof IgxColumnComponent
     * @return {?}
     */
    autosize() {
        if (!this.columnGroup) {
            this.width = this.getLargestCellWidth();
            this.grid.markForCheck();
            this.grid.reflow();
        }
    }
    /**
     * @hidden
     * @return {?}
     */
    getCalcWidth() {
        if (this._calcWidth !== null && !isNaN(this.calcPixelWidth)) {
            return this._calcWidth;
        }
        this.cacheCalcWidth();
        return this._calcWidth;
    }
    /**
     * @hidden
     * Returns the size (in pixels) of the longest currently visible cell, including the header cell.
     * ```typescript
     * \@ViewChild('grid') grid: IgxGridComponent;
     *
     * let column = this.grid.columnList.filter(c => c.field === 'ID')[0];
     * let size = column.getLargestCellWidth();
     * ```
     * \@memberof IgxColumnComponent
     * @return {?}
     */
    getLargestCellWidth() {
        /** @type {?} */
        const range = this.grid.document.createRange();
        /** @type {?} */
        const largest = new Map();
        if (this.cells.length > 0) {
            /** @type {?} */
            let cellsContentWidths = [];
            if (this.cells[0].nativeElement.children.length > 0) {
                this.cells.forEach((cell) => cellsContentWidths.push(cell.calculateSizeToFit(range)));
            }
            else {
                cellsContentWidths = this.cells.map((cell) => getNodeSizeViaRange(range, cell.nativeElement));
            }
            /** @type {?} */
            const index = cellsContentWidths.indexOf(Math.max(...cellsContentWidths));
            /** @type {?} */
            const cellStyle = this.grid.document.defaultView.getComputedStyle(this.cells[index].nativeElement);
            /** @type {?} */
            const cellPadding = parseFloat(cellStyle.paddingLeft) + parseFloat(cellStyle.paddingRight) +
                parseFloat(cellStyle.borderRightWidth);
            largest.set(Math.max(...cellsContentWidths), cellPadding);
        }
        if (this.headerCell) {
            /** @type {?} */
            let headerCell;
            if (this.headerTemplate && this.headerCell.elementRef.nativeElement.children[0].children.length > 0) {
                headerCell = Math.max(...Array.from(this.headerCell.elementRef.nativeElement.children[0].children)
                    .map((child) => getNodeSizeViaRange(range, child)));
            }
            else {
                headerCell = getNodeSizeViaRange(range, this.headerCell.elementRef.nativeElement.children[0]);
            }
            if (this.sortable || this.filterable) {
                headerCell += this.headerCell.elementRef.nativeElement.children[1].getBoundingClientRect().width;
            }
            /** @type {?} */
            const headerStyle = this.grid.document.defaultView.getComputedStyle(this.headerCell.elementRef.nativeElement);
            /** @type {?} */
            const headerPadding = parseFloat(headerStyle.paddingLeft) + parseFloat(headerStyle.paddingRight) +
                parseFloat(headerStyle.borderRightWidth);
            largest.set(headerCell, headerPadding);
        }
        /** @type {?} */
        const largestCell = Math.max(...Array.from(largest.keys()));
        /** @type {?} */
        const width = Math.ceil(largestCell + largest.get(largestCell));
        if (Number.isNaN(width)) {
            return this.width;
        }
        else {
            return width + 'px';
        }
    }
    /**
     * @hidden
     * @return {?}
     */
    getCellWidth() {
        /** @type {?} */
        const colWidth = this.width;
        /** @type {?} */
        const isPercentageWidth = colWidth && typeof colWidth === 'string' && colWidth.indexOf('%') !== -1;
        if (this.columnLayoutChild) {
            return '';
        }
        if (colWidth && !isPercentageWidth) {
            /** @type {?} */
            let cellWidth = colWidth;
            if (typeof cellWidth !== 'string' || cellWidth.endsWith('px') === false) {
                cellWidth += 'px';
            }
            return cellWidth;
        }
        else {
            return colWidth;
        }
    }
    /**
     * @hidden
     * \@internal
     * @protected
     * @return {?}
     */
    cacheCalcWidth() {
        /** @type {?} */
        const colWidth = this.width;
        /** @type {?} */
        const isPercentageWidth = colWidth && typeof colWidth === 'string' && colWidth.indexOf('%') !== -1;
        if (isPercentageWidth) {
            this._calcWidth = parseInt(colWidth, 10) / 100 * (this.grid.calcWidth - this.grid.featureColumnsWidth);
        }
        else if (!colWidth) {
            // no width
            this._calcWidth = this.defaultWidth || this.grid.getPossibleColumnWidth();
        }
        else {
            this._calcWidth = this.width;
        }
        this.calcPixelWidth = parseInt(this._calcWidth, 10);
    }
    /**
     * @hidden
     * @return {?}
     */
    populateVisibleIndexes() { }
}
IgxColumnComponent.decorators = [
    { type: Component, args: [{
                changeDetection: ChangeDetectionStrategy.OnPush,
                preserveWhitespaces: false,
                selector: 'igx-column',
                template: ``
            }] }
];
/** @nocollapse */
IgxColumnComponent.ctorParameters = () => [
    { type: GridBaseAPIService },
    { type: ChangeDetectorRef }
];
IgxColumnComponent.propDecorators = {
    field: [{ type: Input }],
    header: [{ type: Input }],
    sortable: [{ type: Input }],
    groupable: [{ type: Input }],
    editable: [{ type: Input }],
    filterable: [{ type: Input }],
    resizable: [{ type: Input }],
    hasSummary: [{ type: Input }],
    hidden: [{ type: Input }],
    disableHiding: [{ type: Input }],
    disablePinning: [{ type: Input }],
    movable: [{ type: Input }],
    width: [{ type: Input }],
    maxWidth: [{ type: Input }],
    minWidth: [{ type: Input }],
    headerClasses: [{ type: Input }],
    headerGroupClasses: [{ type: Input }],
    cellClasses: [{ type: Input }],
    formatter: [{ type: Input }],
    filteringIgnoreCase: [{ type: Input }],
    sortingIgnoreCase: [{ type: Input }],
    dataType: [{ type: Input }],
    pinned: [{ type: Input }],
    summaries: [{ type: Input }],
    searchable: [{ type: Input }],
    filters: [{ type: Input }],
    sortStrategy: [{ type: Input }],
    groupingComparer: [{ type: Input }],
    bodyTemplate: [{ type: Input, args: ['cellTemplate',] }],
    headerTemplate: [{ type: Input }],
    inlineEditorTemplate: [{ type: Input, args: ['cellEditorTemplate',] }],
    filterCellTemplate: [{ type: Input, args: ['filterCellTemplate',] }],
    rowEnd: [{ type: Input }],
    colEnd: [{ type: Input }],
    rowStart: [{ type: Input }],
    colStart: [{ type: Input }],
    cellTemplate: [{ type: ContentChild, args: [IgxCellTemplateDirective, { read: IgxCellTemplateDirective },] }],
    headTemplate: [{ type: ContentChild, args: [IgxCellHeaderTemplateDirective, { read: IgxCellHeaderTemplateDirective },] }],
    editorTemplate: [{ type: ContentChild, args: [IgxCellEditorTemplateDirective, { read: IgxCellEditorTemplateDirective },] }],
    filterCellTemplateDirective: [{ type: ContentChild, args: [IgxFilterCellTemplateDirective, { read: IgxFilterCellTemplateDirective },] }]
};
tslib_1.__decorate([
    DeprecateProperty(`The property is deprecated. Please, use \`column.grid.id\` instead.`),
    tslib_1.__metadata("design:type", String)
], IgxColumnComponent.prototype, "gridID", void 0);
if (false) {
    /**
     * Sets/gets the `field` value.
     * ```typescript
     * let columnField = this.column.field;
     * ```
     * ```html
     * <igx-column [field] = "'ID'"></igx-column>
     * ```
     * \@memberof IgxColumnComponent
     * @type {?}
     */
    IgxColumnComponent.prototype.field;
    /**
     * Sets/gets the `header` value.
     * ```typescript
     * let columnHeader = this.column.header;
     * ```
     * ```html
     * <igx-column [header] = "'ID'"></igx-column>
     * ```
     *
     * \@memberof IgxColumnComponent
     * @type {?}
     */
    IgxColumnComponent.prototype.header;
    /**
     * Sets/gets whether the column is sortable.
     * Default value is `false`.
     * ```typescript
     * let isSortable = this.column.sortable;
     * ```
     * ```html
     * <igx-column [sortable] = "true"></igx-column>
     * ```
     * \@memberof IgxColumnComponent
     * @type {?}
     */
    IgxColumnComponent.prototype.sortable;
    /**
     * Sets/gets whether the column is groupable.
     * Default value is `false`.
     * ```typescript
     * let isGroupable = this.column.groupable;
     * ```
     * ```html
     * <igx-column [groupable] = "true"></igx-column>
     * ```
     * \@memberof IgxColumnComponent
     * @type {?}
     */
    IgxColumnComponent.prototype.groupable;
    /**
     * Sets/gets whether the column is editable.
     * Default value is `false`.
     * ```typescript
     * let isEditable = this.column.editable;
     * ```
     * ```html
     * <igx-column [editable] = "true"></igx-column>
     * ```
     * \@memberof IgxColumnComponent
     * @type {?}
     */
    IgxColumnComponent.prototype.editable;
    /**
     * Sets/gets whether the column is filterable.
     * Default value is `true`.
     * ```typescript
     * let isFilterable = this.column.filterable;
     * ```
     * ```html
     * <igx-column [filterable] = "false"></igx-column>
     * ```
     * \@memberof IgxColumnComponent
     * @type {?}
     */
    IgxColumnComponent.prototype.filterable;
    /**
     * Sets/gets whether the column is resizable.
     * Default value is `false`.
     * ```typescript
     * let isResizable = this.column.resizable;
     * ```
     * ```html
     * <igx-column [resizable] = "true"></igx-column>
     * ```
     * \@memberof IgxColumnComponent
     * @type {?}
     */
    IgxColumnComponent.prototype.resizable;
    /**
     * Sets/gets whether the column is movable.
     * Default value is `false`.
     * ```typescript
     * let isMovable = this.column.movable;
     * ```
     * ```html
     * <igx-column [movable] = "true"></igx-column>
     * ```
     * \@memberof IgxColumnComponent
     * @type {?}
     */
    IgxColumnComponent.prototype.movable;
    /**
     * @type {?}
     * @private
     */
    IgxColumnComponent.prototype._calcWidth;
    /** @type {?} */
    IgxColumnComponent.prototype.calcPixelWidth;
    /**
     * Sets/gets the maximum `width` of the column.
     * ```typescript
     * let columnMaxWidth = this.column.width;
     * ```
     * ```html
     * <igx-column [maxWidth] = "'75%'"></igx-column>
     * ```
     * \@memberof IgxColumnComponent
     * @type {?}
     */
    IgxColumnComponent.prototype.maxWidth;
    /**
     * Sets/gets the class selector of the column header.
     * ```typescript
     * let columnHeaderClass = this.column.headerClasses;
     * ```
     * ```html
     * <igx-column [headerClasses] = "'column-header'"></igx-column>
     * ```
     * \@memberof IgxColumnComponent
     * @type {?}
     */
    IgxColumnComponent.prototype.headerClasses;
    /**
     * Sets/gets the class selector of the column group header.
     * ```typescript
     * let columnHeaderClass = this.column.headerGroupClasses;
     * ```
     * ```html
     * <igx-column [headerGroupClasses] = "'column-group-header'"></igx-column>
     * ```
     * \@memberof IgxColumnComponent
     * @type {?}
     */
    IgxColumnComponent.prototype.headerGroupClasses;
    /**
     * Sets a conditional class selector of the column cells.
     * Accepts an object literal, containing key-value pairs,
     * where the key is the name of the CSS class, while the
     * value is either a callback function that returns a boolean,
     * or boolean, like so:
     * ```typescript
     * callback = (rowData, columnKey) => { return rowData[columnKey] > 6; }
     * cellClasses = { 'className' : this.callback };
     * ```
     * ```html
     * <igx-column [cellClasses] = "cellClasses"></igx-column>
     * <igx-column [cellClasses] = "{'class1' : true }"></igx-column>
     * ```
     * \@memberof IgxColumnComponent
     * @type {?}
     */
    IgxColumnComponent.prototype.cellClasses;
    /**
     * Gets formatter for the column.
     * ```typescript
     * let columnFormatter = this.column.formatter;
     * ```
     * \@memberof IgxColumnComponent
     * @type {?}
     */
    IgxColumnComponent.prototype.formatter;
    /**
     * Sets/gets whether the column filtering should be case sensitive.
     * Default value is `true`.
     * ```typescript
     * let filteringIgnoreCase = this.column.filteringIgnoreCase;
     * ```
     * ```html
     * <igx-column [filteringIgnoreCase] = "false"></igx-column>
     * ```
     * \@memberof IgxColumnComponent
     * @type {?}
     */
    IgxColumnComponent.prototype.filteringIgnoreCase;
    /**
     * Sets/gets whether the column sorting should be case sensitive.
     * Default value is `true`.
     * ```typescript
     * let sortingIgnoreCase = this.column.sortingIgnoreCase;
     * ```
     * ```html
     * <igx-column [sortingIgnoreCase] = "false"></igx-column>
     * ```
     * \@memberof IgxColumnComponent
     * @type {?}
     */
    IgxColumnComponent.prototype.sortingIgnoreCase;
    /**
     * Sets/gets the data type of the column values.
     * Default value is `string`.
     * ```typescript
     * let columnDataType = this.column.dataType;
     * ```
     * ```html
     * <igx-column [dataType] = "'number'"></igx-column>
     * ```
     * \@memberof IgxColumnComponent
     * @type {?}
     */
    IgxColumnComponent.prototype.dataType;
    /**
     * @deprecated
     * Gets/Sets the `id` of the `igx-grid`.
     * ```typescript
     * let columnGridId = this.column.gridID;
     * ```
     * ```typescript
     * this.column.gridID = 'grid-1';
     * ```
     * \@memberof IgxColumnComponent
     * @type {?}
     */
    IgxColumnComponent.prototype.gridID;
    /**
     * Sets/gets whether the column is `searchable`.
     * Default value is `true`.
     * ```typescript
     * let isSearchable =  this.column.searchable';
     * ```
     * ```html
     *  <igx-column [searchable] = "false"></igx-column>
     * ```
     * \@memberof IgxColumnComponent
     * @type {?}
     */
    IgxColumnComponent.prototype.searchable;
    /**
     * The reference to the `igx-grid` owner.
     * ```typescript
     * let gridComponent = this.column.grid;
     * ```
     * \@memberof IgxColumnComponent
     * @type {?}
     */
    IgxColumnComponent.prototype.grid;
    /**
     * Row index where the current field should end.
     * The amount of rows between rowStart and rowEnd will determine the amount of spanning rows to that field
     * ```html
     * <igx-column-layout>
     *   <igx-column [rowEnd]="2" [rowStart]="1" [colStart]="1"></igx-column>
     * </igx-column-layout>
     * ```
     * \@memberof IgxColumnComponent
     * @type {?}
     */
    IgxColumnComponent.prototype.rowEnd;
    /**
     * Column index where the current field should end.
     * The amount of columns between colStart and colEnd will determine the amount of spanning columns to that field
     * ```html
     * <igx-column-layout>
     *   <igx-column [colEnd]="3" [rowStart]="1" [colStart]="1"></igx-column>
     * </igx-column-layout>
     * ```
     * \@memberof IgxColumnComponent
     * @type {?}
     */
    IgxColumnComponent.prototype.colEnd;
    /**
     * Row index from which the field is starting.
     * ```html
     * <igx-column-layout>
     *   <igx-column [rowStart]="1" [colStart]="1"></igx-column>
     * </igx-column-layout>
     * ```
     * \@memberof IgxColumnComponent
     * @type {?}
     */
    IgxColumnComponent.prototype.rowStart;
    /**
     * Column index from which the field is starting.
     * ```html
     * <igx-column-layout>
     *   <igx-column [colStart]="1" [rowStart]="1"></igx-column>
     * </igx-column-layout>
     * ```
     * \@memberof IgxColumnComponent
     * @type {?}
     */
    IgxColumnComponent.prototype.colStart;
    /**
     * hidden
     * @type {?}
     */
    IgxColumnComponent.prototype.defaultWidth;
    /**
     * hidden
     * @type {?}
     */
    IgxColumnComponent.prototype.widthSetByUser;
    /**
     * Sets/gets the parent column.
     * ```typescript
     * let parentColumn = this.column.parent;
     * ```
     * ```typescript
     * this.column.parent = higherLevelColumn;
     * ```
     * \@memberof IgxColumnComponent
     * @type {?}
     */
    IgxColumnComponent.prototype.parent;
    /**
     * Sets/gets the children columns.
     * ```typescript
     * let columnChildren = this.column.children;
     * ```
     * ```typescript
     * this.column.children = childrenColumns;
     * ```
     * \@memberof IgxColumnComponent
     * @type {?}
     */
    IgxColumnComponent.prototype.children;
    /**
     * @hidden
     * @type {?}
     * @protected
     */
    IgxColumnComponent.prototype._unpinnedIndex;
    /**
     * @hidden
     * @type {?}
     * @protected
     */
    IgxColumnComponent.prototype._pinned;
    /**
     * @hidden
     * @type {?}
     * @protected
     */
    IgxColumnComponent.prototype._bodyTemplate;
    /**
     * @hidden
     * @type {?}
     * @protected
     */
    IgxColumnComponent.prototype._headerTemplate;
    /**
     * @hidden
     * @type {?}
     * @protected
     */
    IgxColumnComponent.prototype._inlineEditorTemplate;
    /**
     * @hidden
     * @type {?}
     * @protected
     */
    IgxColumnComponent.prototype._filterCellTemplate;
    /**
     * @hidden
     * @type {?}
     * @protected
     */
    IgxColumnComponent.prototype._summaries;
    /**
     * @hidden
     * @type {?}
     * @protected
     */
    IgxColumnComponent.prototype._filters;
    /**
     * @hidden
     * @type {?}
     * @protected
     */
    IgxColumnComponent.prototype._sortStrategy;
    /**
     * @hidden
     * @type {?}
     * @protected
     */
    IgxColumnComponent.prototype._groupingComparer;
    /**
     * @hidden
     * @type {?}
     * @protected
     */
    IgxColumnComponent.prototype._hidden;
    /**
     * @hidden
     * @type {?}
     * @protected
     */
    IgxColumnComponent.prototype._index;
    /**
     * @hidden
     * @type {?}
     * @protected
     */
    IgxColumnComponent.prototype._disableHiding;
    /**
     * @hidden
     * @type {?}
     * @protected
     */
    IgxColumnComponent.prototype._disablePinning;
    /**
     * @hidden
     * @type {?}
     * @protected
     */
    IgxColumnComponent.prototype._width;
    /**
     * @hidden
     * @type {?}
     * @protected
     */
    IgxColumnComponent.prototype._defaultMinWidth;
    /**
     * @hidden
     * @type {?}
     * @protected
     */
    IgxColumnComponent.prototype._hasSummary;
    /**
     * @hidden
     * @type {?}
     * @protected
     */
    IgxColumnComponent.prototype.cellTemplate;
    /**
     * @hidden
     * @type {?}
     * @protected
     */
    IgxColumnComponent.prototype.headTemplate;
    /**
     * @hidden
     * @type {?}
     * @protected
     */
    IgxColumnComponent.prototype.editorTemplate;
    /**
     * @type {?}
     * @protected
     */
    IgxColumnComponent.prototype._vIndex;
    /**
     * @hidden
     * @type {?}
     */
    IgxColumnComponent.prototype.filterCellTemplateDirective;
    /** @type {?} */
    IgxColumnComponent.prototype.gridAPI;
    /** @type {?} */
    IgxColumnComponent.prototype.cdr;
}
export class IgxColumnGroupComponent extends IgxColumnComponent {
    /**
     * @param {?} gridAPI
     * @param {?} cdr
     */
    constructor(gridAPI, cdr) {
        // D.P. constructor duplication due to es6 compilation, might be obsolete in the future
        super(gridAPI, cdr);
        this.gridAPI = gridAPI;
        this.cdr = cdr;
        this.children = new QueryList();
        /**
         * Sets/gets whether the column group is `searchable`.
         * Default value is `true`.
         * ```typescript
         * let isSearchable =  this.columnGroup.searchable;
         * ```
         * ```html
         *  <igx-column-group [searchable] = "false"></igx-column-group>
         * ```
         * \@memberof IgxColumnGroupComponent
         */
        this.searchable = true;
    }
    /**
     * Gets the column group `summaries`.
     * ```typescript
     * let columnGroupSummaries = this.columnGroup.summaries;
     * ```
     * \@memberof IgxColumnGroupComponent
     * @return {?}
     */
    get summaries() {
        return this._summaries;
    }
    /**
     * Sets the column group `summaries`.
     * ```typescript
     * this.columnGroup.summaries = IgxNumberSummaryOperand;
     * ```
     * \@memberof IgxColumnGroupComponent
     * @param {?} classRef
     * @return {?}
     */
    set summaries(classRef) { }
    /**
     * Gets the column group `filters`.
     * ```typescript
     * let columnGroupFilters = this.columnGroup.filters;
     * ```
     * \@memberof IgxColumnGroupComponent
     * @return {?}
     */
    get filters() {
        return this._filters;
    }
    /**
     * Sets the column group `filters`.
     * ```typescript
     * this.columnGroup.filters = IgxStringFilteringOperand;
     * ```
     * \@memberof IgxColumnGroupComponent
     * @param {?} classRef
     * @return {?}
     */
    set filters(classRef) { }
    /**
     * Returns a reference to the body template.
     * ```typescript
     * let bodyTemplate = this.columnGroup.bodyTemplate;
     * ```
     * \@memberof IgxColumnGroupComponent
     * @return {?}
     */
    get bodyTemplate() {
        return this._bodyTemplate;
    }
    /**
     * @hidden
     * @param {?} template
     * @return {?}
     */
    set bodyTemplate(template) { }
    /**
     * Returns a reference to the header template.
     * ```typescript
     * let headerTemplate = this.columnGroup.headerTemplate;
     * ```
     * \@memberof IgxColumnGroupComponent
     * @return {?}
     */
    get headerTemplate() {
        return this._headerTemplate;
    }
    /**
     * @hidden
     * \@memberof IgxColumnGroupComponent
     * @param {?} template
     * @return {?}
     */
    set headerTemplate(template) { }
    /**
     * Returns a reference to the inline editor template.
     * ```typescript
     * let inlineEditorTemplate = this.columnGroup.inlineEditorTemplate;
     * ```
     * \@memberof IgxColumnGroupComponent
     * @return {?}
     */
    get inlineEditorTemplate() {
        return this._inlineEditorTemplate;
    }
    /**
     * @hidden
     * @param {?} template
     * @return {?}
     */
    set inlineEditorTemplate(template) { }
    /**
     * Gets the column group cells.
     * ```typescript
     * let columnCells = this.columnGroup.cells;
     * ```
     * \@memberof IgxColumnGroupComponent
     * @return {?}
     */
    get cells() {
        return [];
    }
    /**
     * Gets whether the column group is hidden.
     * ```typescript
     * let isHidden = this.columnGroup.hidden;
     * ```
     * \@memberof IgxColumnGroupComponent
     * @return {?}
     */
    get hidden() {
        return this.allChildren.every(c => c.hidden);
    }
    /**
     * Sets the column group hidden property.
     * ```typescript
     * <igx-column [hidden] = "true"></igx-column>
     * ```
     * \@memberof IgxColumnGroupComponent
     * @param {?} value
     * @return {?}
     */
    set hidden(value) {
        this._hidden = value;
        this.children.forEach(child => child.hidden = value);
    }
    /**
     * @hidden
     * @return {?}
     */
    ngAfterContentInit() {
        /*
            @ContentChildren with descendants still returns the `parent`
            component in the query list.
        */
        this.children.reset(this.children.toArray().slice(1));
        this.children.forEach(child => {
            child.parent = this;
        });
    }
    /**
     * Returns the children columns collection.
     * ```typescript
     * let columns =  this.columnGroup.allChildren;
     * ```
     * \@memberof IgxColumnGroupComponent
     * @return {?}
     */
    get allChildren() {
        return flatten(this.children.toArray());
    }
    /**
     * Returns a boolean indicating if the column is a `ColumnGroup`.
     * ```typescript
     * let isColumnGroup =  this.columnGroup.columnGroup
     * ```
     * \@memberof IgxColumnGroupComponent
     * @return {?}
     */
    get columnGroup() {
        return true;
    }
    /**
     * Returns a boolean indicating if the column is a `ColumnLayout` for multi-row layout.
     * ```typescript
     * let columnGroup =  this.column.columnGroup;
     * ```
     * \@memberof IgxColumnComponent
     * @return {?}
     */
    get columnLayout() {
        return false;
    }
    /**
     * Gets the width of the column group.
     * ```typescript
     * let columnGroupWidth = this.columnGroup.width;
     * ```
     * \@memberof IgxColumnGroupComponent
     * @return {?}
     */
    get width() {
        /** @type {?} */
        let isChildrenWidthInPercent = false;
        /** @type {?} */
        let width;
        width = `${this.children.reduce((acc, val) => {
            if (val.hidden) {
                return acc;
            }
            if (typeof val.width === 'string' && val.width.indexOf('%') !== -1) {
                isChildrenWidthInPercent = true;
            }
            return acc + parseInt(val.width, 10);
        }, 0)}`;
        return isChildrenWidthInPercent ? width + '%' : width;
    }
    /**
     * @param {?} val
     * @return {?}
     */
    set width(val) { }
}
IgxColumnGroupComponent.decorators = [
    { type: Component, args: [{
                changeDetection: ChangeDetectionStrategy.OnPush,
                providers: [{ provide: IgxColumnComponent, useExisting: forwardRef(() => IgxColumnGroupComponent) }],
                selector: 'igx-column-group',
                template: ``
            }] }
];
/** @nocollapse */
IgxColumnGroupComponent.ctorParameters = () => [
    { type: GridBaseAPIService },
    { type: ChangeDetectorRef }
];
IgxColumnGroupComponent.propDecorators = {
    children: [{ type: ContentChildren, args: [IgxColumnComponent, { read: IgxColumnComponent },] }],
    summaries: [{ type: Input }],
    searchable: [{ type: Input }],
    filters: [{ type: Input }],
    hidden: [{ type: Input }]
};
if (false) {
    /** @type {?} */
    IgxColumnGroupComponent.prototype.children;
    /**
     * Sets/gets whether the column group is `searchable`.
     * Default value is `true`.
     * ```typescript
     * let isSearchable =  this.columnGroup.searchable;
     * ```
     * ```html
     *  <igx-column-group [searchable] = "false"></igx-column-group>
     * ```
     * \@memberof IgxColumnGroupComponent
     * @type {?}
     */
    IgxColumnGroupComponent.prototype.searchable;
    /** @type {?} */
    IgxColumnGroupComponent.prototype.gridAPI;
    /** @type {?} */
    IgxColumnGroupComponent.prototype.cdr;
}
export class IgxColumnLayoutComponent extends IgxColumnGroupComponent {
    constructor() {
        super(...arguments);
        this.childrenVisibleIndexes = [];
    }
    /**
     * Gets the width of the column layout.
     * ```typescript
     * let columnGroupWidth = this.columnGroup.width;
     * ```
     * \@memberof IgxColumnGroupComponent
     * @return {?}
     */
    get width() {
        /** @type {?} */
        const width = this.getFilledChildColumnSizes(this.children).reduce((acc, val) => acc + parseInt(val, 10), 0);
        return width;
    }
    /**
     * @param {?} val
     * @return {?}
     */
    set width(val) { }
    /**
     * @return {?}
     */
    get columnLayout() {
        return true;
    }
    /**
     * @hidden
     * @return {?}
     */
    getCalcWidth() {
        /** @type {?} */
        let borderWidth = 0;
        if (this.headerGroup && this.headerGroup.hasLastPinnedChildColumn) {
            /** @type {?} */
            const headerStyles = this.grid.document.defaultView.getComputedStyle(this.headerGroup.element.nativeElement.children[0]);
            borderWidth = parseInt(headerStyles.borderRightWidth, 10);
        }
        return super.getCalcWidth() + borderWidth;
    }
    /**
     * Gets the column visible index.
     * If the column is not visible, returns `-1`.
     * ```typescript
     * let visibleColumnIndex =  this.column.visibleIndex;
     * ```
     * \@memberof IgxColumnComponent
     * @return {?}
     */
    get visibleIndex() {
        if (!isNaN(this._vIndex)) {
            return this._vIndex;
        }
        /** @type {?} */
        const unpinnedColumns = this.grid.unpinnedColumns.filter(c => c.columnLayout && !c.hidden);
        /** @type {?} */
        const pinnedColumns = this.grid.pinnedColumns.filter(c => c.columnLayout && !c.hidden);
        /** @type {?} */
        let vIndex = -1;
        if (!this.pinned) {
            /** @type {?} */
            const indexInCollection = unpinnedColumns.indexOf(this);
            vIndex = indexInCollection === -1 ? -1 : pinnedColumns.length + indexInCollection;
        }
        else {
            vIndex = pinnedColumns.indexOf(this);
        }
        this._vIndex = vIndex;
        return vIndex;
    }
    /*
         * Gets whether the column layout is hidden.
         * ```typescript
         * let isHidden = this.columnGroup.hidden;
         * ```
         * @memberof IgxColumnGroupComponent
         */
    /**
     * @return {?}
     */
    get hidden() {
        return this._hidden;
    }
    /**
     * Sets the column layout hidden property.
     * ```typescript
     * <igx-column-layout [hidden] = "true"></igx-column->
     * ```
     * \@memberof IgxColumnGroupComponent
     * @param {?} value
     * @return {?}
     */
    set hidden(value) {
        this._hidden = value;
        this.children.forEach(child => child.hidden = value);
        if (this.grid && this.grid.columns && this.grid.columns.length > 0) {
            // reset indexes in case columns are hidden/shown runtime
            this.grid.columns.filter(x => x.columnGroup).forEach(x => x.populateVisibleIndexes());
        }
    }
    /**
     * @hidden
     * @return {?}
     */
    ngAfterContentInit() {
        super.ngAfterContentInit();
        if (!this.hidden) {
            this.hidden = this.allChildren.some(x => x.hidden);
        }
        else {
            this.children.forEach(child => child.hidden = this.hidden);
        }
        this.children.forEach(child => {
            child.disableHiding = true;
            child.disablePinning = true;
            child.movable = false;
        });
    }
    /*
         * Gets whether the group contains the last pinned child column of the column layout.
         * ```typescript
         * let columsHasLastPinned = this.columnLayout.hasLastPinnedChildColumn;
         * ```
         * @memberof IgxColumnLayoutComponent
         */
    /**
     * @return {?}
     */
    get hasLastPinnedChildColumn() {
        return this.children.some(child => child.isLastPinned);
    }
    /**
     * @hidden
     * @return {?}
     */
    populateVisibleIndexes() {
        this.childrenVisibleIndexes = [];
        /** @type {?} */
        const grid = this.gridAPI.grid;
        /** @type {?} */
        const columns = grid && grid.pinnedColumns && grid.unpinnedColumns ? grid.pinnedColumns.concat(grid.unpinnedColumns) : [];
        /** @type {?} */
        const orderedCols = columns
            .filter(x => !x.columnGroup && !x.hidden)
            .sort((a, b) => a.rowStart - b.rowStart || columns.indexOf(a.parent) - columns.indexOf(b.parent) || a.colStart - b.colStart);
        this.children.forEach(child => {
            /** @type {?} */
            const rs = child.rowStart || 1;
            /** @type {?} */
            let vIndex = 0;
            // filter out all cols with larger rowStart
            /** @type {?} */
            const cols = orderedCols.filter(c => !c.columnGroup && (c.rowStart || 1) <= rs);
            vIndex = cols.indexOf(child);
            this.childrenVisibleIndexes.push({ column: child, index: vIndex });
        });
    }
}
IgxColumnLayoutComponent.decorators = [
    { type: Component, args: [{
                changeDetection: ChangeDetectionStrategy.OnPush,
                providers: [{ provide: IgxColumnComponent, useExisting: forwardRef(() => IgxColumnLayoutComponent) }],
                selector: 'igx-column-layout',
                template: ``
            }] }
];
IgxColumnLayoutComponent.propDecorators = {
    hidden: [{ type: Input }]
};
if (false) {
    /** @type {?} */
    IgxColumnLayoutComponent.prototype.childrenVisibleIndexes;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY29sdW1uLmNvbXBvbmVudC5qcyIsInNvdXJjZVJvb3QiOiJuZzovL2lnbml0ZXVpLWFuZ3VsYXIvIiwic291cmNlcyI6WyJsaWIvZ3JpZHMvY29sdW1uLmNvbXBvbmVudC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7OztBQUFBLE9BQU8sRUFFSCx1QkFBdUIsRUFDdkIsaUJBQWlCLEVBQ2pCLFNBQVMsRUFDVCxZQUFZLEVBQ1osZUFBZSxFQUNmLEtBQUssRUFDTCxTQUFTLEVBQ1QsV0FBVyxFQUNYLFVBQVUsRUFFYixNQUFNLGVBQWUsQ0FBQztBQUN2QixPQUFPLEVBQUUsUUFBUSxFQUFFLE1BQU0sOEJBQThCLENBQUM7QUFDeEQsT0FBTyxFQUFFLGtCQUFrQixFQUFFLE1BQU0sZUFBZSxDQUFDO0FBRW5ELE9BQU8sRUFBRSxxQkFBcUIsRUFBRSx1QkFBdUIsRUFBRSxpQkFBaUIsRUFBRSxNQUFNLDBCQUEwQixDQUFDO0FBQzdHLE9BQU8sRUFBRSxlQUFlLEVBQUUsTUFBTSxpQkFBaUIsQ0FBQztBQUNsRCxPQUFPLEVBQ0gsOEJBQThCLEVBQzlCLDhCQUE4QixFQUM5Qix3QkFBd0IsRUFDeEIsOEJBQThCLEVBQ2pDLE1BQU0sZUFBZSxDQUFDO0FBRXZCLE9BQU8sRUFBRSxzQkFBc0IsRUFBb0IsTUFBTSxxQ0FBcUMsQ0FBQztBQUMvRixPQUFPLEVBQUUsbUJBQW1CLEVBQUUsT0FBTyxFQUFFLE1BQU0sZUFBZSxDQUFDO0FBQzdELE9BQU8sRUFDSCwwQkFBMEIsRUFDMUIseUJBQXlCLEVBQ3pCLHVCQUF1QixFQUN2Qix5QkFBeUIsRUFDekIsbUJBQW1CLEVBQ3RCLE1BQU0sd0NBQXdDLENBQUM7QUFLaEQsT0FBTyxFQUFFLGlCQUFpQixFQUFFLE1BQU0sNkJBQTZCLENBQUM7QUFFaEUsT0FBTyxFQUFFLGNBQWMsRUFBRSxNQUFNLHdCQUF3QixDQUFDOzs7Ozs7Ozs7QUFnQnhELE1BQU0sT0FBTyxrQkFBa0I7Ozs7O0lBcytCM0IsWUFBbUIsT0FBcUUs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UCxDQUFDOzs7WUEvSUosU0FBUyxTQUFDO2dCQUNQLGVBQWUsRUFBRSx1QkFBdUIsQ0FBQyxNQUFNO2dCQUMvQyxTQUFTLEVBQUUsQ0FBQyxFQUFFLE9BQU8sRUFBRSxrQkFBa0IsRUFBRSxXQUFXLEVBQUUsVUFBVSxDQUFDLEdBQUcsRUFBRSxDQUFDLHdCQUF3QixDQUFDLEVBQUUsQ0FBQztnQkFDckcsUUFBUSxFQUFFLG1CQUFtQjtnQkFDN0IsUUFBUSxFQUFFLEVBQUU7YUFDZjs7O3FCQXFFSSxLQUFLOzs7O0lBbkVOLDBEQUFtQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XG4gICAgQWZ0ZXJDb250ZW50SW5pdCxcbiAgICBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneSxcbiAgICBDaGFuZ2VEZXRlY3RvclJlZixcbiAgICBDb21wb25lbnQsXG4gICAgQ29udGVudENoaWxkLFxuICAgIENvbnRlbnRDaGlsZHJlbixcbiAgICBJbnB1dCxcbiAgICBRdWVyeUxpc3QsXG4gICAgVGVtcGxhdGVSZWYsXG4gICAgZm9yd2FyZFJlZixcbiAgICBBZnRlclZpZXdJbml0XG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgRGF0YVR5cGUgfSBmcm9tICcuLi9kYXRhLW9wZXJhdGlvbnMvZGF0YS11dGlsJztcbmltcG9ydCB7IEdyaWRCYXNlQVBJU2VydmljZSB9IGZyb20gJy4vYXBpLnNlcnZpY2UnO1xuaW1wb3J0IHsgSWd4R3JpZENlbGxDb21wb25lbnQgfSBmcm9tICcuL2NlbGwuY29tcG9uZW50JztcbmltcG9ydCB7IElneERhdGVTdW1tYXJ5T3BlcmFuZCwgSWd4TnVtYmVyU3VtbWFyeU9wZXJhbmQsIElneFN1bW1hcnlPcGVyYW5kIH0gZnJvbSAnLi9zdW1tYXJpZXMvZ3JpZC1zdW1tYXJ5JztcbmltcG9ydCB7IElneFJvd0NvbXBvbmVudCB9IGZyb20gJy4vcm93LmNvbXBvbmVudCc7XG5pbXBvcnQge1xuICAgIElneENlbGxFZGl0b3JUZW1wbGF0ZURpcmVjdGl2ZSxcbiAgICBJZ3hDZWxsSGVhZGVyVGVtcGxhdGVEaXJlY3RpdmUsXG4gICAgSWd4Q2VsbFRlbXBsYXRlRGlyZWN0aXZlLFxuICAgIElneEZpbHRlckNlbGxUZW1wbGF0ZURpcmVjdGl2ZVxufSBmcm9tICcuL2dyaWQuY29tbW9uJztcbmltcG9ydCB7IElneEdyaWRIZWFkZXJDb21wb25lbnQgfSBmcm9tICcuL2dyaWQtaGVhZGVyLmNvbXBvbmVudCc7XG5pbXBvcnQgeyBEZWZhdWx0U29ydGluZ1N0cmF0ZWd5LCBJU29ydGluZ1N0cmF0ZWd5IH0gZnJvbSAnLi4vZGF0YS1vcGVyYXRpb25zL3NvcnRpbmctc3RyYXRlZ3knO1xuaW1wb3J0IHsgZ2V0Tm9kZVNpemVWaWFSYW5nZSwgZmxhdHRlbiB9IGZyb20gJy4uL2NvcmUvdXRpbHMnO1xuaW1wb3J0IHtcbiAgICBJZ3hCb29sZWFuRmlsdGVyaW5nT3BlcmFuZCxcbiAgICBJZ3hOdW1iZXJGaWx0ZXJpbmdPcGVyYW5kLFxuICAgIElneERhdGVGaWx0ZXJpbmdPcGVyYW5kLFxuICAgIElneFN0cmluZ0ZpbHRlcmluZ09wZXJhbmQsXG4gICAgSWd4RmlsdGVyaW5nT3BlcmFuZFxufSBmcm9tICcuLi9kYXRhLW9wZXJhdGlvbnMvZmlsdGVyaW5nLWNvbmRpdGlvbic7XG5pbXBvcnQgeyBJZ3hHcmlkQmFzZUNvbXBvbmVudCwgSUdyaWREYXRhQmluZGFibGUgfSBmcm9tICcuL2dyaWQtYmFzZS5jb21wb25lbnQnO1xuaW1wb3J0IHsgRmlsdGVyaW5nRXhwcmVzc2lvbnNUcmVlIH0gZnJvbSAnLi4vZGF0YS1vcGVyYXRpb25zL2ZpbHRlcmluZy1leHByZXNzaW9ucy10cmVlJztcbmltcG9ydCB7IElneEdyaWRGaWx0ZXJpbmdDZWxsQ29tcG9uZW50IH0gZnJvbSAnLi9maWx0ZXJpbmcvZ3JpZC1maWx0ZXJpbmctY2VsbC5jb21wb25lbnQnO1xuaW1wb3J0IHsgSWd4R3JpZEhlYWRlckdyb3VwQ29tcG9uZW50IH0gZnJvbSAnLi9ncmlkLWhlYWRlci1ncm91cC5jb21wb25lbnQnO1xuaW1wb3J0IHsgRGVwcmVjYXRlUHJvcGVydHkgfSBmcm9tICcuLi9jb3JlL2RlcHJlY2F0ZURlY29yYXRvcnMnO1xuaW1wb3J0IHsgTVJMQ29sdW1uU2l6ZUluZm8sIE1STFJlc2l6ZUNvbHVtbkluZm8gfSBmcm9tICcuLi9kYXRhLW9wZXJhdGlvbnMvbXVsdGktcm93LWxheW91dC5pbnRlcmZhY2VzJztcbmltcG9ydCB7IERpc3BsYXlEZW5zaXR5IH0gZnJvbSAnLi4vY29yZS9kaXNwbGF5RGVuc2l0eSc7XG5cbi8qKlxuICogKipJZ25pdGUgVUkgZm9yIEFuZ3VsYXIgQ29sdW1uKiogLVxuICogW0RvY3VtZW50YXRpb25dKGh0dHBzOi8vd3d3LmluZnJhZ2lzdGljcy5jb20vcHJvZHVjdHMvaWduaXRlLXVpLWFuZ3VsYXIvYW5ndWxhci9jb21wb25lbnRzL2dyaWQuaHRtbCNjb2x1bW5zLWNvbmZpZ3VyYXRpb24pXG4gKlxuICogVGhlIElnbml0ZSBVSSBDb2x1bW4gaXMgdXNlZCB3aXRoaW4gYW4gYGlneC1ncmlkYCBlbGVtZW50IHRvIGRlZmluZSB3aGF0IGRhdGEgdGhlIGNvbHVtbiB3aWxsIHNob3cuIEZlYXR1cmVzIHN1Y2ggYXMgc29ydGluZyxcbiAqIGZpbHRlcmluZyAmIGVkaXRpbmcgYXJlIGVuYWJsZWQgYXQgdGhlIGNvbHVtbiBsZXZlbC4gIFlvdSBjYW4gYWxzbyBwcm92aWRlIGEgdGVtcGxhdGUgY29udGFpbmluZyBjdXN0b20gY29udGVudCBpbnNpZGVcbiAqIHRoZSBjb2x1bW4gdXNpbmcgYG5nLXRlbXBsYXRlYCB3aGljaCB3aWxsIGJlIHVzZWQgZm9yIGFsbCBjZWxscyB3aXRoaW4gdGhlIGNvbHVtbi5cbiAqL1xuQENvbXBvbmVudCh7XG4gICAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2gsXG4gICAgcHJlc2VydmVXaGl0ZXNwYWNlczogZmFsc2UsXG4gICAgc2VsZWN0b3I6ICdpZ3gtY29sdW1uJyxcbiAgICB0ZW1wbGF0ZTogYGBcbn0pXG5leHBvcnQgY2xhc3MgSWd4Q29sdW1uQ29tcG9uZW50IGltcGxlbWVudHMgQWZ0ZXJDb250ZW50SW5pdCB7XG4gICAgLyoqXG4gICAgICogU2V0cy9nZXRzIHRoZSBgZmllbGRgIHZhbHVlLlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBsZXQgY29sdW1uRmllbGQgPSB0aGlzLmNvbHVtbi5maWVsZDtcbiAgICAgKiBgYGBcbiAgICAgKiBgYGBodG1sXG4gICAgICogPGlneC1jb2x1bW4gW2ZpZWxkXSA9IFwiJ0lEJ1wiPjwvaWd4LWNvbHVtbj5cbiAgICAgKiBgYGBcbiAgICAgKiBAbWVtYmVyb2YgSWd4Q29sdW1uQ29tcG9uZW50XG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBwdWJsaWMgZmllbGQ6IHN0cmluZztcbiAgICAvKipcbiAgICAgKiBTZXRzL2dldHMgdGhlIGBoZWFkZXJgIHZhbHVlLlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBsZXQgY29sdW1uSGVhZGVyID0gdGhpcy5jb2x1bW4uaGVhZGVyO1xuICAgICAqIGBgYFxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8aWd4LWNvbHVtbiBbaGVhZGVyXSA9IFwiJ0lEJ1wiPjwvaWd4LWNvbHVtbj5cbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBJZ3hDb2x1bW5Db21wb25lbnRcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHB1YmxpYyBoZWFkZXIgPSAnJztcbiAgICAvKipcbiAgICAgKiBTZXRzL2dldHMgd2hldGhlciB0aGUgY29sdW1uIGlzIHNvcnRhYmxlLlxuICAgICAqIERlZmF1bHQgdmFsdWUgaXMgYGZhbHNlYC5cbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogbGV0IGlzU29ydGFibGUgPSB0aGlzLmNvbHVtbi5zb3J0YWJsZTtcbiAgICAgKiBgYGBcbiAgICAgKiBgYGBodG1sXG4gICAgICogPGlneC1jb2x1bW4gW3NvcnRhYmxlXSA9IFwidHJ1ZVwiPjwvaWd4LWNvbHVtbj5cbiAgICAgKiBgYGBcbiAgICAgKiBAbWVtYmVyb2YgSWd4Q29sdW1uQ29tcG9uZW50XG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBwdWJsaWMgc29ydGFibGUgPSBmYWxzZTtcbiAgICAvKipcbiAgICAgKiBTZXRzL2dldHMgd2hldGhlciB0aGUgY29sdW1uIGlzIGdyb3VwYWJsZS5cbiAgICAgKiBEZWZhdWx0IHZhbHVlIGlzIGBmYWxzZWAuXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIGxldCBpc0dyb3VwYWJsZSA9IHRoaXMuY29sdW1uLmdyb3VwYWJsZTtcbiAgICAgKiBgYGBcbiAgICAgKiBgYGBodG1sXG4gICAgICogPGlneC1jb2x1bW4gW2dyb3VwYWJsZV0gPSBcInRydWVcIj48L2lneC1jb2x1bW4+XG4gICAgICogYGBgXG4gICAgICogQG1lbWJlcm9mIElneENvbHVtbkNvbXBvbmVudFxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgcHVibGljIGdyb3VwYWJsZSA9IGZhbHNlO1xuICAgIC8qKlxuICAgICAqIFNldHMvZ2V0cyB3aGV0aGVyIHRoZSBjb2x1bW4gaXMgZWRpdGFibGUuXG4gICAgICogRGVmYXVsdCB2YWx1ZSBpcyBgZmFsc2VgLlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBsZXQgaXNFZGl0YWJsZSA9IHRoaXMuY29sdW1uLmVkaXRhYmxlO1xuICAgICAqIGBgYFxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8aWd4LWNvbHVtbiBbZWRpdGFibGVdID0gXCJ0cnVlXCI+PC9pZ3gtY29sdW1uPlxuICAgICAqIGBgYFxuICAgICAqIEBtZW1iZXJvZiBJZ3hDb2x1bW5Db21wb25lbnRcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHB1YmxpYyBlZGl0YWJsZSA9IG51bGw7XG4gICAgLyoqXG4gICAgICogU2V0cy9nZXRzIHdoZXRoZXIgdGhlIGNvbHVtbiBpcyBmaWx0ZXJhYmxlLlxuICAgICAqIERlZmF1bHQgdmFsdWUgaXMgYHRydWVgLlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBsZXQgaXNGaWx0ZXJhYmxlID0gdGhpcy5jb2x1bW4uZmlsdGVyYWJsZTtcbiAgICAgKiBgYGBcbiAgICAgKiBgYGBodG1sXG4gICAgICogPGlneC1jb2x1bW4gW2ZpbHRlcmFibGVdID0gXCJmYWxzZVwiPjwvaWd4LWNvbHVtbj5cbiAgICAgKiBgYGBcbiAgICAgKiBAbWVtYmVyb2YgSWd4Q29sdW1uQ29tcG9uZW50XG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBwdWJsaWMgZmlsdGVyYWJsZSA9IHRydWU7XG4gICAgLyoqXG4gICAgICogU2V0cy9nZXRzIHdoZXRoZXIgdGhlIGNvbHVtbiBpcyByZXNpemFibGUuXG4gICAgICogRGVmYXVsdCB2YWx1ZSBpcyBgZmFsc2VgLlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBsZXQgaXNSZXNpemFibGUgPSB0aGlzLmNvbHVtbi5yZXNpemFibGU7XG4gICAgICogYGBgXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxpZ3gtY29sdW1uIFtyZXNpemFibGVdID0gXCJ0cnVlXCI+PC9pZ3gtY29sdW1uPlxuICAgICAqIGBgYFxuICAgICAqIEBtZW1iZXJvZiBJZ3hDb2x1bW5Db21wb25lbnRcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHB1YmxpYyByZXNpemFibGUgPSBmYWxzZTtcbiAgICAvKipcbiAgICAgKiBHZXRzIGEgdmFsdWUgaW5kaWNhdGluZyB3aGV0aGVyIHRoZSBzdW1tYXJ5IGZvciB0aGUgY29sdW1uIGlzIGVuYWJsZWQuXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIGxldCBoYXNTdW1tYXJ5ID0gdGhpcy5jb2x1bW4uaGFzU3VtbWFyeTtcbiAgICAgKiBgYGBcbiAgICAgKiBAbWVtYmVyb2YgSWd4Q29sdW1uQ29tcG9uZW50XG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBnZXQgaGFzU3VtbWFyeSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2hhc1N1bW1hcnk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgYSB2YWx1ZSBpbmRpY2F0aW5nIHdoZXRoZXIgdGhlIHN1bW1hcnkgZm9yIHRoZSBjb2x1bW4gaXMgZW5hYmxlZC5cbiAgICAgKiBEZWZhdWx0IHZhbHVlIGlzIGBmYWxzZWAuXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxpZ3gtY29sdW1uIFtoYXNTdW1tYXJ5XSA9IFwidHJ1ZVwiPjwvaWd4LWNvbHVtbj5cbiAgICAgKiBgYGBcbiAgICAgKiBAbWVtYmVyb2YgSWd4Q29sdW1uQ29tcG9uZW50XG4gICAgICovXG4gICAgc2V0IGhhc1N1bW1hcnkodmFsdWUpIHtcbiAgICAgICAgdGhpcy5faGFzU3VtbWFyeSA9IHZhbHVlO1xuXG4gICAgICAgIGlmICh0aGlzLmdyaWQpIHtcbiAgICAgICAgICAgIHRoaXMuZ3JpZC5zdW1tYXJ5U2VydmljZS5yZWNhbGN1bGF0ZVN1bW1hcmllcygpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgd2hldGhlciB0aGUgY29sdW1uIGlzIGhpZGRlbi5cbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogbGV0IGlzSGlkZGVuID0gdGhpcy5jb2x1bW4uaGlkZGVuO1xuICAgICAqIGBgYFxuICAgICAqQG1lbWJlcm9mIElneENvbHVtbkNvbXBvbmVudFxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgZ2V0IGhpZGRlbigpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2hpZGRlbjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgY29sdW1uIGhpZGRlbiBwcm9wZXJ0eS5cbiAgICAgKiBEZWZhdWx0IHZhbHVlIGlzIGBmYWxzZWAuXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIDxpZ3gtY29sdW1uIFtoaWRkZW5dID0gXCJ0cnVlXCI+PC9pZ3gtY29sdW1uPlxuICAgICAqIGBgYFxuICAgICAqIEBtZW1iZXJvZiBJZ3hDb2x1bW5Db21wb25lbnRcbiAgICAgKi9cbiAgICBzZXQgaGlkZGVuKHZhbHVlOiBib29sZWFuKSB7XG4gICAgICAgIGlmICh0aGlzLl9oaWRkZW4gIT09IHZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLl9oaWRkZW4gPSB2YWx1ZTtcbiAgICAgICAgICAgIGlmICh0aGlzLmdyaWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmdyaWQucmVzZXRDYWNoZXMoKTtcbiAgICAgICAgICAgICAgICB0aGlzLmdyaWQuZW5kRWRpdChmYWxzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBUT0RPOiBTaW1wbGlmeVxuICAgICAgICAgICAgdGhpcy5jaGVjaygpO1xuICAgICAgICAgICAgaWYgKHRoaXMuZ3JpZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZ3JpZC5yZWZyZXNoU2VhcmNoKHRydWUpO1xuICAgICAgICAgICAgICAgIHRoaXMuZ3JpZC5zdW1tYXJ5U2VydmljZS5yZXNldFN1bW1hcnlIZWlnaHQoKTtcbiAgICAgICAgICAgICAgICB0aGlzLmdyaWQucmVmbG93KCk7XG4gICAgICAgICAgICAgICAgdGhpcy5ncmlkLmZpbHRlcmluZ1NlcnZpY2UucmVmcmVzaEV4cHJlc3Npb25zKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbHVtbkxheW91dENoaWxkICYmIHRoaXMucGFyZW50LmhpZGRlbiAhPT0gdmFsdWUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnBhcmVudC5oaWRkZW4gPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIHdoZXRoZXIgdGhlIGhpZGluZyBpcyBkaXNhYmxlZC5cbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogbGV0IGlzSGlkaW5nRGlzYWJsZWQgPSAgdGhpcy5jb2x1bW4uZGlzYWJsZUhpZGluZztcbiAgICAgKiBgYGBcbiAgICAgKiBAbWVtYmVyb2YgSWd4Q29sdW1uQ29tcG9uZW50XG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBnZXQgZGlzYWJsZUhpZGluZygpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2Rpc2FibGVIaWRpbmc7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVuYWJsZXMvZGlzYWJsZXMgaGlkaW5nIGZvciB0aGUgY29sdW1uLlxuICAgICAqIERlZmF1bHQgdmFsdWUgaXMgYGZhbHNlYC5cbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogPGlneC1jb2x1bW4gW2hpZGRlbl0gPSBcInRydWVcIj48L2lneC1jb2x1bW4+XG4gICAgICogYGBgXG4gICAgICogQG1lbWJlcm9mIElneENvbHVtbkNvbXBvbmVudFxuICAgICAqL1xuICAgIHNldCBkaXNhYmxlSGlkaW5nKHZhbHVlOiBib29sZWFuKSB7XG4gICAgICAgIGlmICh0aGlzLl9kaXNhYmxlSGlkaW5nICE9PSB2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5fZGlzYWJsZUhpZGluZyA9IHZhbHVlO1xuICAgICAgICAgICAgdGhpcy5jaGVjaygpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgd2hldGhlciB0aGUgcGlubmluZyBpcyBkaXNhYmxlZC5cbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogbGV0IGlzUGlubmluZ0Rpc2FibGVkID0gIHRoaXMuY29sdW1uLmRpc2FibGVQaW5uaW5nO1xuICAgICAqIGBgYFxuICAgICAqIEBtZW1iZXJvZiBJZ3hDb2x1bW5Db21wb25lbnRcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIGdldCBkaXNhYmxlUGlubmluZygpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2Rpc2FibGVQaW5uaW5nO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFbmFibGVzL2Rpc2FibGVzIHBpbm5pbmcgZm9yIHRoZSBjb2x1bW4uXG4gICAgICogRGVmYXVsdCB2YWx1ZSBpcyBgZmFsc2VgLlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiA8aWd4LWNvbHVtbiBbcGlubmVkXSA9IFwidHJ1ZVwiPjwvaWd4LWNvbHVtbj5cbiAgICAgKiBgYGBcbiAgICAgKiBAbWVtYmVyb2YgSWd4Q29sdW1uQ29tcG9uZW50XG4gICAgICovXG4gICAgc2V0IGRpc2FibGVQaW5uaW5nKHZhbHVlOiBib29sZWFuKSB7XG4gICAgICAgIGlmICh0aGlzLl9kaXNhYmxlUGlubmluZyAhPT0gdmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuX2Rpc2FibGVQaW5uaW5nID0gdmFsdWU7XG4gICAgICAgICAgICB0aGlzLmNoZWNrKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cy9nZXRzIHdoZXRoZXIgdGhlIGNvbHVtbiBpcyBtb3ZhYmxlLlxuICAgICAqIERlZmF1bHQgdmFsdWUgaXMgYGZhbHNlYC5cbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogbGV0IGlzTW92YWJsZSA9IHRoaXMuY29sdW1uLm1vdmFibGU7XG4gICAgICogYGBgXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxpZ3gtY29sdW1uIFttb3ZhYmxlXSA9IFwidHJ1ZVwiPjwvaWd4LWNvbHVtbj5cbiAgICAgKiBgYGBcbiAgICAgKiBAbWVtYmVyb2YgSWd4Q29sdW1uQ29tcG9uZW50XG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBwdWJsaWMgbW92YWJsZSA9IGZhbHNlO1xuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGB3aWR0aGAgb2YgdGhlIGNvbHVtbi5cbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogbGV0IGNvbHVtbldpZHRoID0gdGhpcy5jb2x1bW4ud2lkdGg7XG4gICAgICogYGBgXG4gICAgICogQG1lbWJlcm9mIElneENvbHVtbkNvbXBvbmVudFxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgcHVibGljIGdldCB3aWR0aCgpOiBzdHJpbmcge1xuICAgICAgICByZXR1cm4gdGhpcy53aWR0aFNldEJ5VXNlciA/IHRoaXMuX3dpZHRoIDogdGhpcy5kZWZhdWx0V2lkdGg7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGB3aWR0aGAgb2YgdGhlIGNvbHVtbi5cbiAgICAgKiBgYGBodG1sXG4gICAgICogPGlneC1jb2x1bW4gW3dpZHRoXSA9IFwiJzI1JSdcIj48L2lneC1jb2x1bW4+XG4gICAgICogYGBgXG4gICAgICogQG1lbWJlcm9mIElneENvbHVtbkNvbXBvbmVudFxuICAgICAqL1xuICAgIHB1YmxpYyBzZXQgd2lkdGgodmFsdWU6IHN0cmluZykge1xuICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuX2NhbGNXaWR0aCA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLmNhbGNQaXhlbFdpZHRoID0gTmFOO1xuICAgICAgICAgICAgdGhpcy53aWR0aFNldEJ5VXNlciA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLl93aWR0aCA9IHZhbHVlO1xuICAgICAgICAgICAgaWYgKHRoaXMuZ3JpZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuY2FjaGVDYWxjV2lkdGgoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0IGNhbGNXaWR0aCgpOiBhbnkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRDYWxjV2lkdGgoKTtcbiAgICB9XG5cbiAgICBwcml2YXRlIF9jYWxjV2lkdGggPSBudWxsO1xuICAgIHB1YmxpYyBjYWxjUGl4ZWxXaWR0aDogbnVtYmVyO1xuXG4gICAgLyoqXG4gICAgICogU2V0cy9nZXRzIHRoZSBtYXhpbXVtIGB3aWR0aGAgb2YgdGhlIGNvbHVtbi5cbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogbGV0IGNvbHVtbk1heFdpZHRoID0gdGhpcy5jb2x1bW4ud2lkdGg7XG4gICAgICogYGBgXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxpZ3gtY29sdW1uIFttYXhXaWR0aF0gPSBcIic3NSUnXCI+PC9pZ3gtY29sdW1uPlxuICAgICAqIGBgYFxuICAgICAqIEBtZW1iZXJvZiBJZ3hDb2x1bW5Db21wb25lbnRcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHB1YmxpYyBtYXhXaWR0aDogc3RyaW5nO1xuICAgIC8qKlxuICAgICAqIFNldHMvZ2V0cyB0aGUgbWluaW11bSBgd2lkdGhgIG9mIHRoZSBjb2x1bW4uXG4gICAgICogRGVmYXVsdCB2YWx1ZSBpcyBgODhgO1xuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBsZXQgY29sdW1uTWluV2lkdGggPSB0aGlzLmNvbHVtbi5taW5XaWR0aDtcbiAgICAgKiBgYGBcbiAgICAgKiBgYGBodG1sXG4gICAgICogPGlneC1jb2x1bW4gW21pbldpZHRoXSA9IFwiJzE1JSdcIj48L2lneC1jb2x1bW4+XG4gICAgICogYGBgXG4gICAgICogQG1lbWJlcm9mIElneENvbHVtbkNvbXBvbmVudFxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgcHVibGljIHNldCBtaW5XaWR0aCh2YWx1ZTogc3RyaW5nKSB7XG4gICAgICAgIGNvbnN0IG1pblZhbCA9IHBhcnNlRmxvYXQodmFsdWUpO1xuICAgICAgICBpZiAoTnVtYmVyLmlzTmFOKG1pblZhbCkpIHsgcmV0dXJuOyB9XG4gICAgICAgIHRoaXMuX2RlZmF1bHRNaW5XaWR0aCA9IHZhbHVlO1xuXG4gICAgfVxuICAgIHB1YmxpYyBnZXQgbWluV2lkdGgoKTogc3RyaW5nIHtcbiAgICAgICAgcmV0dXJuICF0aGlzLl9kZWZhdWx0TWluV2lkdGggPyB0aGlzLmRlZmF1bHRNaW5XaWR0aCA6IHRoaXMuX2RlZmF1bHRNaW5XaWR0aDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cy9nZXRzIHRoZSBjbGFzcyBzZWxlY3RvciBvZiB0aGUgY29sdW1uIGhlYWRlci5cbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogbGV0IGNvbHVtbkhlYWRlckNsYXNzID0gdGhpcy5jb2x1bW4uaGVhZGVyQ2xhc3NlcztcbiAgICAgKiBgYGBcbiAgICAgKiBgYGBodG1sXG4gICAgICogPGlneC1jb2x1bW4gW2hlYWRlckNsYXNzZXNdID0gXCInY29sdW1uLWhlYWRlcidcIj48L2lneC1jb2x1bW4+XG4gICAgICogYGBgXG4gICAgICogQG1lbWJlcm9mIElneENvbHVtbkNvbXBvbmVudFxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgcHVibGljIGhlYWRlckNsYXNzZXMgPSAnJztcblxuICAgIC8qKlxuICAgICAqIFNldHMvZ2V0cyB0aGUgY2xhc3Mgc2VsZWN0b3Igb2YgdGhlIGNvbHVtbiBncm91cCBoZWFkZXIuXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIGxldCBjb2x1bW5IZWFkZXJDbGFzcyA9IHRoaXMuY29sdW1uLmhlYWRlckdyb3VwQ2xhc3NlcztcbiAgICAgKiBgYGBcbiAgICAgKiBgYGBodG1sXG4gICAgICogPGlneC1jb2x1bW4gW2hlYWRlckdyb3VwQ2xhc3Nlc10gPSBcIidjb2x1bW4tZ3JvdXAtaGVhZGVyJ1wiPjwvaWd4LWNvbHVtbj5cbiAgICAgKiBgYGBcbiAgICAgKiBAbWVtYmVyb2YgSWd4Q29sdW1uQ29tcG9uZW50XG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBwdWJsaWMgaGVhZGVyR3JvdXBDbGFzc2VzID0gJyc7XG4gICAgLyoqXG4gICAgICogU2V0cyBhIGNvbmRpdGlvbmFsIGNsYXNzIHNlbGVjdG9yIG9mIHRoZSBjb2x1bW4gY2VsbHMuXG4gICAgICogQWNjZXB0cyBhbiBvYmplY3QgbGl0ZXJhbCwgY29udGFpbmluZyBrZXktdmFsdWUgcGFpcnMsXG4gICAgICogd2hlcmUgdGhlIGtleSBpcyB0aGUgbmFtZSBvZiB0aGUgQ1NTIGNsYXNzLCB3aGlsZSB0aGVcbiAgICAgKiB2YWx1ZSBpcyBlaXRoZXIgYSBjYWxsYmFjayBmdW5jdGlvbiB0aGF0IHJldHVybnMgYSBib29sZWFuLFxuICAgICAqIG9yIGJvb2xlYW4sIGxpa2Ugc286XG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIGNhbGxiYWNrID0gKHJvd0RhdGEsIGNvbHVtbktleSkgPT4geyByZXR1cm4gcm93RGF0YVtjb2x1bW5LZXldID4gNjsgfVxuICAgICAqIGNlbGxDbGFzc2VzID0geyAnY2xhc3NOYW1lJyA6IHRoaXMuY2FsbGJhY2sgfTtcbiAgICAgKiBgYGBcbiAgICAgKiBgYGBodG1sXG4gICAgICogPGlneC1jb2x1bW4gW2NlbGxDbGFzc2VzXSA9IFwiY2VsbENsYXNzZXNcIj48L2lneC1jb2x1bW4+XG4gICAgICogPGlneC1jb2x1bW4gW2NlbGxDbGFzc2VzXSA9IFwieydjbGFzczEnIDogdHJ1ZSB9XCI+PC9pZ3gtY29sdW1uPlxuICAgICAqIGBgYFxuICAgICAqIEBtZW1iZXJvZiBJZ3hDb2x1bW5Db21wb25lbnRcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHB1YmxpYyBjZWxsQ2xhc3NlczogYW55O1xuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGNvbHVtbiBpbmRleC5cbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogbGV0IGNvbHVtbkluZGV4ID0gdGhpcy5jb2x1bW4uaW5kZXg7XG4gICAgICogYGBgXG4gICAgICogQG1lbWJlcm9mIElneENvbHVtbkNvbXBvbmVudFxuICAgICAqL1xuICAgIGdldCBpbmRleCgpOiBudW1iZXIge1xuICAgICAgICByZXR1cm4gdGhpcy5ncmlkLmNvbHVtbnMuaW5kZXhPZih0aGlzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyBmb3JtYXR0ZXIgZm9yIHRoZSBjb2x1bW4uXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIGxldCBjb2x1bW5Gb3JtYXR0ZXIgPSB0aGlzLmNvbHVtbi5mb3JtYXR0ZXI7XG4gICAgICogYGBgXG4gICAgICogQG1lbWJlcm9mIElneENvbHVtbkNvbXBvbmVudFxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgZm9ybWF0dGVyOiAodmFsdWU6IGFueSkgPT4gYW55O1xuICAgIC8qKlxuICAgICAqIFNldHMvZ2V0cyB3aGV0aGVyIHRoZSBjb2x1bW4gZmlsdGVyaW5nIHNob3VsZCBiZSBjYXNlIHNlbnNpdGl2ZS5cbiAgICAgKiBEZWZhdWx0IHZhbHVlIGlzIGB0cnVlYC5cbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogbGV0IGZpbHRlcmluZ0lnbm9yZUNhc2UgPSB0aGlzLmNvbHVtbi5maWx0ZXJpbmdJZ25vcmVDYXNlO1xuICAgICAqIGBgYFxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8aWd4LWNvbHVtbiBbZmlsdGVyaW5nSWdub3JlQ2FzZV0gPSBcImZhbHNlXCI+PC9pZ3gtY29sdW1uPlxuICAgICAqIGBgYFxuICAgICAqIEBtZW1iZXJvZiBJZ3hDb2x1bW5Db21wb25lbnRcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHB1YmxpYyBmaWx0ZXJpbmdJZ25vcmVDYXNlID0gdHJ1ZTtcbiAgICAvKipcbiAgICAgKiBTZXRzL2dldHMgd2hldGhlciB0aGUgY29sdW1uIHNvcnRpbmcgc2hvdWxkIGJlIGNhc2Ugc2Vuc2l0aXZlLlxuICAgICAqIERlZmF1bHQgdmFsdWUgaXMgYHRydWVgLlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBsZXQgc29ydGluZ0lnbm9yZUNhc2UgPSB0aGlzLmNvbHVtbi5zb3J0aW5nSWdub3JlQ2FzZTtcbiAgICAgKiBgYGBcbiAgICAgKiBgYGBodG1sXG4gICAgICogPGlneC1jb2x1bW4gW3NvcnRpbmdJZ25vcmVDYXNlXSA9IFwiZmFsc2VcIj48L2lneC1jb2x1bW4+XG4gICAgICogYGBgXG4gICAgICogQG1lbWJlcm9mIElneENvbHVtbkNvbXBvbmVudFxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgcHVibGljIHNvcnRpbmdJZ25vcmVDYXNlID0gdHJ1ZTtcbiAgICAvKipcbiAgICAgKiBTZXRzL2dldHMgdGhlIGRhdGEgdHlwZSBvZiB0aGUgY29sdW1uIHZhbHVlcy5cbiAgICAgKiBEZWZhdWx0IHZhbHVlIGlzIGBzdHJpbmdgLlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBsZXQgY29sdW1uRGF0YVR5cGUgPSB0aGlzLmNvbHVtbi5kYXRhVHlwZTtcbiAgICAgKiBgYGBcbiAgICAgKiBgYGBodG1sXG4gICAgICogPGlneC1jb2x1bW4gW2RhdGFUeXBlXSA9IFwiJ251bWJlcidcIj48L2lneC1jb2x1bW4+XG4gICAgICogYGBgXG4gICAgICogQG1lbWJlcm9mIElneENvbHVtbkNvbXBvbmVudFxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgcHVibGljIGRhdGFUeXBlOiBEYXRhVHlwZSA9IERhdGFUeXBlLlN0cmluZztcbiAgICAvKipcbiAgICAgKiBHZXRzIHdoZXRoZXIgdGhlIGNvbHVtbiBpcyBgcGlubmVkYC5cbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogbGV0IGlzUGlubmVkID0gdGhpcy5jb2x1bW4ucGlubmVkO1xuICAgICAqIGBgYFxuICAgICAqIEBtZW1iZXJvZiBJZ3hDb2x1bW5Db21wb25lbnRcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHB1YmxpYyBnZXQgcGlubmVkKCk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gdGhpcy5fcGlubmVkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIHdoZXRoZXIgdGhlIGNvbHVtbiBpcyBwaW5uZWQuXG4gICAgICogRGVmYXVsdCB2YWx1ZSBpcyBgZmFsc2VgLlxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8aWd4LWNvbHVtbiBbcGlubmVkXSA9IFwidHJ1ZVwiPjwvaWd4LWNvbHVtbj5cbiAgICAgKiBgYGBcbiAgICAgKiBAbWVtYmVyb2YgSWd4Q29sdW1uQ29tcG9uZW50XG4gICAgICovXG4gICAgcHVibGljIHNldCBwaW5uZWQodmFsdWU6IGJvb2xlYW4pIHtcbiAgICAgICAgaWYgKHRoaXMuX3Bpbm5lZCAhPT0gdmFsdWUpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmdyaWQgJiYgdGhpcy53aWR0aCAmJiAhaXNOYU4ocGFyc2VJbnQodGhpcy53aWR0aCwgMTApKSkge1xuICAgICAgICAgICAgICAgIHZhbHVlID8gdGhpcy5waW4oKSA6IHRoaXMudW5waW4oKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvKiBObyBncmlkL3dpZHRoIGF2YWlsYWJsZSBhdCBpbml0aWFsaXphdGlvbi4gYGluaXRQaW5uaW5nYCBpbiB0aGUgZ3JpZFxuICAgICAgICAgICAgICAgd2lsbCByZS1pbml0IHRoZSBncm91cCAoaWYgcHJlc2VudClcbiAgICAgICAgICAgICovXG4gICAgICAgICAgICB0aGlzLl9waW5uZWQgPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAZGVwcmVjYXRlZFxuICAgICAqIEdldHMvU2V0cyB0aGUgYGlkYCBvZiB0aGUgYGlneC1ncmlkYC5cbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogbGV0IGNvbHVtbkdyaWRJZCA9IHRoaXMuY29sdW1uLmdyaWRJRDtcbiAgICAgKiBgYGBcbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogdGhpcy5jb2x1bW4uZ3JpZElEID0gJ2dyaWQtMSc7XG4gICAgICogYGBgXG4gICAgICogQG1lbWJlcm9mIElneENvbHVtbkNvbXBvbmVudFxuICAgICAqL1xuICAgIEBEZXByZWNhdGVQcm9wZXJ0eShgVGhlIHByb3BlcnR5IGlzIGRlcHJlY2F0ZWQuIFBsZWFzZSwgdXNlIFxcYGNvbHVtbi5ncmlkLmlkXFxgIGluc3RlYWQuYClcbiAgICBwdWJsaWMgZ3JpZElEOiBzdHJpbmc7XG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgY29sdW1uIGBzdW1tYXJpZXNgLlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBsZXQgY29sdW1uU3VtbWFyaWVzID0gdGhpcy5jb2x1bW4uc3VtbWFyaWVzO1xuICAgICAqIGBgYFxuICAgICAqIEBtZW1iZXJvZiBJZ3hDb2x1bW5Db21wb25lbnRcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHB1YmxpYyBnZXQgc3VtbWFyaWVzKCk6IGFueSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zdW1tYXJpZXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGNvbHVtbiBgc3VtbWFyaWVzYC5cbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogdGhpcy5jb2x1bW4uc3VtbWFyaWVzID0gSWd4TnVtYmVyU3VtbWFyeU9wZXJhbmQ7XG4gICAgICogYGBgXG4gICAgICogQG1lbWJlcm9mIElneENvbHVtbkNvbXBvbmVudFxuICAgICAqL1xuICAgIHB1YmxpYyBzZXQgc3VtbWFyaWVzKGNsYXNzUmVmOiBhbnkpIHtcbiAgICAgICAgdGhpcy5fc3VtbWFyaWVzID0gbmV3IGNsYXNzUmVmKCk7XG5cbiAgICAgICAgaWYgKHRoaXMuZ3JpZCkge1xuICAgICAgICAgICAgdGhpcy5ncmlkLnN1bW1hcnlTZXJ2aWNlLnJlbW92ZVN1bW1hcmllc0NhY2hlUGVyQ29sdW1uKHRoaXMuZmllbGQpO1xuICAgICAgICAgICAgKHRoaXMuZ3JpZCBhcyBhbnkpLl9zdW1tYXJ5UGlwZVRyaWdnZXIrKztcbiAgICAgICAgICAgIHRoaXMuZ3JpZC5zdW1tYXJ5U2VydmljZS5yZWNhbGN1bGF0ZVN1bW1hcmllcygpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMvZ2V0cyB3aGV0aGVyIHRoZSBjb2x1bW4gaXMgYHNlYXJjaGFibGVgLlxuICAgICAqIERlZmF1bHQgdmFsdWUgaXMgYHRydWVgLlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBsZXQgaXNTZWFyY2hhYmxlID0gIHRoaXMuY29sdW1uLnNlYXJjaGFibGUnO1xuICAgICAqIGBgYFxuICAgICAqIGBgYGh0bWxcbiAgICAgKiAgPGlneC1jb2x1bW4gW3NlYXJjaGFibGVdID0gXCJmYWxzZVwiPjwvaWd4LWNvbHVtbj5cbiAgICAgKiBgYGBcbiAgICAgKiBAbWVtYmVyb2YgSWd4Q29sdW1uQ29tcG9uZW50XG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBwdWJsaWMgc2VhcmNoYWJsZSA9IHRydWU7XG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgY29sdW1uIGBmaWx0ZXJzYC5cbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogbGV0IGNvbHVtbkZpbHRlcnMgPSB0aGlzLmNvbHVtbi5maWx0ZXJzJ1xuICAgICAqIGBgYFxuICAgICAqIEBtZW1iZXJvZiBJZ3hDb2x1bW5Db21wb25lbnRcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHB1YmxpYyBnZXQgZmlsdGVycygpOiBJZ3hGaWx0ZXJpbmdPcGVyYW5kIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ZpbHRlcnM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGNvbHVtbiBgZmlsdGVyc2AuXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIHRoaXMuY29sdW1uLmZpbHRlcnMgPSBJZ3hCb29sZWFuRmlsdGVyaW5nT3BlcmFuZC5pbnN0YW5jZSgpLlxuICAgICAqIGBgYFxuICAgICAqIEBtZW1iZXJvZiBJZ3hDb2x1bW5Db21wb25lbnRcbiAgICAgKi9cbiAgICBwdWJsaWMgc2V0IGZpbHRlcnMoaW5zdGFuY2U6IElneEZpbHRlcmluZ09wZXJhbmQpIHtcbiAgICAgICAgdGhpcy5fZmlsdGVycyA9IGluc3RhbmNlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBjb2x1bW4gYHNvcnRTdHJhdGVneWAuXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIGxldCBzb3J0U3RyYXRlZ3kgPSB0aGlzLmNvbHVtbi5zb3J0U3RyYXRlZ3knXG4gICAgICogYGBgXG4gICAgICogQG1lbWJlcm9mIElneENvbHVtbkNvbXBvbmVudFxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgcHVibGljIGdldCBzb3J0U3RyYXRlZ3koKTogSVNvcnRpbmdTdHJhdGVneSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zb3J0U3RyYXRlZ3k7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGNvbHVtbiBgc29ydFN0cmF0ZWd5YC5cbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogdGhpcy5jb2x1bW4uc29ydFN0cmF0ZWd5ID0gbmV3IEN1c3RvbVNvcnRpbmdTdHJhdGVneSgpLlxuICAgICAqXG4gICAgICogY2xhc3MgQ3VzdG9tU29ydGluZ1N0cmF0ZWd5IGV4dGVuZHMgU29ydGluZ1N0cmF0ZWd5IHtcbiAgICAgKiAuLi5cbiAgICAgKiB9XG4gICAgICogYGBgXG4gICAgICogQG1lbWJlcm9mIElneENvbHVtbkNvbXBvbmVudFxuICAgICAqL1xuICAgIHB1YmxpYyBzZXQgc29ydFN0cmF0ZWd5KGNsYXNzUmVmOiBJU29ydGluZ1N0cmF0ZWd5KSB7XG4gICAgICAgIHRoaXMuX3NvcnRTdHJhdGVneSA9IGNsYXNzUmVmO1xuICAgIH1cbiAgICAvKipcbiAgICAqIEdldHMgdGhlIGZ1bmN0aW9uIHRoYXQgY29tcGFyZXMgdmFsdWVzIGZvciBncm91cGluZy5cbiAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAqIGxldCBncm91cGluZ0NvbXBhcmVyID0gdGhpcy5jb2x1bW4uZ3JvdXBpbmdDb21wYXJlcidcbiAgICAqIGBgYFxuICAgICogQG1lbWJlcm9mIElneENvbHVtbkNvbXBvbmVudFxuICAgICovXG4gICAgQElucHV0KClcbiAgICBwdWJsaWMgZ2V0IGdyb3VwaW5nQ29tcGFyZXIoKTogKGE6IGFueSwgYjogYW55KSA9PiBudW1iZXIge1xuICAgICAgICByZXR1cm4gdGhpcy5fZ3JvdXBpbmdDb21wYXJlcjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyBhIGN1c3RvbSBmdW5jdGlvbiB0byBjb21wYXJlIHZhbHVlcyBmb3IgZ3JvdXBpbmcuXG4gICAgICogU3Vic2VxdWVudCB2YWx1ZXMgaW4gdGhlIHNvcnRlZCBkYXRhIHRoYXQgdGhlIGZ1bmN0aW9uIHJldHVybnMgMCBmb3IgYXJlIGdyb3VwZWQuXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIHRoaXMuY29sdW1uLmdyb3VwaW5nQ29tcGFyZXIgPSAoYTogYW55LCBiOiBhbnkpID0+IHsgcmV0dXJuIGEgPT09IGIgPyAwIDogLTE7IH1cbiAgICAgKiBgYGBcbiAgICAgKiBAbWVtYmVyb2YgSWd4Q29sdW1uQ29tcG9uZW50XG4gICAgICovXG4gICAgcHVibGljIHNldCBncm91cGluZ0NvbXBhcmVyKGZ1bmNSZWY6IChhOiBhbnksIGI6IGFueSkgPT4gbnVtYmVyKSB7XG4gICAgICAgIHRoaXMuX2dyb3VwaW5nQ29tcGFyZXIgPSBmdW5jUmVmO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBkZWZhdWx0IG1pbmltdW0gYHdpZHRoYCBvZiB0aGUgY29sdW1uLlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBsZXQgZGVmYXVsdE1pbldpZHRoID0gIHRoaXMuY29sdW1uLmRlZmF1bHRNaW5XaWR0aDtcbiAgICAgKiBgYGBcbiAgICAgKiBAbWVtYmVyb2YgSWd4Q29sdW1uQ29tcG9uZW50XG4gICAgICovXG4gICAgZ2V0IGRlZmF1bHRNaW5XaWR0aCgpOiBzdHJpbmcge1xuICAgICAgICBpZiAoIXRoaXMuZ3JpZCkgeyByZXR1cm4gJzgwJzsgfVxuICAgICAgICBzd2l0Y2ggKHRoaXMuZ3JpZC5kaXNwbGF5RGVuc2l0eSkge1xuICAgICAgICAgICAgY2FzZSBEaXNwbGF5RGVuc2l0eS5jb3N5OlxuICAgICAgICAgICAgICAgIHJldHVybiAnNjQnO1xuICAgICAgICAgICAgY2FzZSBEaXNwbGF5RGVuc2l0eS5jb21wYWN0OlxuICAgICAgICAgICAgICAgIHJldHVybiAnNTYnO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZXR1cm4gJzgwJztcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgcmVmZXJlbmNlIHRvIHRoZSBgaWd4LWdyaWRgIG93bmVyLlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBsZXQgZ3JpZENvbXBvbmVudCA9IHRoaXMuY29sdW1uLmdyaWQ7XG4gICAgICogYGBgXG4gICAgICogQG1lbWJlcm9mIElneENvbHVtbkNvbXBvbmVudFxuICAgICAqL1xuICAgIHB1YmxpYyBncmlkOiBJZ3hHcmlkQmFzZUNvbXBvbmVudDtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgcmVmZXJlbmNlIHRvIHRoZSBgYm9keVRlbXBsYXRlYC5cbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogbGV0IGJvZHlUZW1wbGF0ZSA9IHRoaXMuY29sdW1uLmJvZHlUZW1wbGF0ZTtcbiAgICAgKiBgYGBcbiAgICAgKiBAbWVtYmVyb2YgSWd4Q29sdW1uQ29tcG9uZW50XG4gICAgICovXG4gICAgQElucHV0KCdjZWxsVGVtcGxhdGUnKVxuICAgIGdldCBib2R5VGVtcGxhdGUoKTogVGVtcGxhdGVSZWY8YW55PiB7XG4gICAgICAgIHJldHVybiB0aGlzLl9ib2R5VGVtcGxhdGU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGJvZHkgdGVtcGxhdGUuXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxuZy10ZW1wbGF0ZSAjYm9keVRlbXBsYXRlIGlneENlbGwgbGV0LXZhbD5cbiAgICAgKiAgICA8ZGl2IHN0eWxlID0gXCJiYWNrZ3JvdW5kLWNvbG9yOiB5ZWxsb3dncmVlblwiIChjbGljaykgPSBcImNoYW5nZUNvbG9yKHZhbClcIj5cbiAgICAgKiAgICAgICA8c3Bhbj4ge3t2YWx9fSA8L3NwYW4+XG4gICAgICogICAgPC9kaXY+XG4gICAgICogPC9uZy10ZW1wbGF0ZT5cbiAgICAgKiBgYGBcbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogQFZpZXdDaGlsZChcIidib2R5VGVtcGxhdGUnXCIsIHtyZWFkOiBUZW1wbGF0ZVJlZiB9KVxuICAgICAqIHB1YmxpYyBib2R5VGVtcGxhdGU6IFRlbXBsYXRlUmVmPGFueT47XG4gICAgICogdGhpcy5jb2x1bW4uYm9keVRlbXBsYXRlID0gdGhpcy5ib2R5VGVtcGxhdGU7XG4gICAgICogYGBgXG4gICAgICogQG1lbWJlcm9mIElneENvbHVtbkNvbXBvbmVudFxuICAgICAqL1xuICAgIHNldCBib2R5VGVtcGxhdGUodGVtcGxhdGU6IFRlbXBsYXRlUmVmPGFueT4pIHtcbiAgICAgICAgdGhpcy5fYm9keVRlbXBsYXRlID0gdGVtcGxhdGU7XG4gICAgICAgIGlmICh0aGlzLmdyaWQpIHtcbiAgICAgICAgICAgIHRoaXMuZ3JpZC5jZHIubWFya0ZvckNoZWNrKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIHJlZmVyZW5jZSB0byB0aGUgaGVhZGVyIHRlbXBsYXRlLlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBsZXQgaGVhZGVyVGVtcGxhdGUgPSB0aGlzLmNvbHVtbi5oZWFkZXJUZW1wbGF0ZTtcbiAgICAgKiBgYGBcbiAgICAgKiBAbWVtYmVyb2YgSWd4Q29sdW1uQ29tcG9uZW50XG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBnZXQgaGVhZGVyVGVtcGxhdGUoKTogVGVtcGxhdGVSZWY8YW55PiB7XG4gICAgICAgIHJldHVybiB0aGlzLl9oZWFkZXJUZW1wbGF0ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgaGVhZGVyIHRlbXBsYXRlLlxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8bmctdGVtcGxhdGUgI2hlYWRlclRlbXBsYXRlPlxuICAgICAqICAgPGRpdiBzdHlsZSA9IFwiYmFja2dyb3VuZC1jb2xvcjpibGFja1wiIChjbGljaykgPSBcImNoYW5nZUNvbG9yKHZhbClcIj5cbiAgICAgKiAgICAgICA8c3BhbiBzdHlsZT1cImNvbG9yOnJlZFwiID57e2NvbHVtbi5maWVsZH19PC9zcGFuPlxuICAgICAqICAgPC9kaXY+XG4gICAgICogPC9uZy10ZW1wbGF0ZT5cbiAgICAgKiBgYGBcbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogQFZpZXdDaGlsZChcIidoZWFkZXJUZW1wbGF0ZSdcIiwge3JlYWQ6IFRlbXBsYXRlUmVmIH0pXG4gICAgICogcHVibGljIGhlYWRlclRlbXBsYXRlOiBUZW1wbGF0ZVJlZjxhbnk+O1xuICAgICAqIHRoaXMuY29sdW1uLmhlYWRlclRlbXBsYXRlID0gdGhpcy5oZWFkZXJUZW1wbGF0ZTtcbiAgICAgKiBgYGBcbiAgICAgKiBAbWVtYmVyb2YgSWd4Q29sdW1uQ29tcG9uZW50XG4gICAgICovXG4gICAgc2V0IGhlYWRlclRlbXBsYXRlKHRlbXBsYXRlOiBUZW1wbGF0ZVJlZjxhbnk+KSB7XG4gICAgICAgIHRoaXMuX2hlYWRlclRlbXBsYXRlID0gdGVtcGxhdGU7XG4gICAgICAgIGlmICh0aGlzLmdyaWQpIHtcbiAgICAgICAgICAgIHRoaXMuZ3JpZC5jZHIubWFya0ZvckNoZWNrKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIHJlZmVyZW5jZSB0byB0aGUgaW5saW5lIGVkaXRvciB0ZW1wbGF0ZS5cbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogbGV0IGlubGluZUVkaXRvclRlbXBsYXRlID0gdGhpcy5jb2x1bW4uaW5saW5lRWRpdG9yVGVtcGxhdGU7XG4gICAgICogYGBgXG4gICAgICogQG1lbWJlcm9mIElneENvbHVtbkNvbXBvbmVudFxuICAgICAqL1xuICAgIEBJbnB1dCgnY2VsbEVkaXRvclRlbXBsYXRlJylcbiAgICBnZXQgaW5saW5lRWRpdG9yVGVtcGxhdGUoKTogVGVtcGxhdGVSZWY8YW55PiB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pbmxpbmVFZGl0b3JUZW1wbGF0ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgaW5saW5lIGVkaXRvciB0ZW1wbGF0ZS5cbiAgICAgKiBgYGBodG1sXG4gICAgICogPG5nLXRlbXBsYXRlICNpbmxpbmVFZGl0b3JUZW1wbGF0ZSBpZ3hDZWxsRWRpdG9yIGxldC1jZWxsPVwiY2VsbFwiPlxuICAgICAqICAgICA8aW5wdXQgdHlwZT1cInN0cmluZ1wiIFsobmdNb2RlbCldPVwiY2VsbC52YWx1ZVwiLz5cbiAgICAgKiA8L25nLXRlbXBsYXRlPlxuICAgICAqIGBgYFxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBAVmlld0NoaWxkKFwiJ2lubGluZUVkaXRvclRlbXBsYXRlJ1wiLCB7cmVhZDogVGVtcGxhdGVSZWYgfSlcbiAgICAgKiBwdWJsaWMgaW5saW5lRWRpdG9yVGVtcGxhdGU6IFRlbXBsYXRlUmVmPGFueT47XG4gICAgICogdGhpcy5jb2x1bW4uaW5saW5lRWRpdG9yVGVtcGxhdGUgPSB0aGlzLmlubGluZUVkaXRvclRlbXBsYXRlO1xuICAgICAqIGBgYFxuICAgICAqIEBtZW1iZXJvZiBJZ3hDb2x1bW5Db21wb25lbnRcbiAgICAgKi9cbiAgICBzZXQgaW5saW5lRWRpdG9yVGVtcGxhdGUodGVtcGxhdGU6IFRlbXBsYXRlUmVmPGFueT4pIHtcbiAgICAgICAgdGhpcy5faW5saW5lRWRpdG9yVGVtcGxhdGUgPSB0ZW1wbGF0ZTtcbiAgICAgICAgaWYgKHRoaXMuZ3JpZCkge1xuICAgICAgICAgICAgdGhpcy5ncmlkLmNkci5tYXJrRm9yQ2hlY2soKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgcmVmZXJlbmNlIHRvIHRoZSBgZmlsdGVyQ2VsbFRlbXBsYXRlYC5cbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogbGV0IGZpbHRlckNlbGxUZW1wbGF0ZSA9IHRoaXMuY29sdW1uLmZpbHRlckNlbGxUZW1wbGF0ZTtcbiAgICAgKiBgYGBcbiAgICAgKiBAbWVtYmVyb2YgSWd4Q29sdW1uQ29tcG9uZW50XG4gICAgICovXG4gICAgQElucHV0KCdmaWx0ZXJDZWxsVGVtcGxhdGUnKVxuICAgIGdldCBmaWx0ZXJDZWxsVGVtcGxhdGUoKTogVGVtcGxhdGVSZWY8YW55PiB7XG4gICAgICAgIHJldHVybiB0aGlzLl9maWx0ZXJDZWxsVGVtcGxhdGU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIHF1aWNrIGZpbHRlciB0ZW1wbGF0ZS5cbiAgICAgKiBgYGBodG1sXG4gICAgICogPG5nLXRlbXBsYXRlICNmaWx0ZXJDZWxsVGVtcGxhdGUgSWd4RmlsdGVyQ2VsbFRlbXBsYXRlIGxldC1jb2x1bW49XCJjb2x1bW5cIj5cbiAgICAgKiAgICA8aW5wdXQgKGlucHV0KT1cIm9uSW5wdXQoKVwiPlxuICAgICAqIDwvbmctdGVtcGxhdGU+XG4gICAgICogYGBgXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIEBWaWV3Q2hpbGQoXCInZmlsdGVyQ2VsbFRlbXBsYXRlJ1wiLCB7cmVhZDogVGVtcGxhdGVSZWYgfSlcbiAgICAgKiBwdWJsaWMgZmlsdGVyQ2VsbFRlbXBsYXRlOiBUZW1wbGF0ZVJlZjxhbnk+O1xuICAgICAqIHRoaXMuY29sdW1uLmZpbHRlckNlbGxUZW1wbGF0ZSA9IHRoaXMuZmlsdGVyQ2VsbFRlbXBsYXRlO1xuICAgICAqIGBgYFxuICAgICAqIEBtZW1iZXJvZiBJZ3hDb2x1bW5Db21wb25lbnRcbiAgICAgKi9cbiAgICBzZXQgZmlsdGVyQ2VsbFRlbXBsYXRlKHRlbXBsYXRlOiBUZW1wbGF0ZVJlZjxhbnk+KSB7XG4gICAgICAgIHRoaXMuX2ZpbHRlckNlbGxUZW1wbGF0ZSA9IHRlbXBsYXRlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBjZWxscyBvZiB0aGUgY29sdW1uLlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBsZXQgY29sdW1uQ2VsbHMgPSAgdGhpcy5jb2x1bW4uY2VsbHM7XG4gICAgICogYGBgXG4gICAgICogQG1lbWJlcm9mIElneENvbHVtbkNvbXBvbmVudFxuICAgICAqL1xuICAgIGdldCBjZWxscygpOiBJZ3hHcmlkQ2VsbENvbXBvbmVudFtdIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ3JpZC5yb3dMaXN0LmZpbHRlcigocm93KSA9PiByb3cgaW5zdGFuY2VvZiBJZ3hSb3dDb21wb25lbnQpXG4gICAgICAgICAgICAubWFwKChyb3cpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAocm93LmNlbGxzKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByb3cuY2VsbHMuZmlsdGVyKChjZWxsKSA9PiBjZWxsLmNvbHVtbkluZGV4ID09PSB0aGlzLmluZGV4KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KS5yZWR1Y2UoKGEsIGIpID0+IGEuY29uY2F0KGIpLCBbXSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGNvbHVtbiB2aXNpYmxlIGluZGV4LlxuICAgICAqIElmIHRoZSBjb2x1bW4gaXMgbm90IHZpc2libGUsIHJldHVybnMgYC0xYC5cbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogbGV0IHZpc2libGVDb2x1bW5JbmRleCA9ICB0aGlzLmNvbHVtbi52aXNpYmxlSW5kZXg7XG4gICAgICogYGBgXG4gICAgICogQG1lbWJlcm9mIElneENvbHVtbkNvbXBvbmVudFxuICAgICAqL1xuICAgIGdldCB2aXNpYmxlSW5kZXgoKTogbnVtYmVyIHtcbiAgICAgICAgaWYgKCFpc05hTih0aGlzLl92SW5kZXgpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fdkluZGV4O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHVucGlubmVkQ29sdW1ucyA9IHRoaXMuZ3JpZC51bnBpbm5lZENvbHVtbnMuZmlsdGVyKGMgPT4gIWMuY29sdW1uR3JvdXApO1xuICAgICAgICBjb25zdCBwaW5uZWRDb2x1bW5zID0gdGhpcy5ncmlkLnBpbm5lZENvbHVtbnMuZmlsdGVyKGMgPT4gIWMuY29sdW1uR3JvdXApO1xuICAgICAgICBsZXQgY29sID0gdGhpcztcbiAgICAgICAgbGV0IHZJbmRleCA9IC0xO1xuXG4gICAgICAgIGlmICh0aGlzLmNvbHVtbkdyb3VwKSB7XG4gICAgICAgICAgICBjb2wgPSB0aGlzLmFsbENoaWxkcmVuLmZpbHRlcihjID0+ICFjLmNvbHVtbkdyb3VwKVswXSBhcyBhbnk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuY29sdW1uTGF5b3V0Q2hpbGQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcmVudC5jaGlsZHJlblZpc2libGVJbmRleGVzLmZpbmQoeCA9PiB4LmNvbHVtbiA9PT0gdGhpcykuaW5kZXg7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXRoaXMucGlubmVkKSB7XG4gICAgICAgICAgICBjb25zdCBpbmRleEluQ29sbGVjdGlvbiA9IHVucGlubmVkQ29sdW1ucy5pbmRleE9mKGNvbCk7XG4gICAgICAgICAgICB2SW5kZXggPSBpbmRleEluQ29sbGVjdGlvbiA9PT0gLTEgPyAtMSA6IHBpbm5lZENvbHVtbnMubGVuZ3RoICsgaW5kZXhJbkNvbGxlY3Rpb247XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2SW5kZXggPSBwaW5uZWRDb2x1bW5zLmluZGV4T2YoY29sKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl92SW5kZXggPSB2SW5kZXg7XG4gICAgICAgIHJldHVybiB2SW5kZXg7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBib29sZWFuIGluZGljYXRpbmcgaWYgdGhlIGNvbHVtbiBpcyBhIGBDb2x1bW5Hcm91cGAuXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIGxldCBjb2x1bW5Hcm91cCA9ICB0aGlzLmNvbHVtbi5jb2x1bW5Hcm91cDtcbiAgICAgKiBgYGBcbiAgICAgKiBAbWVtYmVyb2YgSWd4Q29sdW1uQ29tcG9uZW50XG4gICAgICovXG4gICAgZ2V0IGNvbHVtbkdyb3VwKCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBib29sZWFuIGluZGljYXRpbmcgaWYgdGhlIGNvbHVtbiBpcyBhIGBDb2x1bW5MYXlvdXRgIGZvciBtdWx0aS1yb3cgbGF5b3V0LlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBsZXQgY29sdW1uR3JvdXAgPSAgdGhpcy5jb2x1bW4uY29sdW1uR3JvdXA7XG4gICAgICogYGBgXG4gICAgICogQG1lbWJlcm9mIElneENvbHVtbkNvbXBvbmVudFxuICAgICAqL1xuICAgIGdldCBjb2x1bW5MYXlvdXQoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAgLyoqXG4gICAgICogUmV0dXJucyBhIGJvb2xlYW4gaW5kaWNhdGluZyBpZiB0aGUgY29sdW1uIGlzIGEgY2hpbGQgb2YgYSBgQ29sdW1uTGF5b3V0YCBmb3IgbXVsdGktcm93IGxheW91dC5cbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogbGV0IGNvbHVtbkxheW91dENoaWxkID0gIHRoaXMuY29sdW1uLmNvbHVtbkxheW91dENoaWxkO1xuICAgICAqIGBgYFxuICAgICAqIEBtZW1iZXJvZiBJZ3hDb2x1bW5Db21wb25lbnRcbiAgICAgKi9cbiAgICBnZXQgY29sdW1uTGF5b3V0Q2hpbGQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcmVudCAmJiB0aGlzLnBhcmVudC5jb2x1bW5MYXlvdXQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgY2hpbGRyZW4gY29sdW1ucyBjb2xsZWN0aW9uLlxuICAgICAqIFJldHVybnMgYW4gZW1wdHkgYXJyYXkgaWYgdGhlIGNvbHVtbiBkb2VzIG5vdCBjb250YWluIGNoaWxkcmVuIGNvbHVtbnMuXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIGxldCBjaGlsZHJlbkNvbHVtbnMgPSAgdGhpcy5jb2x1bW4uYWxsQ2hpbGRyZW47XG4gICAgICogYGBgXG4gICAgICogQG1lbWJlcm9mIElneENvbHVtbkNvbXBvbmVudFxuICAgICAqL1xuICAgIGdldCBhbGxDaGlsZHJlbigpOiBJZ3hDb2x1bW5Db21wb25lbnRbXSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgbGV2ZWwgb2YgdGhlIGNvbHVtbiBpbiBhIGNvbHVtbiBncm91cC5cbiAgICAgKiBSZXR1cm5zIGAwYCBpZiB0aGUgY29sdW1uIGRvZXNuJ3QgaGF2ZSBhIGBwYXJlbnRgLlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBsZXQgY29sdW1uTGV2ZWwgPSAgdGhpcy5jb2x1bW4ubGV2ZWw7XG4gICAgICogYGBgXG4gICAgICogQG1lbWJlcm9mIElneENvbHVtbkNvbXBvbmVudFxuICAgICAqL1xuICAgIGdldCBsZXZlbCgpIHtcbiAgICAgICAgbGV0IHB0ciA9IHRoaXMucGFyZW50O1xuICAgICAgICBsZXQgbHZsID0gMDtcblxuICAgICAgICB3aGlsZSAocHRyKSB7XG4gICAgICAgICAgICBsdmwrKztcbiAgICAgICAgICAgIHB0ciA9IHB0ci5wYXJlbnQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGx2bDtcbiAgICB9XG5cbiAgICBnZXQgaXNMYXN0UGlubmVkKCk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gdGhpcy5ncmlkLnBpbm5lZENvbHVtbnNbdGhpcy5ncmlkLnBpbm5lZENvbHVtbnMubGVuZ3RoIC0gMV0gPT09IHRoaXM7XG4gICAgfVxuICAgIGdldCBncmlkUm93U3BhbigpOiBudW1iZXIge1xuICAgICAgICByZXR1cm4gdGhpcy5yb3dFbmQgJiYgdGhpcy5yb3dTdGFydCA/IHRoaXMucm93RW5kIC0gdGhpcy5yb3dTdGFydCA6IDE7XG4gICAgfVxuICAgIGdldCBncmlkQ29sdW1uU3BhbigpOiBudW1iZXIge1xuICAgICAgICByZXR1cm4gdGhpcy5jb2xFbmQgJiYgdGhpcy5jb2xTdGFydCA/IHRoaXMuY29sRW5kIC0gdGhpcy5jb2xTdGFydCA6IDE7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUm93IGluZGV4IHdoZXJlIHRoZSBjdXJyZW50IGZpZWxkIHNob3VsZCBlbmQuXG4gICAgICogVGhlIGFtb3VudCBvZiByb3dzIGJldHdlZW4gcm93U3RhcnQgYW5kIHJvd0VuZCB3aWxsIGRldGVybWluZSB0aGUgYW1vdW50IG9mIHNwYW5uaW5nIHJvd3MgdG8gdGhhdCBmaWVsZFxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8aWd4LWNvbHVtbi1sYXlvdXQ+XG4gICAgICogICA8aWd4LWNvbHVtbiBbcm93RW5kXT1cIjJcIiBbcm93U3RhcnRdPVwiMVwiIFtjb2xTdGFydF09XCIxXCI+PC9pZ3gtY29sdW1uPlxuICAgICAqIDwvaWd4LWNvbHVtbi1sYXlvdXQ+XG4gICAgICogYGBgXG4gICAgICogQG1lbWJlcm9mIElneENvbHVtbkNvbXBvbmVudFxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgcHVibGljIHJvd0VuZDogbnVtYmVyO1xuXG4gICAgLyoqXG4gICAgICogQ29sdW1uIGluZGV4IHdoZXJlIHRoZSBjdXJyZW50IGZpZWxkIHNob3VsZCBlbmQuXG4gICAgICogVGhlIGFtb3VudCBvZiBjb2x1bW5zIGJldHdlZW4gY29sU3RhcnQgYW5kIGNvbEVuZCB3aWxsIGRldGVybWluZSB0aGUgYW1vdW50IG9mIHNwYW5uaW5nIGNvbHVtbnMgdG8gdGhhdCBmaWVsZFxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8aWd4LWNvbHVtbi1sYXlvdXQ+XG4gICAgICogICA8aWd4LWNvbHVtbiBbY29sRW5kXT1cIjNcIiBbcm93U3RhcnRdPVwiMVwiIFtjb2xTdGFydF09XCIxXCI+PC9pZ3gtY29sdW1uPlxuICAgICAqIDwvaWd4LWNvbHVtbi1sYXlvdXQ+XG4gICAgICogYGBgXG4gICAgICogQG1lbWJlcm9mIElneENvbHVtbkNvbXBvbmVudFxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgcHVibGljIGNvbEVuZDogbnVtYmVyO1xuXG4gICAgLyoqXG4gICAgICogUm93IGluZGV4IGZyb20gd2hpY2ggdGhlIGZpZWxkIGlzIHN0YXJ0aW5nLlxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8aWd4LWNvbHVtbi1sYXlvdXQ+XG4gICAgICogICA8aWd4LWNvbHVtbiBbcm93U3RhcnRdPVwiMVwiIFtjb2xTdGFydF09XCIxXCI+PC9pZ3gtY29sdW1uPlxuICAgICAqIDwvaWd4LWNvbHVtbi1sYXlvdXQ+XG4gICAgICogYGBgXG4gICAgICogQG1lbWJlcm9mIElneENvbHVtbkNvbXBvbmVudFxuICAgICAqL1xuICAgIEBJbnB1dCgpIHJvd1N0YXJ0OiBudW1iZXI7XG5cbiAgICAvKipcbiAgICAgKiBDb2x1bW4gaW5kZXggZnJvbSB3aGljaCB0aGUgZmllbGQgaXMgc3RhcnRpbmcuXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxpZ3gtY29sdW1uLWxheW91dD5cbiAgICAgKiAgIDxpZ3gtY29sdW1uIFtjb2xTdGFydF09XCIxXCIgW3Jvd1N0YXJ0XT1cIjFcIj48L2lneC1jb2x1bW4+XG4gICAgICogPC9pZ3gtY29sdW1uLWxheW91dD5cbiAgICAgKiBgYGBcbiAgICAgKiBAbWVtYmVyb2YgSWd4Q29sdW1uQ29tcG9uZW50XG4gICAgICovXG4gICAgQElucHV0KCkgY29sU3RhcnQ6IG51bWJlcjtcblxuICAgIC8qKlxuICAgICAqIGhpZGRlblxuICAgICAqL1xuICAgIHB1YmxpYyBkZWZhdWx0V2lkdGg6IHN0cmluZztcblxuICAgIC8qKlxuICAgICAqIGhpZGRlblxuICAgICAqL1xuICAgIHB1YmxpYyB3aWR0aFNldEJ5VXNlcjogYm9vbGVhbjtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGZpbHRlcmluZ0V4cHJlc3Npb25zVHJlZSBvZiB0aGUgY29sdW1uLlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBsZXQgdHJlZSA9ICB0aGlzLmNvbHVtbi5maWx0ZXJpbmdFeHByZXNzaW9uc1RyZWU7XG4gICAgICogYGBgXG4gICAgICogQG1lbWJlcm9mIElneENvbHVtbkNvbXBvbmVudFxuICAgICAqL1xuICAgIGdldCBmaWx0ZXJpbmdFeHByZXNzaW9uc1RyZWUoKTogRmlsdGVyaW5nRXhwcmVzc2lvbnNUcmVlIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ3JpZC5maWx0ZXJpbmdFeHByZXNzaW9uc1RyZWUuZmluZCh0aGlzLmZpZWxkKSBhcyBGaWx0ZXJpbmdFeHByZXNzaW9uc1RyZWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMvZ2V0cyB0aGUgcGFyZW50IGNvbHVtbi5cbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogbGV0IHBhcmVudENvbHVtbiA9IHRoaXMuY29sdW1uLnBhcmVudDtcbiAgICAgKiBgYGBcbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogdGhpcy5jb2x1bW4ucGFyZW50ID0gaGlnaGVyTGV2ZWxDb2x1bW47XG4gICAgICogYGBgXG4gICAgICogQG1lbWJlcm9mIElneENvbHVtbkNvbXBvbmVudFxuICAgICAqL1xuICAgIHBhcmVudCA9IG51bGw7XG4gICAgLyoqXG4gICAgICogU2V0cy9nZXRzIHRoZSBjaGlsZHJlbiBjb2x1bW5zLlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBsZXQgY29sdW1uQ2hpbGRyZW4gPSB0aGlzLmNvbHVtbi5jaGlsZHJlbjtcbiAgICAgKiBgYGBcbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogdGhpcy5jb2x1bW4uY2hpbGRyZW4gPSBjaGlsZHJlbkNvbHVtbnM7XG4gICAgICogYGBgXG4gICAgICogQG1lbWJlcm9mIElneENvbHVtbkNvbXBvbmVudFxuICAgICAqL1xuICAgIGNoaWxkcmVuOiBRdWVyeUxpc3Q8SWd4Q29sdW1uQ29tcG9uZW50PjtcbiAgICAvKipcbiAgICAgKkBoaWRkZW5cbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgX3VucGlubmVkSW5kZXg7XG4gICAgLyoqXG4gICAgICpAaGlkZGVuXG4gICAgICovXG4gICAgcHJvdGVjdGVkIF9waW5uZWQgPSBmYWxzZTtcbiAgICAvKipcbiAgICAgKkBoaWRkZW5cbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgX2JvZHlUZW1wbGF0ZTogVGVtcGxhdGVSZWY8YW55PjtcbiAgICAvKipcbiAgICAgKkBoaWRkZW5cbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgX2hlYWRlclRlbXBsYXRlOiBUZW1wbGF0ZVJlZjxhbnk+O1xuICAgIC8qKlxuICAgICAqQGhpZGRlblxuICAgICAqL1xuICAgIHByb3RlY3RlZCBfaW5saW5lRWRpdG9yVGVtcGxhdGU6IFRlbXBsYXRlUmVmPGFueT47XG4gICAgLyoqXG4gICAgICpAaGlkZGVuXG4gICAgICovXG4gICAgcHJvdGVjdGVkIF9maWx0ZXJDZWxsVGVtcGxhdGU6IFRlbXBsYXRlUmVmPGFueT47XG4gICAgLyoqXG4gICAgICpAaGlkZGVuXG4gICAgICovXG4gICAgcHJvdGVjdGVkIF9zdW1tYXJpZXMgPSBudWxsO1xuICAgIC8qKlxuICAgICAqQGhpZGRlblxuICAgICAqL1xuICAgIHByb3RlY3RlZCBfZmlsdGVycyA9IG51bGw7XG4gICAgLyoqXG4gICAgICpAaGlkZGVuXG4gICAgICovXG4gICAgcHJvdGVjdGVkIF9zb3J0U3RyYXRlZ3k6IElTb3J0aW5nU3RyYXRlZ3kgPSBEZWZhdWx0U29ydGluZ1N0cmF0ZWd5Lmluc3RhbmNlKCk7XG4gICAgLyoqXG4gICAgICpAaGlkZGVuXG4gICAgICovXG4gICAgcHJvdGVjdGVkIF9ncm91cGluZ0NvbXBhcmVyOiAoYTogYW55LCBiOiBhbnkpID0+IG51bWJlcjtcbiAgICAvKipcbiAgICAgKkBoaWRkZW5cbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgX2hpZGRlbiA9IGZhbHNlO1xuICAgIC8qKlxuICAgICAqQGhpZGRlblxuICAgICAqL1xuICAgIHByb3RlY3RlZCBfaW5kZXg6IG51bWJlcjtcbiAgICAvKipcbiAgICAgKkBoaWRkZW5cbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgX2Rpc2FibGVIaWRpbmcgPSBmYWxzZTtcbiAgICAvKipcbiAgICAgKkBoaWRkZW5cbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgX2Rpc2FibGVQaW5uaW5nID0gZmFsc2U7XG4gICAgLyoqXG4gICAgICpAaGlkZGVuXG4gICAgICovXG4gICAgcHJvdGVjdGVkIF93aWR0aDogc3RyaW5nO1xuICAgIC8qKlxuICAgICAqQGhpZGRlblxuICAgICAqL1xuICAgIHByb3RlY3RlZCBfZGVmYXVsdE1pbldpZHRoID0gJyc7XG4gICAgLyoqXG4gICAgICpAaGlkZGVuXG4gICAgICovXG4gICAgcHJvdGVjdGVkIF9oYXNTdW1tYXJ5ID0gZmFsc2U7XG4gICAgLyoqXG4gICAgICpAaGlkZGVuXG4gICAgICovXG4gICAgQENvbnRlbnRDaGlsZChJZ3hDZWxsVGVtcGxhdGVEaXJlY3RpdmUsIHsgcmVhZDogSWd4Q2VsbFRlbXBsYXRlRGlyZWN0aXZlIH0pXG4gICAgcHJvdGVjdGVkIGNlbGxUZW1wbGF0ZTogSWd4Q2VsbFRlbXBsYXRlRGlyZWN0aXZlO1xuICAgIC8qKlxuICAgICAqQGhpZGRlblxuICAgICAqL1xuICAgIEBDb250ZW50Q2hpbGQoSWd4Q2VsbEhlYWRlclRlbXBsYXRlRGlyZWN0aXZlLCB7IHJlYWQ6IElneENlbGxIZWFkZXJUZW1wbGF0ZURpcmVjdGl2ZSB9KVxuICAgIHByb3RlY3RlZCBoZWFkVGVtcGxhdGU6IElneENlbGxIZWFkZXJUZW1wbGF0ZURpcmVjdGl2ZTtcbiAgICAvKipcbiAgICAgKkBoaWRkZW5cbiAgICAgKi9cbiAgICBAQ29udGVudENoaWxkKElneENlbGxFZGl0b3JUZW1wbGF0ZURpcmVjdGl2ZSwgeyByZWFkOiBJZ3hDZWxsRWRpdG9yVGVtcGxhdGVEaXJlY3RpdmUgfSlcbiAgICBwcm90ZWN0ZWQgZWRpdG9yVGVtcGxhdGU6IElneENlbGxFZGl0b3JUZW1wbGF0ZURpcmVjdGl2ZTtcblxuICAgIHByb3RlY3RlZCBfdkluZGV4ID0gTmFOO1xuICAgIC8qKlxuICAgICAqQGhpZGRlblxuICAgICAqL1xuICAgIEBDb250ZW50Q2hpbGQoSWd4RmlsdGVyQ2VsbFRlbXBsYXRlRGlyZWN0aXZlLCB7IHJlYWQ6IElneEZpbHRlckNlbGxUZW1wbGF0ZURpcmVjdGl2ZSB9KVxuICAgIHB1YmxpYyBmaWx0ZXJDZWxsVGVtcGxhdGVEaXJlY3RpdmU6IElneEZpbHRlckNlbGxUZW1wbGF0ZURpcmVjdGl2ZTtcblxuICAgIGNvbnN0cnVjdG9yKHB1YmxpYyBncmlkQVBJOiBHcmlkQmFzZUFQSVNlcnZpY2U8SWd4R3JpZEJhc2VDb21wb25lbnQgJiBJR3JpZERhdGFCaW5kYWJsZT4sIHB1YmxpYyBjZHI6IENoYW5nZURldGVjdG9yUmVmKSB7IH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBwdWJsaWMgcmVzZXRDYWNoZXMoKSB7XG4gICAgICAgIHRoaXMuX3ZJbmRleCA9IE5hTjtcbiAgICAgICAgaWYgKHRoaXMuZ3JpZCkge1xuICAgICAgICAgICAgdGhpcy5jYWNoZUNhbGNXaWR0aCgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpAaGlkZGVuXG4gICAgICovXG4gICAgcHVibGljIG5nQWZ0ZXJDb250ZW50SW5pdCgpOiB2b2lkIHtcbiAgICAgICAgaWYgKHRoaXMuY2VsbFRlbXBsYXRlKSB7XG4gICAgICAgICAgICB0aGlzLl9ib2R5VGVtcGxhdGUgPSB0aGlzLmNlbGxUZW1wbGF0ZS50ZW1wbGF0ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5oZWFkVGVtcGxhdGUpIHtcbiAgICAgICAgICAgIHRoaXMuX2hlYWRlclRlbXBsYXRlID0gdGhpcy5oZWFkVGVtcGxhdGUudGVtcGxhdGU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuZWRpdG9yVGVtcGxhdGUpIHtcbiAgICAgICAgICAgIHRoaXMuX2lubGluZUVkaXRvclRlbXBsYXRlID0gdGhpcy5lZGl0b3JUZW1wbGF0ZS50ZW1wbGF0ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5maWx0ZXJDZWxsVGVtcGxhdGVEaXJlY3RpdmUpIHtcbiAgICAgICAgICAgIHRoaXMuX2ZpbHRlckNlbGxUZW1wbGF0ZSA9IHRoaXMuZmlsdGVyQ2VsbFRlbXBsYXRlRGlyZWN0aXZlLnRlbXBsYXRlO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5zdW1tYXJpZXMpIHtcbiAgICAgICAgICAgIHN3aXRjaCAodGhpcy5kYXRhVHlwZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgRGF0YVR5cGUuU3RyaW5nOlxuICAgICAgICAgICAgICAgIGNhc2UgRGF0YVR5cGUuQm9vbGVhbjpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdW1tYXJpZXMgPSBJZ3hTdW1tYXJ5T3BlcmFuZDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBEYXRhVHlwZS5OdW1iZXI6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3VtbWFyaWVzID0gSWd4TnVtYmVyU3VtbWFyeU9wZXJhbmQ7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgRGF0YVR5cGUuRGF0ZTpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdW1tYXJpZXMgPSBJZ3hEYXRlU3VtbWFyeU9wZXJhbmQ7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3VtbWFyaWVzID0gSWd4U3VtbWFyeU9wZXJhbmQ7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5maWx0ZXJzKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKHRoaXMuZGF0YVR5cGUpIHtcbiAgICAgICAgICAgICAgICBjYXNlIERhdGFUeXBlLkJvb2xlYW46XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZmlsdGVycyA9IElneEJvb2xlYW5GaWx0ZXJpbmdPcGVyYW5kLmluc3RhbmNlKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgRGF0YVR5cGUuTnVtYmVyOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmZpbHRlcnMgPSBJZ3hOdW1iZXJGaWx0ZXJpbmdPcGVyYW5kLmluc3RhbmNlKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgRGF0YVR5cGUuRGF0ZTpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5maWx0ZXJzID0gSWd4RGF0ZUZpbHRlcmluZ09wZXJhbmQuaW5zdGFuY2UoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBEYXRhVHlwZS5TdHJpbmc6XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5maWx0ZXJzID0gSWd4U3RyaW5nRmlsdGVyaW5nT3BlcmFuZC5pbnN0YW5jZSgpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBnZXRHcmlkVGVtcGxhdGUoaXNSb3c6IGJvb2xlYW4sIGlzSUU6IGJvb2xlYW4pOiBzdHJpbmcge1xuICAgICAgICBpZiAoaXNSb3cpIHtcbiAgICAgICAgICAgIGNvbnN0IHJvd3NDb3VudCA9IHRoaXMuZ3JpZC5tdWx0aVJvd0xheW91dFJvd1NpemU7XG4gICAgICAgICAgICByZXR1cm4gaXNJRSA/XG4gICAgICAgICAgICAgICAgYCgxZnIpWyR7cm93c0NvdW50fV1gIDpcbiAgICAgICAgICAgICAgICBgcmVwZWF0KCR7cm93c0NvdW50fSwxZnIpYDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldENvbHVtblNpemVzU3RyaW5nKHRoaXMuY2hpbGRyZW4pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHVibGljIGdldEluaXRpYWxDaGlsZENvbHVtblNpemVzKGNoaWxkcmVuOiBRdWVyeUxpc3Q8SWd4Q29sdW1uQ29tcG9uZW50Pik6IEFycmF5PE1STENvbHVtblNpemVJbmZvPiB7XG4gICAgICAgIGNvbnN0IGNvbHVtblNpemVzOiBNUkxDb2x1bW5TaXplSW5mb1tdID0gW107XG4gICAgICAgIC8vIGZpbmQgdGhlIHNtYWxsZXN0IGNvbCBzcGFuc1xuICAgICAgICBjaGlsZHJlbi5mb3JFYWNoKGNvbCA9PiB7XG4gICAgICAgICAgICBpZiAoIWNvbC5jb2xTdGFydCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IG5ld1dpZHRoU2V0ID0gIGNvbC53aWR0aFNldEJ5VXNlciAmJiBjb2x1bW5TaXplc1tjb2wuY29sU3RhcnQgLSAxXSAmJiAhY29sdW1uU2l6ZXNbY29sLmNvbFN0YXJ0IC0gMV0ud2lkdGhTZXRCeVVzZXI7XG4gICAgICAgICAgICBjb25zdCBuZXdTcGFuU21hbGxlciA9IGNvbHVtblNpemVzW2NvbC5jb2xTdGFydCAtIDFdICYmIGNvbHVtblNpemVzW2NvbC5jb2xTdGFydCAtIDFdLmNvbFNwYW4gPiBjb2wuZ3JpZENvbHVtblNwYW47XG4gICAgICAgICAgICBjb25zdCBib3RoV2lkdGhzU2V0ID0gY29sLndpZHRoU2V0QnlVc2VyICYmIGNvbHVtblNpemVzW2NvbC5jb2xTdGFydCAtIDFdICYmIGNvbHVtblNpemVzW2NvbC5jb2xTdGFydCAtIDFdLndpZHRoU2V0QnlVc2VyO1xuICAgICAgICAgICAgY29uc3QgYm90aFdpZHRoc05vdFNldCA9ICFjb2wud2lkdGhTZXRCeVVzZXIgJiYgY29sdW1uU2l6ZXNbY29sLmNvbFN0YXJ0IC0gMV0gJiYgIWNvbHVtblNpemVzW2NvbC5jb2xTdGFydCAtIDFdLndpZHRoU2V0QnlVc2VyO1xuXG4gICAgICAgICAgICBpZiAoY29sdW1uU2l6ZXNbY29sLmNvbFN0YXJ0IC0gMV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIC8vIElmIG5vdGhpbmcgaXMgZGVmaW5lZCB5ZXQgdGFrZSBhbnkgY29sdW1uIGF0IGZpcnN0XG4gICAgICAgICAgICAgICAgLy8gV2UgdXNlIGNvbEVuZCB0byBrbm93IHdoZXJlIHRoZSBjb2x1bW4gYWN0dWFsbHkgZW5kcywgYmVjYXVzZSBub3QgYWx3YXlzIGl0IHN0YXJ0cyB3aGVyZSB3ZSBoYXZlIGl0IHNldCBpbiBjb2x1bW5TaXplcy5cbiAgICAgICAgICAgICAgICBjb2x1bW5TaXplc1tjb2wuY29sU3RhcnQgLSAxXSA9IHtcbiAgICAgICAgICAgICAgICAgICAgcmVmOiBjb2wsXG4gICAgICAgICAgICAgICAgICAgIHdpZHRoOiBjb2wud2lkdGhTZXRCeVVzZXIgfHwgdGhpcy5ncmlkLmNvbHVtbldpZHRoU2V0QnlVc2VyID8gcGFyc2VJbnQoY29sLmNhbGNXaWR0aCwgMTApIDogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgY29sU3BhbjogY29sLmdyaWRDb2x1bW5TcGFuLFxuICAgICAgICAgICAgICAgICAgICBjb2xFbmQ6IGNvbC5jb2xTdGFydCArIGNvbC5ncmlkQ29sdW1uU3BhbixcbiAgICAgICAgICAgICAgICAgICAgd2lkdGhTZXRCeVVzZXI6IGNvbC53aWR0aFNldEJ5VXNlclxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG5ld1dpZHRoU2V0IHx8IChuZXdTcGFuU21hbGxlciAmJiAoKGJvdGhXaWR0aHNTZXQpIHx8IChib3RoV2lkdGhzTm90U2V0KSkpKSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgYSBjb2x1bW4gaXMgc2V0IGFscmVhZHkgaXQgc2hvdWxkIGVpdGhlciBub3QgaGF2ZSB3aWR0aCBkZWZpbmVkIG9yIGhhdmUgd2lkdGggd2l0aCBiaWdnZXIgc3BhbiB0aGFuIHRoZSBuZXcgb25lLlxuXG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogIElmIHJlcGxhY2VkIGNvbHVtbiBoYXMgYmlnZ2VyIHNwYW4sIHdlIHdhbnQgdG8gZmlsbCB0aGUgcmVtYWluaW5nIGNvbHVtbnNcbiAgICAgICAgICAgICAgICAgKiAgdGhhdCB0aGUgcmVwbGFjaW5nIGNvbHVtbiBkb2VzIG5vdCBmaWxsIHdpdGggdGhlIG9sZCBvbmUuXG4gICAgICAgICAgICAgICAgICoqL1xuICAgICAgICAgICAgICAgIGlmIChib3RoV2lkdGhzU2V0ICYmIG5ld1NwYW5TbWFsbGVyKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFN0YXJ0IGZyb20gd2hlcmUgdGhlIG5ldyBjb2x1bW4gc2V0IHdvdWxkIGVuZCBhbmQgYXBwbHkgdGhlIG9sZCBjb2x1bW4gdG8gdGhlIHJlc3QgZGVwZW5kaW5nIG9uIGhvdyBtdWNoIGl0IHNwYW5zLlxuICAgICAgICAgICAgICAgICAgICAvLyBXZSBoYXZlIG5vdCB5ZXQgcmVwbGFjZWQgaXQgc28gd2UgY2FuIHVzZSBpdCBkaXJlY3RseSBmcm9tIHRoZSBjb2x1bW5TaXplcyBjb2xsZWN0aW9uLlxuICAgICAgICAgICAgICAgICAgICAvLyBUaGlzIGlzIHdoZXJlIGNvbEVuZCBpcyB1c2VkIGJlY2F1c2UgdGhlIGNvbFN0YXJ0IG9mIHRoZSBvbGQgY29sdW1uIGlzIG5vdCBhY3R1YWxseSBpICsgMS5cbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IGNvbC5jb2xTdGFydCAtIDEgKyBjb2wuZ3JpZENvbHVtblNwYW47IGkgPCBjb2x1bW5TaXplc1tjb2wuY29sU3RhcnQgLSAxXS5jb2xFbmQgLSAxOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghY29sdW1uU2l6ZXNbaV0gfHwgIWNvbHVtblNpemVzW2ldLndpZHRoU2V0QnlVc2VyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sdW1uU2l6ZXNbaV0gPSBjb2x1bW5TaXplc1tjb2wuY29sU3RhcnQgLSAxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBSZXBsYWNlIHRoZSBvbGQgY29sdW1uIHdpdGggdGhlIG5ldyBvbmUuXG4gICAgICAgICAgICAgICAgY29sdW1uU2l6ZXNbY29sLmNvbFN0YXJ0IC0gMV0gPSB7XG4gICAgICAgICAgICAgICAgICAgIHJlZjogY29sLFxuICAgICAgICAgICAgICAgICAgICB3aWR0aDogY29sLndpZHRoU2V0QnlVc2VyIHx8IHRoaXMuZ3JpZC5jb2x1bW5XaWR0aFNldEJ5VXNlciA/IHBhcnNlSW50KGNvbC5jYWxjV2lkdGgsIDEwKSA6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgIGNvbFNwYW46IGNvbC5ncmlkQ29sdW1uU3BhbixcbiAgICAgICAgICAgICAgICAgICAgY29sRW5kOiBjb2wuY29sU3RhcnQgKyBjb2wuZ3JpZENvbHVtblNwYW4sXG4gICAgICAgICAgICAgICAgICAgIHdpZHRoU2V0QnlVc2VyOiBjb2wud2lkdGhTZXRCeVVzZXJcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSBlbHNlIGlmIChib3RoV2lkdGhzU2V0ICYmIGNvbHVtblNpemVzW2NvbC5jb2xTdGFydCAtIDFdLmNvbFNwYW4gPCBjb2wuZ3JpZENvbHVtblNwYW4pIHtcbiAgICAgICAgICAgICAgICAvLyBJZiB0aGUgY29sdW1uIGFscmVhZHkgaW4gdGhlIGNvbHVtblNpemVzIGhhcyBzbWFsbGVyIHNwYW4sIHdlIHN0aWxsIG5lZWQgdG8gZmlsbCBhbnkgZW1wdHkgcGxhY2VzIHdpdGggdGhlIGN1cnJlbnQgY29sLlxuICAgICAgICAgICAgICAgIC8vIFN0YXJ0IGZyb20gd2hlcmUgdGhlIHNtYWxsZXIgY29sdW1uIHNldCB3b3VsZCBlbmQgYW5kIGFwcGx5IHRoZSBiaWdnZXIgY29sdW1uIHRvIHRoZSByZXN0IGRlcGVuZGluZyBvbiBob3cgbXVjaCBpdCBzcGFucy5cbiAgICAgICAgICAgICAgICAvLyBTaW5jZSBoZXJlIHdlIGRvIG5vdCBoYXZlIGl0IGluIGNvbHVtblNpemVzIHdlIHNldCBpdCBhcyBhIG5ldyBjb2x1bW4ga2VlcGluZyB0aGUgc2FtZSBjb2xTcGFuLlxuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSBjb2wuY29sU3RhcnQgLSAxICsgY29sdW1uU2l6ZXNbY29sLmNvbFN0YXJ0IC0gMV0uY29sU3BhbjsgaSA8IGNvbC5jb2xTdGFydCAtIDEgKyBjb2wuZ3JpZENvbHVtblNwYW47IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWNvbHVtblNpemVzW2ldIHx8ICFjb2x1bW5TaXplc1tpXS53aWR0aFNldEJ5VXNlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29sdW1uU2l6ZXNbaV0gPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVmOiBjb2wsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg6IGNvbC53aWR0aFNldEJ5VXNlciB8fCB0aGlzLmdyaWQuY29sdW1uV2lkdGhTZXRCeVVzZXIgPyBwYXJzZUludChjb2wuY2FsY1dpZHRoLCAxMCkgOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbFNwYW46IGNvbC5ncmlkQ29sdW1uU3BhbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2xFbmQ6IGNvbC5jb2xTdGFydCArIGNvbC5ncmlkQ29sdW1uU3BhbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aWR0aFNldEJ5VXNlcjogY29sLndpZHRoU2V0QnlVc2VyXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIEZsYXR0ZW4gY29sdW1uU2l6ZXMgc28gdGhlcmUgYXJlIG5vdCBjb2x1bW5zIHdpdGggY29sU3BhbiA+IDFcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb2x1bW5TaXplcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKGNvbHVtblNpemVzW2ldICYmIGNvbHVtblNpemVzW2ldLmNvbFNwYW4gPiAxKSB7XG4gICAgICAgICAgICAgICAgbGV0IGogPSAxO1xuXG4gICAgICAgICAgICAgICAgLy8gUmVwbGFjZSBhbGwgZW1wdHkgcGxhY2VzIGRlcGVuZGluZyBvbiBob3cgbXVjaCB0aGUgY3VycmVudCBjb2x1bW4gc3BhbnMgc3RhcnRpbmcgZnJvbSBuZXh0IGNvbC5cbiAgICAgICAgICAgICAgICBmb3IgKDsgaiA8IGNvbHVtblNpemVzW2ldLmNvbFNwYW4gJiYgaSArIGogKyAxIDwgY29sdW1uU2l6ZXNbaV0uY29sRW5kOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbHVtblNpemVzW2kgKyBqXSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgKCghY29sdW1uU2l6ZXNbaV0ud2lkdGggJiYgY29sdW1uU2l6ZXNbaSArIGpdLndpZHRoKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICghY29sdW1uU2l6ZXNbaV0ud2lkdGggJiYgIWNvbHVtblNpemVzW2kgKyBqXS53aWR0aCAmJiBjb2x1bW5TaXplc1tpICsgal0uY29sU3BhbiA8PSBjb2x1bW5TaXplc1tpXS5jb2xTcGFuKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgKCEhY29sdW1uU2l6ZXNbaSArIGpdLndpZHRoICYmIGNvbHVtblNpemVzW2kgKyBqXS5jb2xTcGFuIDw9IGNvbHVtblNpemVzW2ldLmNvbFNwYW4pKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgd2UgcmVhY2ggYW4gYWxyZWFkeSBkZWZpbmVkIGNvbHVtbiB0aGF0IGhhcyB3aWR0aCBhbmQgdGhlIGN1cnJlbnQgZG9lc24ndCBoYXZlIG9yXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBpZiB0aGUgcmVhY2hlZCBjb2x1bW4gaGFzIGJpZ2dlciBjb2xTcGFuIHdlIHN0b3AuXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHdpZHRoID0gY29sdW1uU2l6ZXNbaV0ud2lkdGhTZXRCeVVzZXIgP1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbHVtblNpemVzW2ldLndpZHRoIC8gY29sdW1uU2l6ZXNbaV0uY29sU3BhbiA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sdW1uU2l6ZXNbaV0ud2lkdGg7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2x1bW5TaXplc1tpICsgal0gPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVmOiBjb2x1bW5TaXplc1tpXS5yZWYsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg6IHdpZHRoLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbFNwYW46IDEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sRW5kOiBjb2x1bW5TaXplc1tpXS5jb2xFbmQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGhTZXRCeVVzZXI6IGNvbHVtblNpemVzW2ldLndpZHRoU2V0QnlVc2VyXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gVXBkYXRlIHRoZSBjdXJyZW50IGNvbHVtbiB3aWR0aCBzbyBpdCBpcyBkaXZpZGVkIGJldHdlZW4gYWxsIGNvbHVtbnMgaXQgc3BhbnMgYW5kIHNldCBpdCB0byAxLlxuICAgICAgICAgICAgICAgIGNvbHVtblNpemVzW2ldLndpZHRoID0gY29sdW1uU2l6ZXNbaV0ud2lkdGhTZXRCeVVzZXIgP1xuICAgICAgICAgICAgICAgICAgICBjb2x1bW5TaXplc1tpXS53aWR0aCAvIGNvbHVtblNpemVzW2ldLmNvbFNwYW4gOlxuICAgICAgICAgICAgICAgICAgICBjb2x1bW5TaXplc1tpXS53aWR0aDtcbiAgICAgICAgICAgICAgICBjb2x1bW5TaXplc1tpXS5jb2xTcGFuID0gMTtcblxuICAgICAgICAgICAgICAgIC8vIFVwZGF0ZSB0aGUgaW5kZXggYmFzZWQgb24gaG93IG11Y2ggd2UgaGF2ZSByZXBsYWNlZC4gU3VidHJhY3QgMSBiZWNhdXNlIHdlIHN0YXJ0ZWQgZnJvbSAxLlxuICAgICAgICAgICAgICAgIGkgKz0gaiAtIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY29sdW1uU2l6ZXM7XG4gICAgfVxuXG4gICAgcHVibGljIGdldEZpbGxlZENoaWxkQ29sdW1uU2l6ZXMoY2hpbGRyZW46IFF1ZXJ5TGlzdDxJZ3hDb2x1bW5Db21wb25lbnQ+KTogQXJyYXk8c3RyaW5nPiB7XG4gICAgICAgIGNvbnN0IGNvbHVtblNpemVzID0gdGhpcy5nZXRJbml0aWFsQ2hpbGRDb2x1bW5TaXplcyhjaGlsZHJlbik7XG5cbiAgICAgICAgLy8gZmlsbCB0aGUgZ2FwcyBpZiB0aGVyZSBhcmUgYW55XG4gICAgICAgIGNvbnN0IHJlc3VsdDogc3RyaW5nW10gPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb2x1bW5TaXplcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKGNvbHVtblNpemVzW2ldICYmICEhY29sdW1uU2l6ZXNbaV0ud2lkdGgpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChjb2x1bW5TaXplc1tpXS53aWR0aCArICdweCcpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChwYXJzZUludCh0aGlzLmdyaWQuZ2V0UG9zc2libGVDb2x1bW5XaWR0aCgpLCAxMCkgKyAncHgnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIHByb3RlY3RlZCBnZXRDb2x1bW5TaXplc1N0cmluZyhjaGlsZHJlbjogUXVlcnlMaXN0PElneENvbHVtbkNvbXBvbmVudD4pOiBzdHJpbmcge1xuICAgICAgIGNvbnN0IHJlcyA9IHRoaXMuZ2V0RmlsbGVkQ2hpbGRDb2x1bW5TaXplcyhjaGlsZHJlbik7XG4gICAgICAgcmV0dXJuIHJlcy5qb2luKCcgJyk7XG4gICAgfVxuXG4gICAgcHVibGljIGdldFJlc2l6YWJsZUNvbFVuZGVyRW5kKCk6IE1STFJlc2l6ZUNvbHVtbkluZm9bXSB7XG4gICAgICAgIGlmICh0aGlzLmNvbHVtbkxheW91dCB8fCAhdGhpcy5jb2x1bW5MYXlvdXRDaGlsZCB8fCB0aGlzLmNvbHVtbkdyb3VwKSB7XG4gICAgICAgICAgICByZXR1cm4gW3sgdGFyZ2V0OiB0aGlzLCBzcGFuVXNlZDogMSB9XTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGNvbHVtblNpemVkID0gdGhpcy5nZXRJbml0aWFsQ2hpbGRDb2x1bW5TaXplcyh0aGlzLnBhcmVudC5jaGlsZHJlbik7XG4gICAgICAgIGNvbnN0IHRhcmdldHM6IE1STFJlc2l6ZUNvbHVtbkluZm9bXSA9IFtdO1xuICAgICAgICBjb25zdCBjb2xFbmQgPSB0aGlzLmNvbEVuZCA/IHRoaXMuY29sRW5kIDogdGhpcy5jb2xTdGFydCArIDE7XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb2x1bW5TaXplZC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKHRoaXMuY29sU3RhcnQgPD0gaSArIDEgJiYgaSArIDEgPCBjb2xFbmQpIHtcbiAgICAgICAgICAgICAgICB0YXJnZXRzLnB1c2goeyB0YXJnZXQ6IGNvbHVtblNpemVkW2ldLnJlZiwgc3BhblVzZWQ6IDF9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHRhcmdldHNTcXVhc2hlZDogTVJMUmVzaXplQ29sdW1uSW5mb1tdID0gW107XG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgdGFyZ2V0cy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgaWYgKHRhcmdldHNTcXVhc2hlZC5sZW5ndGggJiYgdGFyZ2V0c1NxdWFzaGVkW3RhcmdldHNTcXVhc2hlZC5sZW5ndGggLSAxXS50YXJnZXQuZmllbGQgPT09IHRhcmdldHNbal0udGFyZ2V0LmZpZWxkKSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0c1NxdWFzaGVkW3RhcmdldHNTcXVhc2hlZC5sZW5ndGggLSAxXS5zcGFuVXNlZCsrO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0YXJnZXRzU3F1YXNoZWQucHVzaCh0YXJnZXRzW2pdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0YXJnZXRzU3F1YXNoZWQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUGlucyB0aGUgY29sdW1uIGF0IHRoZSBwcm92aWRlZCBpbmRleCBpbiB0aGUgcGlubmVkIGFyZWEuIERlZmF1bHRzIHRvIGluZGV4IGAwYCBpZiBub3QgcHJvdmlkZWQuXG4gICAgICogUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGNvbHVtbiBpcyBzdWNjZXNzZnVsbHkgcGlubmVkLiBSZXR1cm5zIGBmYWxzZWAgaWYgdGhlIGNvbHVtbiBjYW5ub3QgYmUgcGlubmVkLlxuICAgICAqIENvbHVtbiBjYW5ub3QgYmUgcGlubmVkIGlmOlxuICAgICAqIC0gSXMgYWxyZWFkeSBwaW5uZWRcbiAgICAgKiAtIGluZGV4IGFyZ3VtZW50IGlzIG91dCBvZiByYW5nZVxuICAgICAqIC0gVGhlIHBpbm5lZCBhcmVhIGV4Y2VlZHMgODAlIG9mIHRoZSBncmlkIHdpZHRoXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIGxldCBzdWNjZXNzID0gdGhpcy5jb2x1bW4ucGluKCk7XG4gICAgICogYGBgXG4gICAgICogQG1lbWJlcm9mIElneENvbHVtbkNvbXBvbmVudFxuICAgICAqL1xuICAgIHB1YmxpYyBwaW4oaW5kZXg/OiBudW1iZXIpOiBib29sZWFuIHtcbiAgICAgICAgLy8gVE9ETzogUHJvYmFibHkgc2hvdWxkIHRoZSByZXR1cm4gdHlwZSBvZiB0aGUgb2xkIGZ1bmN0aW9uc1xuICAgICAgICAvLyBzaG91bGQgYmUgbW92ZWQgYXMgYSBldmVudCBwYXJhbWV0ZXIuXG4gICAgICAgIGlmICh0aGlzLmdyaWQpIHtcbiAgICAgICAgICAgIHRoaXMuZ3JpZC5lbmRFZGl0KHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9waW5uZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLnBhcmVudCAmJiAhdGhpcy5wYXJlbnQucGlubmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy50b3BMZXZlbFBhcmVudC5waW4oaW5kZXgpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgZ3JpZCA9ICh0aGlzLmdyaWQgYXMgYW55KTtcbiAgICAgICAgY29uc3QgaGFzSW5kZXggPSBpbmRleCAhPT0gdW5kZWZpbmVkO1xuICAgICAgICBpZiAoaGFzSW5kZXggJiYgKGluZGV4IDwgMCB8fCBpbmRleCA+PSBncmlkLnBpbm5lZENvbHVtbnMubGVuZ3RoKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3Qgd2lkdGggPSBwYXJzZUludCh0aGlzLndpZHRoLCAxMCk7XG5cbiAgICAgICAgaWYgKCF0aGlzLnBhcmVudCAmJiAoZ3JpZC5nZXRVbnBpbm5lZFdpZHRoKHRydWUpIC0gd2lkdGggPCBncmlkLnVucGlubmVkQXJlYU1pbldpZHRoKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fcGlubmVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5fdW5waW5uZWRJbmRleCA9IGdyaWQuX3VucGlubmVkQ29sdW1ucy5pbmRleE9mKHRoaXMpO1xuICAgICAgICBpbmRleCA9IGluZGV4ICE9PSB1bmRlZmluZWQgPyBpbmRleCA6IGdyaWQuX3Bpbm5lZENvbHVtbnMubGVuZ3RoO1xuICAgICAgICBjb25zdCB0YXJnZXRDb2x1bW4gPSBncmlkLl9waW5uZWRDb2x1bW5zW2luZGV4XTtcbiAgICAgICAgY29uc3QgYXJncyA9IHsgY29sdW1uOiB0aGlzLCBpbnNlcnRBdEluZGV4OiBpbmRleCwgaXNQaW5uZWQ6IHRydWUgfTtcbiAgICAgICAgZ3JpZC5vbkNvbHVtblBpbm5pbmcuZW1pdChhcmdzKTtcblxuICAgICAgICBpZiAoZ3JpZC5fcGlubmVkQ29sdW1ucy5pbmRleE9mKHRoaXMpID09PSAtMSkge1xuICAgICAgICAgICAgZ3JpZC5fcGlubmVkQ29sdW1ucy5zcGxpY2UoYXJncy5pbnNlcnRBdEluZGV4LCAwLCB0aGlzKTtcblxuICAgICAgICAgICAgaWYgKGdyaWQuX3VucGlubmVkQ29sdW1ucy5pbmRleE9mKHRoaXMpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIGdyaWQuX3VucGlubmVkQ29sdW1ucy5zcGxpY2UoZ3JpZC5fdW5waW5uZWRDb2x1bW5zLmluZGV4T2YodGhpcyksIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGhhc0luZGV4KSB7XG4gICAgICAgICAgICBncmlkLl9tb3ZlQ29sdW1ucyh0aGlzLCB0YXJnZXRDb2x1bW4pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuY29sdW1uR3JvdXApIHtcbiAgICAgICAgICAgIHRoaXMuYWxsQ2hpbGRyZW4uZm9yRWFjaChjaGlsZCA9PiBjaGlsZC5waW4oKSk7XG4gICAgICAgICAgICBncmlkLnJlaW5pdFBpblN0YXRlcygpO1xuICAgICAgICB9XG5cbiAgICAgICAgZ3JpZC5yZXNldENhY2hlcygpO1xuICAgICAgICBncmlkLmNkci5kZXRlY3RDaGFuZ2VzKCk7XG4gICAgICAgIGlmICh0aGlzLmNvbHVtbkxheW91dENoaWxkKSB7XG4gICAgICAgICAgICB0aGlzLmdyaWQuY29sdW1ucy5maWx0ZXIoeCA9PiB4LmNvbHVtbkxheW91dCkuZm9yRWFjaCggeCA9PiB4LnBvcHVsYXRlVmlzaWJsZUluZGV4ZXMoKSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5ncmlkLmZpbHRlcmluZ1NlcnZpY2UucmVmcmVzaEV4cHJlc3Npb25zKCk7XG4gICAgICAgIHRoaXMuZ3JpZC5yZWZyZXNoU2VhcmNoKHRydWUpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVW5waW5zIHRoZSBjb2x1bW4gYW5kIHBsYWNlIGl0IGF0IHRoZSBwcm92aWRlZCBpbmRleCBpbiB0aGUgdW5waW5uZWQgYXJlYS4gRGVmYXVsdHMgdG8gaW5kZXggYDBgIGlmIG5vdCBwcm92aWRlZC5cbiAgICAgKiBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgY29sdW1uIGlzIHN1Y2Nlc3NmdWxseSB1bnBpbm5lZC4gUmV0dXJucyBgZmFsc2VgIGlmIHRoZSBjb2x1bW4gY2Fubm90IGJlIHVucGlubmVkLlxuICAgICAqIENvbHVtbiBjYW5ub3QgYmUgdW5waW5uZWQgaWY6XG4gICAgICogLSBJcyBhbHJlYWR5IHVucGlubmVkXG4gICAgICogLSBpbmRleCBhcmd1bWVudCBpcyBvdXQgb2YgcmFuZ2VcbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogbGV0IHN1Y2Nlc3MgPSB0aGlzLmNvbHVtbi51bnBpbigpO1xuICAgICAqIGBgYFxuICAgICAqIEBtZW1iZXJvZiBJZ3hDb2x1bW5Db21wb25lbnRcbiAgICAgKi9cbiAgICBwdWJsaWMgdW5waW4oaW5kZXg/OiBudW1iZXIpOiBib29sZWFuIHtcbiAgICAgICAgaWYgKHRoaXMuZ3JpZCkge1xuICAgICAgICAgICAgdGhpcy5ncmlkLmVuZEVkaXQodHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLl9waW5uZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLnBhcmVudCAmJiB0aGlzLnBhcmVudC5waW5uZWQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRvcExldmVsUGFyZW50LnVucGluKGluZGV4KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGdyaWQgPSAodGhpcy5ncmlkIGFzIGFueSk7XG4gICAgICAgIGNvbnN0IGhhc0luZGV4ID0gaW5kZXggIT09IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKGhhc0luZGV4ICYmIChpbmRleCA8IDAgfHwgaW5kZXggPj0gZ3JpZC5fdW5waW5uZWRDb2x1bW5zLmxlbmd0aCkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGluZGV4ID0gKGluZGV4ICE9PSB1bmRlZmluZWQgPyBpbmRleCA6XG4gICAgICAgICAgICB0aGlzLl91bnBpbm5lZEluZGV4ICE9PSB1bmRlZmluZWQgPyB0aGlzLl91bnBpbm5lZEluZGV4IDogdGhpcy5pbmRleCk7XG4gICAgICAgIHRoaXMuX3Bpbm5lZCA9IGZhbHNlO1xuXG4gICAgICAgIGNvbnN0IHRhcmdldENvbHVtbiA9IGdyaWQuX3VucGlubmVkQ29sdW1uc1tpbmRleF07XG5cbiAgICAgICAgZ3JpZC5fdW5waW5uZWRDb2x1bW5zLnNwbGljZShpbmRleCwgMCwgdGhpcyk7XG4gICAgICAgIGlmIChncmlkLl9waW5uZWRDb2x1bW5zLmluZGV4T2YodGhpcykgIT09IC0xKSB7XG4gICAgICAgICAgICBncmlkLl9waW5uZWRDb2x1bW5zLnNwbGljZShncmlkLl9waW5uZWRDb2x1bW5zLmluZGV4T2YodGhpcyksIDEpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGhhc0luZGV4KSB7XG4gICAgICAgICAgICBncmlkLl9tb3ZlQ29sdW1ucyh0aGlzLCB0YXJnZXRDb2x1bW4pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuY29sdW1uR3JvdXApIHtcbiAgICAgICAgICAgIHRoaXMuYWxsQ2hpbGRyZW4uZm9yRWFjaChjaGlsZCA9PiBjaGlsZC51bnBpbigpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGdyaWQucmVpbml0UGluU3RhdGVzKCk7XG4gICAgICAgIGdyaWQucmVzZXRDYWNoZXMoKTtcblxuICAgICAgICBjb25zdCBpbnNlcnRBdEluZGV4ID0gZ3JpZC5fdW5waW5uZWRDb2x1bW5zLmluZGV4T2YodGhpcyk7XG4gICAgICAgIGNvbnN0IGFyZ3MgPSB7IGNvbHVtbjogdGhpcywgaW5zZXJ0QXRJbmRleCwgaXNQaW5uZWQ6IGZhbHNlIH07XG4gICAgICAgIGdyaWQub25Db2x1bW5QaW5uaW5nLmVtaXQoYXJncyk7XG5cbiAgICAgICAgZ3JpZC5jZHIuZGV0ZWN0Q2hhbmdlcygpO1xuICAgICAgICBpZiAodGhpcy5jb2x1bW5MYXlvdXRDaGlsZCkge1xuICAgICAgICAgICAgdGhpcy5ncmlkLmNvbHVtbnMuZmlsdGVyKHggPT4geC5jb2x1bW5MYXlvdXQpLmZvckVhY2goIHggPT4geC5wb3B1bGF0ZVZpc2libGVJbmRleGVzKCkpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZ3JpZC5maWx0ZXJpbmdTZXJ2aWNlLnJlZnJlc2hFeHByZXNzaW9ucygpO1xuICAgICAgICB0aGlzLmdyaWQucmVmcmVzaFNlYXJjaCh0cnVlKTtcblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIHJlZmVyZW5jZSB0byB0aGUgdG9wIGxldmVsIHBhcmVudCBjb2x1bW4uXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIGxldCB0b3BMZXZlbFBhcmVudCA9ICB0aGlzLmNvbHVtbi50b3BMZXZlbFBhcmVudDtcbiAgICAgKiBgYGBcbiAgICAgKiBAbWVtYmVyb2YgSWd4Q29sdW1uQ29tcG9uZW50XG4gICAgICovXG4gICAgZ2V0IHRvcExldmVsUGFyZW50KCkge1xuICAgICAgICBsZXQgcGFyZW50ID0gdGhpcy5wYXJlbnQ7XG4gICAgICAgIHdoaWxlIChwYXJlbnQgJiYgcGFyZW50LnBhcmVudCkge1xuICAgICAgICAgICAgcGFyZW50ID0gcGFyZW50LnBhcmVudDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGFyZW50O1xuICAgIH1cbiAgICAvKipcbiAgICAgKkBoaWRkZW5cbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgY2hlY2soKSB7XG4gICAgICAgIGlmICh0aGlzLmdyaWQpIHtcbiAgICAgICAgICAgIHRoaXMuZ3JpZC5tYXJrRm9yQ2hlY2soKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSByZWZlcmVuY2UgdG8gdGhlIGhlYWRlciBvZiB0aGUgY29sdW1uLlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBsZXQgY29sdW1uID0gdGhpcy5ncmlkLmNvbHVtbkxpc3QuZmlsdGVyKGMgPT4gYy5maWVsZCA9PT0gJ0lEJylbMF07XG4gICAgICogbGV0IGhlYWRlckNlbGwgPSBjb2x1bW4uaGVhZGVyQ2VsbDtcbiAgICAgKiBgYGBcbiAgICAgKiBAbWVtYmVyb2YgSWd4Q29sdW1uQ29tcG9uZW50XG4gICAgICovXG4gICAgZ2V0IGhlYWRlckNlbGwoKTogSWd4R3JpZEhlYWRlckNvbXBvbmVudCB7XG4gICAgICAgIHJldHVybiB0aGlzLmdyaWQuaGVhZGVyQ2VsbExpc3QuZmluZCgoaGVhZGVyKSA9PiBoZWFkZXIuY29sdW1uID09PSB0aGlzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAqIFJldHVybnMgYSByZWZlcmVuY2UgdG8gdGhlIGZpbHRlciBjZWxsIG9mIHRoZSBjb2x1bW4uXG4gICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgKiBsZXQgY29sdW1uID0gdGhpcy5ncmlkLmNvbHVtbkxpc3QuZmlsdGVyKGMgPT4gYy5maWVsZCA9PT0gJ0lEJylbMF07XG4gICAgKiBsZXQgZmlsdGVyZWxsID0gY29sdW1uLmZpbHRlcmVsbDtcbiAgICAqIGBgYFxuICAgICogQG1lbWJlcm9mIElneENvbHVtbkNvbXBvbmVudFxuICAgICovXG4gICAgZ2V0IGZpbHRlckNlbGwoKTogSWd4R3JpZEZpbHRlcmluZ0NlbGxDb21wb25lbnQge1xuICAgICAgICByZXR1cm4gdGhpcy5ncmlkLmZpbHRlckNlbGxMaXN0LmZpbmQoKGZpbHRlckNlbGwpID0+IGZpbHRlckNlbGwuY29sdW1uID09PSB0aGlzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgcmVmZXJlbmNlIHRvIHRoZSBoZWFkZXIgZ3JvdXAgb2YgdGhlIGNvbHVtbi5cbiAgICAgKiBAbWVtYmVyb2YgSWd4Q29sdW1uQ29tcG9uZW50XG4gICAgICovXG4gICAgZ2V0IGhlYWRlckdyb3VwKCk6IElneEdyaWRIZWFkZXJHcm91cENvbXBvbmVudCB7XG4gICAgICAgIHJldHVybiB0aGlzLmdyaWQuaGVhZGVyR3JvdXBzTGlzdC5maW5kKChoZWFkZXJHcm91cCkgPT4gaGVhZGVyR3JvdXAuY29sdW1uID09PSB0aGlzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBdXRvc2l6ZSB0aGUgY29sdW1uIHRvIHRoZSBsb25nZXN0IGN1cnJlbnRseSB2aXNpYmxlIGNlbGwgdmFsdWUsIGluY2x1ZGluZyB0aGUgaGVhZGVyIGNlbGwuXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIEBWaWV3Q2hpbGQoJ2dyaWQnKSBncmlkOiBJZ3hHcmlkQ29tcG9uZW50O1xuICAgICAqXG4gICAgICogbGV0IGNvbHVtbiA9IHRoaXMuZ3JpZC5jb2x1bW5MaXN0LmZpbHRlcihjID0+IGMuZmllbGQgPT09ICdJRCcpWzBdO1xuICAgICAqIGNvbHVtbi5hdXRvc2l6ZSgpO1xuICAgICAqIGBgYFxuICAgICAqIEBtZW1iZXJvZiBJZ3hDb2x1bW5Db21wb25lbnRcbiAgICAgKi9cbiAgICBwdWJsaWMgYXV0b3NpemUoKSB7XG4gICAgICAgIGlmICghdGhpcy5jb2x1bW5Hcm91cCkge1xuXG4gICAgICAgICAgICB0aGlzLndpZHRoID0gdGhpcy5nZXRMYXJnZXN0Q2VsbFdpZHRoKCk7XG5cbiAgICAgICAgICAgIHRoaXMuZ3JpZC5tYXJrRm9yQ2hlY2soKTtcbiAgICAgICAgICAgIHRoaXMuZ3JpZC5yZWZsb3coKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0Q2FsY1dpZHRoKCk6IGFueSB7XG4gICAgICAgIGlmICh0aGlzLl9jYWxjV2lkdGggIT09IG51bGwgJiYgIWlzTmFOKHRoaXMuY2FsY1BpeGVsV2lkdGgpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY2FsY1dpZHRoO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY2FjaGVDYWxjV2lkdGgoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NhbGNXaWR0aDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICogUmV0dXJucyB0aGUgc2l6ZSAoaW4gcGl4ZWxzKSBvZiB0aGUgbG9uZ2VzdCBjdXJyZW50bHkgdmlzaWJsZSBjZWxsLCBpbmNsdWRpbmcgdGhlIGhlYWRlciBjZWxsLlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBAVmlld0NoaWxkKCdncmlkJykgZ3JpZDogSWd4R3JpZENvbXBvbmVudDtcbiAgICAgKlxuICAgICAqIGxldCBjb2x1bW4gPSB0aGlzLmdyaWQuY29sdW1uTGlzdC5maWx0ZXIoYyA9PiBjLmZpZWxkID09PSAnSUQnKVswXTtcbiAgICAgKiBsZXQgc2l6ZSA9IGNvbHVtbi5nZXRMYXJnZXN0Q2VsbFdpZHRoKCk7XG4gICAgICogYGBgXG4gICAgICogQG1lbWJlcm9mIElneENvbHVtbkNvbXBvbmVudFxuICAgICAqL1xuICAgIHB1YmxpYyBnZXRMYXJnZXN0Q2VsbFdpZHRoKCk6IHN0cmluZyB7XG4gICAgICAgIGNvbnN0IHJhbmdlID0gdGhpcy5ncmlkLmRvY3VtZW50LmNyZWF0ZVJhbmdlKCk7XG4gICAgICAgIGNvbnN0IGxhcmdlc3QgPSBuZXcgTWFwPG51bWJlciwgbnVtYmVyPigpO1xuXG4gICAgICAgIGlmICh0aGlzLmNlbGxzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGxldCBjZWxsc0NvbnRlbnRXaWR0aHMgPSBbXTtcbiAgICAgICAgICAgIGlmICh0aGlzLmNlbGxzWzBdLm5hdGl2ZUVsZW1lbnQuY2hpbGRyZW4ubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIHRoaXMuY2VsbHMuZm9yRWFjaCgoY2VsbCkgPT4gY2VsbHNDb250ZW50V2lkdGhzLnB1c2goY2VsbC5jYWxjdWxhdGVTaXplVG9GaXQocmFuZ2UpKSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNlbGxzQ29udGVudFdpZHRocyA9IHRoaXMuY2VsbHMubWFwKChjZWxsKSA9PiBnZXROb2RlU2l6ZVZpYVJhbmdlKHJhbmdlLCBjZWxsLm5hdGl2ZUVsZW1lbnQpKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3QgaW5kZXggPSBjZWxsc0NvbnRlbnRXaWR0aHMuaW5kZXhPZihNYXRoLm1heCguLi5jZWxsc0NvbnRlbnRXaWR0aHMpKTtcbiAgICAgICAgICAgIGNvbnN0IGNlbGxTdHlsZSA9IHRoaXMuZ3JpZC5kb2N1bWVudC5kZWZhdWx0Vmlldy5nZXRDb21wdXRlZFN0eWxlKHRoaXMuY2VsbHNbaW5kZXhdLm5hdGl2ZUVsZW1lbnQpO1xuICAgICAgICAgICAgY29uc3QgY2VsbFBhZGRpbmcgPSBwYXJzZUZsb2F0KGNlbGxTdHlsZS5wYWRkaW5nTGVmdCkgKyBwYXJzZUZsb2F0KGNlbGxTdHlsZS5wYWRkaW5nUmlnaHQpICtcbiAgICAgICAgICAgICAgICBwYXJzZUZsb2F0KGNlbGxTdHlsZS5ib3JkZXJSaWdodFdpZHRoKTtcblxuICAgICAgICAgICAgbGFyZ2VzdC5zZXQoTWF0aC5tYXgoLi4uY2VsbHNDb250ZW50V2lkdGhzKSwgY2VsbFBhZGRpbmcpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuaGVhZGVyQ2VsbCkge1xuICAgICAgICAgICAgbGV0IGhlYWRlckNlbGw7XG4gICAgICAgICAgICBpZiAodGhpcy5oZWFkZXJUZW1wbGF0ZSAmJiB0aGlzLmhlYWRlckNlbGwuZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LmNoaWxkcmVuWzBdLmNoaWxkcmVuLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJDZWxsID0gTWF0aC5tYXgoLi4uQXJyYXkuZnJvbSh0aGlzLmhlYWRlckNlbGwuZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LmNoaWxkcmVuWzBdLmNoaWxkcmVuKVxuICAgICAgICAgICAgICAgICAgICAubWFwKChjaGlsZCkgPT4gZ2V0Tm9kZVNpemVWaWFSYW5nZShyYW5nZSwgY2hpbGQpKSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGhlYWRlckNlbGwgPSBnZXROb2RlU2l6ZVZpYVJhbmdlKHJhbmdlLCB0aGlzLmhlYWRlckNlbGwuZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LmNoaWxkcmVuWzBdKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHRoaXMuc29ydGFibGUgfHwgdGhpcy5maWx0ZXJhYmxlKSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyQ2VsbCArPSB0aGlzLmhlYWRlckNlbGwuZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LmNoaWxkcmVuWzFdLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLndpZHRoO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25zdCBoZWFkZXJTdHlsZSA9IHRoaXMuZ3JpZC5kb2N1bWVudC5kZWZhdWx0Vmlldy5nZXRDb21wdXRlZFN0eWxlKHRoaXMuaGVhZGVyQ2VsbC5lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQpO1xuICAgICAgICAgICAgY29uc3QgaGVhZGVyUGFkZGluZyA9IHBhcnNlRmxvYXQoaGVhZGVyU3R5bGUucGFkZGluZ0xlZnQpICsgcGFyc2VGbG9hdChoZWFkZXJTdHlsZS5wYWRkaW5nUmlnaHQpICtcbiAgICAgICAgICAgICAgICBwYXJzZUZsb2F0KGhlYWRlclN0eWxlLmJvcmRlclJpZ2h0V2lkdGgpO1xuICAgICAgICAgICAgbGFyZ2VzdC5zZXQoaGVhZGVyQ2VsbCwgaGVhZGVyUGFkZGluZyk7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGxhcmdlc3RDZWxsID0gTWF0aC5tYXgoLi4uQXJyYXkuZnJvbShsYXJnZXN0LmtleXMoKSkpO1xuICAgICAgICBjb25zdCB3aWR0aCA9IE1hdGguY2VpbChsYXJnZXN0Q2VsbCArIGxhcmdlc3QuZ2V0KGxhcmdlc3RDZWxsKSk7XG5cbiAgICAgICAgaWYgKE51bWJlci5pc05hTih3aWR0aCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLndpZHRoO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHdpZHRoICsgJ3B4JztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqQGhpZGRlblxuICAgICAqL1xuICAgIHB1YmxpYyBnZXRDZWxsV2lkdGgoKSB7XG4gICAgICAgIGNvbnN0IGNvbFdpZHRoID0gdGhpcy53aWR0aDtcbiAgICAgICAgY29uc3QgaXNQZXJjZW50YWdlV2lkdGggPSBjb2xXaWR0aCAmJiB0eXBlb2YgY29sV2lkdGggPT09ICdzdHJpbmcnICYmIGNvbFdpZHRoLmluZGV4T2YoJyUnKSAhPT0gLTE7XG5cbiAgICAgICAgaWYgKHRoaXMuY29sdW1uTGF5b3V0Q2hpbGQpIHtcbiAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjb2xXaWR0aCAmJiAhaXNQZXJjZW50YWdlV2lkdGgpIHtcblxuICAgICAgICAgICAgbGV0IGNlbGxXaWR0aCA9IGNvbFdpZHRoO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBjZWxsV2lkdGggIT09ICdzdHJpbmcnIHx8IGNlbGxXaWR0aC5lbmRzV2l0aCgncHgnKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICBjZWxsV2lkdGggKz0gJ3B4JztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGNlbGxXaWR0aDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBjb2xXaWR0aDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgY2FjaGVDYWxjV2lkdGgoKTogYW55IHtcbiAgICAgICAgY29uc3QgY29sV2lkdGggPSB0aGlzLndpZHRoO1xuICAgICAgICBjb25zdCBpc1BlcmNlbnRhZ2VXaWR0aCA9IGNvbFdpZHRoICYmIHR5cGVvZiBjb2xXaWR0aCA9PT0gJ3N0cmluZycgJiYgY29sV2lkdGguaW5kZXhPZignJScpICE9PSAtMTtcbiAgICAgICAgaWYgKGlzUGVyY2VudGFnZVdpZHRoKSB7XG4gICAgICAgICAgICB0aGlzLl9jYWxjV2lkdGggPSBwYXJzZUludChjb2xXaWR0aCwgMTApIC8gMTAwICogKHRoaXMuZ3JpZC5jYWxjV2lkdGggLSB0aGlzLmdyaWQuZmVhdHVyZUNvbHVtbnNXaWR0aCk7XG4gICAgICAgIH0gZWxzZSBpZiAoIWNvbFdpZHRoKSB7XG4gICAgICAgICAgICAvLyBubyB3aWR0aFxuICAgICAgICAgICAgdGhpcy5fY2FsY1dpZHRoID0gdGhpcy5kZWZhdWx0V2lkdGggfHwgdGhpcy5ncmlkLmdldFBvc3NpYmxlQ29sdW1uV2lkdGgoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX2NhbGNXaWR0aCA9IHRoaXMud2lkdGg7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jYWxjUGl4ZWxXaWR0aCA9IHBhcnNlSW50KHRoaXMuX2NhbGNXaWR0aCwgMTApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBwdWJsaWMgcG9wdWxhdGVWaXNpYmxlSW5kZXhlcygpIHsgfVxufVxuXG5cbkBDb21wb25lbnQoe1xuICAgIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoLFxuICAgIHByb3ZpZGVyczogW3sgcHJvdmlkZTogSWd4Q29sdW1uQ29tcG9uZW50LCB1c2VFeGlzdGluZzogZm9yd2FyZFJlZigoKSA9PiBJZ3hDb2x1bW5Hcm91cENvbXBvbmVudCkgfV0sXG4gICAgc2VsZWN0b3I6ICdpZ3gtY29sdW1uLWdyb3VwJyxcbiAgICB0ZW1wbGF0ZTogYGBcbn0pXG5leHBvcnQgY2xhc3MgSWd4Q29sdW1uR3JvdXBDb21wb25lbnQgZXh0ZW5kcyBJZ3hDb2x1bW5Db21wb25lbnQgaW1wbGVtZW50cyBBZnRlckNvbnRlbnRJbml0IHtcblxuICAgIEBDb250ZW50Q2hpbGRyZW4oSWd4Q29sdW1uQ29tcG9uZW50LCB7IHJlYWQ6IElneENvbHVtbkNvbXBvbmVudCB9KVxuICAgIGNoaWxkcmVuID0gbmV3IFF1ZXJ5TGlzdDxJZ3hDb2x1bW5Db21wb25lbnQ+KCk7XG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgY29sdW1uIGdyb3VwIGBzdW1tYXJpZXNgLlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBsZXQgY29sdW1uR3JvdXBTdW1tYXJpZXMgPSB0aGlzLmNvbHVtbkdyb3VwLnN1bW1hcmllcztcbiAgICAgKiBgYGBcbiAgICAgKiBAbWVtYmVyb2YgSWd4Q29sdW1uR3JvdXBDb21wb25lbnRcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHB1YmxpYyBnZXQgc3VtbWFyaWVzKCk6IGFueSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zdW1tYXJpZXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGNvbHVtbiBncm91cCBgc3VtbWFyaWVzYC5cbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogdGhpcy5jb2x1bW5Hcm91cC5zdW1tYXJpZXMgPSBJZ3hOdW1iZXJTdW1tYXJ5T3BlcmFuZDtcbiAgICAgKiBgYGBcbiAgICAgKiBAbWVtYmVyb2YgSWd4Q29sdW1uR3JvdXBDb21wb25lbnRcbiAgICAgKi9cbiAgICBwdWJsaWMgc2V0IHN1bW1hcmllcyhjbGFzc1JlZjogYW55KSB7IH1cbiAgICAvKipcbiAgICAgKiBTZXRzL2dldHMgd2hldGhlciB0aGUgY29sdW1uIGdyb3VwIGlzIGBzZWFyY2hhYmxlYC5cbiAgICAgKiBEZWZhdWx0IHZhbHVlIGlzIGB0cnVlYC5cbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogbGV0IGlzU2VhcmNoYWJsZSA9ICB0aGlzLmNvbHVtbkdyb3VwLnNlYXJjaGFibGU7XG4gICAgICogYGBgXG4gICAgICogYGBgaHRtbFxuICAgICAqICA8aWd4LWNvbHVtbi1ncm91cCBbc2VhcmNoYWJsZV0gPSBcImZhbHNlXCI+PC9pZ3gtY29sdW1uLWdyb3VwPlxuICAgICAqIGBgYFxuICAgICAqIEBtZW1iZXJvZiBJZ3hDb2x1bW5Hcm91cENvbXBvbmVudFxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgcHVibGljIHNlYXJjaGFibGUgPSB0cnVlO1xuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGNvbHVtbiBncm91cCBgZmlsdGVyc2AuXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIGxldCBjb2x1bW5Hcm91cEZpbHRlcnMgPSB0aGlzLmNvbHVtbkdyb3VwLmZpbHRlcnM7XG4gICAgICogYGBgXG4gICAgICogQG1lbWJlcm9mIElneENvbHVtbkdyb3VwQ29tcG9uZW50XG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBwdWJsaWMgZ2V0IGZpbHRlcnMoKTogYW55IHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ZpbHRlcnM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGNvbHVtbiBncm91cCBgZmlsdGVyc2AuXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIHRoaXMuY29sdW1uR3JvdXAuZmlsdGVycyA9IElneFN0cmluZ0ZpbHRlcmluZ09wZXJhbmQ7XG4gICAgICogYGBgXG4gICAgICogQG1lbWJlcm9mIElneENvbHVtbkdyb3VwQ29tcG9uZW50XG4gICAgICovXG4gICAgcHVibGljIHNldCBmaWx0ZXJzKGNsYXNzUmVmOiBhbnkpIHsgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIHJlZmVyZW5jZSB0byB0aGUgYm9keSB0ZW1wbGF0ZS5cbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogbGV0IGJvZHlUZW1wbGF0ZSA9IHRoaXMuY29sdW1uR3JvdXAuYm9keVRlbXBsYXRlO1xuICAgICAqIGBgYFxuICAgICAqIEBtZW1iZXJvZiBJZ3hDb2x1bW5Hcm91cENvbXBvbmVudFxuICAgICAqL1xuICAgIGdldCBib2R5VGVtcGxhdGUoKTogVGVtcGxhdGVSZWY8YW55PiB7XG4gICAgICAgIHJldHVybiB0aGlzLl9ib2R5VGVtcGxhdGU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBzZXQgYm9keVRlbXBsYXRlKHRlbXBsYXRlOiBUZW1wbGF0ZVJlZjxhbnk+KSB7IH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgcmVmZXJlbmNlIHRvIHRoZSBoZWFkZXIgdGVtcGxhdGUuXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIGxldCBoZWFkZXJUZW1wbGF0ZSA9IHRoaXMuY29sdW1uR3JvdXAuaGVhZGVyVGVtcGxhdGU7XG4gICAgICogYGBgXG4gICAgICogQG1lbWJlcm9mIElneENvbHVtbkdyb3VwQ29tcG9uZW50XG4gICAgICovXG4gICAgZ2V0IGhlYWRlclRlbXBsYXRlKCk6IFRlbXBsYXRlUmVmPGFueT4ge1xuICAgICAgICByZXR1cm4gdGhpcy5faGVhZGVyVGVtcGxhdGU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKiBAbWVtYmVyb2YgSWd4Q29sdW1uR3JvdXBDb21wb25lbnRcbiAgICAgKi9cbiAgICBzZXQgaGVhZGVyVGVtcGxhdGUodGVtcGxhdGU6IFRlbXBsYXRlUmVmPGFueT4pIHsgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSByZWZlcmVuY2UgdG8gdGhlIGlubGluZSBlZGl0b3IgdGVtcGxhdGUuXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIGxldCBpbmxpbmVFZGl0b3JUZW1wbGF0ZSA9IHRoaXMuY29sdW1uR3JvdXAuaW5saW5lRWRpdG9yVGVtcGxhdGU7XG4gICAgICogYGBgXG4gICAgICogQG1lbWJlcm9mIElneENvbHVtbkdyb3VwQ29tcG9uZW50XG4gICAgICovXG4gICAgZ2V0IGlubGluZUVkaXRvclRlbXBsYXRlKCk6IFRlbXBsYXRlUmVmPGFueT4ge1xuICAgICAgICByZXR1cm4gdGhpcy5faW5saW5lRWRpdG9yVGVtcGxhdGU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBzZXQgaW5saW5lRWRpdG9yVGVtcGxhdGUodGVtcGxhdGU6IFRlbXBsYXRlUmVmPGFueT4pIHsgfVxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGNvbHVtbiBncm91cCBjZWxscy5cbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogbGV0IGNvbHVtbkNlbGxzID0gdGhpcy5jb2x1bW5Hcm91cC5jZWxscztcbiAgICAgKiBgYGBcbiAgICAgKiBAbWVtYmVyb2YgSWd4Q29sdW1uR3JvdXBDb21wb25lbnRcbiAgICAgKi9cbiAgICBnZXQgY2VsbHMoKTogSWd4R3JpZENlbGxDb21wb25lbnRbXSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyB3aGV0aGVyIHRoZSBjb2x1bW4gZ3JvdXAgaXMgaGlkZGVuLlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBsZXQgaXNIaWRkZW4gPSB0aGlzLmNvbHVtbkdyb3VwLmhpZGRlbjtcbiAgICAgKiBgYGBcbiAgICAgKiBAbWVtYmVyb2YgSWd4Q29sdW1uR3JvdXBDb21wb25lbnRcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIGdldCBoaWRkZW4oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFsbENoaWxkcmVuLmV2ZXJ5KGMgPT4gYy5oaWRkZW4pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBjb2x1bW4gZ3JvdXAgaGlkZGVuIHByb3BlcnR5LlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiA8aWd4LWNvbHVtbiBbaGlkZGVuXSA9IFwidHJ1ZVwiPjwvaWd4LWNvbHVtbj5cbiAgICAgKiBgYGBcbiAgICAgKiBAbWVtYmVyb2YgSWd4Q29sdW1uR3JvdXBDb21wb25lbnRcbiAgICAgKi9cbiAgICBzZXQgaGlkZGVuKHZhbHVlOiBib29sZWFuKSB7XG4gICAgICAgIHRoaXMuX2hpZGRlbiA9IHZhbHVlO1xuICAgICAgICB0aGlzLmNoaWxkcmVuLmZvckVhY2goY2hpbGQgPT4gY2hpbGQuaGlkZGVuID0gdmFsdWUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKkBoaWRkZW5cbiAgICAgKi9cbiAgICBuZ0FmdGVyQ29udGVudEluaXQoKSB7XG4gICAgICAgIC8qXG4gICAgICAgICAgICBAQ29udGVudENoaWxkcmVuIHdpdGggZGVzY2VuZGFudHMgc3RpbGwgcmV0dXJucyB0aGUgYHBhcmVudGBcbiAgICAgICAgICAgIGNvbXBvbmVudCBpbiB0aGUgcXVlcnkgbGlzdC5cbiAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jaGlsZHJlbi5yZXNldCh0aGlzLmNoaWxkcmVuLnRvQXJyYXkoKS5zbGljZSgxKSk7XG4gICAgICAgIHRoaXMuY2hpbGRyZW4uZm9yRWFjaChjaGlsZCA9PiB7XG4gICAgICAgICAgICBjaGlsZC5wYXJlbnQgPSB0aGlzO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgY2hpbGRyZW4gY29sdW1ucyBjb2xsZWN0aW9uLlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBsZXQgY29sdW1ucyA9ICB0aGlzLmNvbHVtbkdyb3VwLmFsbENoaWxkcmVuO1xuICAgICAqIGBgYFxuICAgICAqIEBtZW1iZXJvZiBJZ3hDb2x1bW5Hcm91cENvbXBvbmVudFxuICAgICAqL1xuICAgIGdldCBhbGxDaGlsZHJlbigpOiBJZ3hDb2x1bW5Db21wb25lbnRbXSB7XG4gICAgICAgIHJldHVybiBmbGF0dGVuKHRoaXMuY2hpbGRyZW4udG9BcnJheSgpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIGJvb2xlYW4gaW5kaWNhdGluZyBpZiB0aGUgY29sdW1uIGlzIGEgYENvbHVtbkdyb3VwYC5cbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogbGV0IGlzQ29sdW1uR3JvdXAgPSAgdGhpcy5jb2x1bW5Hcm91cC5jb2x1bW5Hcm91cFxuICAgICAqIGBgYFxuICAgICAqIEBtZW1iZXJvZiBJZ3hDb2x1bW5Hcm91cENvbXBvbmVudFxuICAgICAqL1xuICAgIGdldCBjb2x1bW5Hcm91cCgpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBib29sZWFuIGluZGljYXRpbmcgaWYgdGhlIGNvbHVtbiBpcyBhIGBDb2x1bW5MYXlvdXRgIGZvciBtdWx0aS1yb3cgbGF5b3V0LlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBsZXQgY29sdW1uR3JvdXAgPSAgdGhpcy5jb2x1bW4uY29sdW1uR3JvdXA7XG4gICAgICogYGBgXG4gICAgICogQG1lbWJlcm9mIElneENvbHVtbkNvbXBvbmVudFxuICAgICAqL1xuICAgIGdldCBjb2x1bW5MYXlvdXQoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgd2lkdGggb2YgdGhlIGNvbHVtbiBncm91cC5cbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogbGV0IGNvbHVtbkdyb3VwV2lkdGggPSB0aGlzLmNvbHVtbkdyb3VwLndpZHRoO1xuICAgICAqIGBgYFxuICAgICAqIEBtZW1iZXJvZiBJZ3hDb2x1bW5Hcm91cENvbXBvbmVudFxuICAgICAqL1xuICAgIGdldCB3aWR0aCgpIHtcbiAgICAgICAgbGV0IGlzQ2hpbGRyZW5XaWR0aEluUGVyY2VudCA9IGZhbHNlLCB3aWR0aDtcbiAgICAgICAgd2lkdGggPSBgJHt0aGlzLmNoaWxkcmVuLnJlZHVjZSgoYWNjLCB2YWwpID0+IHtcbiAgICAgICAgICAgIGlmICh2YWwuaGlkZGVuKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsLndpZHRoID09PSAnc3RyaW5nJyAmJiB2YWwud2lkdGguaW5kZXhPZignJScpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgIGlzQ2hpbGRyZW5XaWR0aEluUGVyY2VudCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYWNjICsgcGFyc2VJbnQodmFsLndpZHRoLCAxMCk7XG4gICAgICAgIH0sIDApfWA7XG4gICAgICAgIHJldHVybiBpc0NoaWxkcmVuV2lkdGhJblBlcmNlbnQgPyB3aWR0aCArICclJyA6IHdpZHRoO1xuICAgIH1cblxuICAgIHNldCB3aWR0aCh2YWwpIHsgfVxuXG4gICAgY29uc3RydWN0b3IocHVibGljIGdyaWRBUEk6IEdyaWRCYXNlQVBJU2VydmljZTxJZ3hHcmlkQmFzZUNvbXBvbmVudCAmIElHcmlkRGF0YUJpbmRhYmxlPiwgcHVibGljIGNkcjogQ2hhbmdlRGV0ZWN0b3JSZWYpIHtcbiAgICAgICAgLy8gRC5QLiBjb25zdHJ1Y3RvciBkdXBsaWNhdGlvbiBkdWUgdG8gZXM2IGNvbXBpbGF0aW9uLCBtaWdodCBiZSBvYnNvbGV0ZSBpbiB0aGUgZnV0dXJlXG4gICAgICAgIHN1cGVyKGdyaWRBUEksIGNkcik7XG4gICAgfVxufVxuXG5AQ29tcG9uZW50KHtcbiAgICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaCxcbiAgICBwcm92aWRlcnM6IFt7IHByb3ZpZGU6IElneENvbHVtbkNvbXBvbmVudCwgdXNlRXhpc3Rpbmc6IGZvcndhcmRSZWYoKCkgPT4gSWd4Q29sdW1uTGF5b3V0Q29tcG9uZW50KSB9XSxcbiAgICBzZWxlY3RvcjogJ2lneC1jb2x1bW4tbGF5b3V0JyxcbiAgICB0ZW1wbGF0ZTogYGBcbn0pXG5leHBvcnQgY2xhc3MgSWd4Q29sdW1uTGF5b3V0Q29tcG9uZW50IGV4dGVuZHMgSWd4Q29sdW1uR3JvdXBDb21wb25lbnQgaW1wbGVtZW50cyBBZnRlckNvbnRlbnRJbml0IHtcbiAgICBwdWJsaWMgY2hpbGRyZW5WaXNpYmxlSW5kZXhlcyA9IFtdO1xuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIHdpZHRoIG9mIHRoZSBjb2x1bW4gbGF5b3V0LlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBsZXQgY29sdW1uR3JvdXBXaWR0aCA9IHRoaXMuY29sdW1uR3JvdXAud2lkdGg7XG4gICAgICogYGBgXG4gICAgICogQG1lbWJlcm9mIElneENvbHVtbkdyb3VwQ29tcG9uZW50XG4gICAgICovXG4gICAgZ2V0IHdpZHRoKCk6IGFueSB7XG4gICAgICAgIGNvbnN0IHdpZHRoID0gdGhpcy5nZXRGaWxsZWRDaGlsZENvbHVtblNpemVzKHRoaXMuY2hpbGRyZW4pLnJlZHVjZSgoYWNjLCB2YWwpID0+IGFjYyArIHBhcnNlSW50KHZhbCwgMTApLCAwKTtcbiAgICAgICAgcmV0dXJuIHdpZHRoO1xuICAgIH1cblxuICAgIHNldCB3aWR0aCh2YWw6IGFueSkgeyB9XG5cbiAgICBnZXQgY29sdW1uTGF5b3V0KCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHVibGljIGdldENhbGNXaWR0aCgpOiBhbnkge1xuICAgICAgICBsZXQgYm9yZGVyV2lkdGggPSAwO1xuXG4gICAgICAgIGlmICh0aGlzLmhlYWRlckdyb3VwICYmIHRoaXMuaGVhZGVyR3JvdXAuaGFzTGFzdFBpbm5lZENoaWxkQ29sdW1uKSB7XG4gICAgICAgICAgICBjb25zdCBoZWFkZXJTdHlsZXMgPSB0aGlzLmdyaWQuZG9jdW1lbnQuZGVmYXVsdFZpZXcuZ2V0Q29tcHV0ZWRTdHlsZSh0aGlzLmhlYWRlckdyb3VwLmVsZW1lbnQubmF0aXZlRWxlbWVudC5jaGlsZHJlblswXSk7XG4gICAgICAgICAgICBib3JkZXJXaWR0aCA9IHBhcnNlSW50KGhlYWRlclN0eWxlcy5ib3JkZXJSaWdodFdpZHRoLCAxMCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gc3VwZXIuZ2V0Q2FsY1dpZHRoKCkgKyBib3JkZXJXaWR0aDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBjb2x1bW4gdmlzaWJsZSBpbmRleC5cbiAgICAgKiBJZiB0aGUgY29sdW1uIGlzIG5vdCB2aXNpYmxlLCByZXR1cm5zIGAtMWAuXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIGxldCB2aXNpYmxlQ29sdW1uSW5kZXggPSAgdGhpcy5jb2x1bW4udmlzaWJsZUluZGV4O1xuICAgICAqIGBgYFxuICAgICAqIEBtZW1iZXJvZiBJZ3hDb2x1bW5Db21wb25lbnRcbiAgICAgKi9cbiAgICBnZXQgdmlzaWJsZUluZGV4KCk6IG51bWJlciB7XG4gICAgICAgIGlmICghaXNOYU4odGhpcy5fdkluZGV4KSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3ZJbmRleDtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHVucGlubmVkQ29sdW1ucyA9IHRoaXMuZ3JpZC51bnBpbm5lZENvbHVtbnMuZmlsdGVyKGMgPT4gYy5jb2x1bW5MYXlvdXQgJiYgIWMuaGlkZGVuKTtcbiAgICAgICAgY29uc3QgcGlubmVkQ29sdW1ucyA9IHRoaXMuZ3JpZC5waW5uZWRDb2x1bW5zLmZpbHRlcihjID0+IGMuY29sdW1uTGF5b3V0ICYmICFjLmhpZGRlbik7XG4gICAgICAgIGxldCB2SW5kZXggPSAtMTtcblxuICAgICAgICBpZiAoIXRoaXMucGlubmVkKSB7XG4gICAgICAgICAgICBjb25zdCBpbmRleEluQ29sbGVjdGlvbiA9IHVucGlubmVkQ29sdW1ucy5pbmRleE9mKHRoaXMpO1xuICAgICAgICAgICAgdkluZGV4ID0gaW5kZXhJbkNvbGxlY3Rpb24gPT09IC0xID8gLTEgOiBwaW5uZWRDb2x1bW5zLmxlbmd0aCArIGluZGV4SW5Db2xsZWN0aW9uO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdkluZGV4ID0gcGlubmVkQ29sdW1ucy5pbmRleE9mKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3ZJbmRleCA9IHZJbmRleDtcbiAgICAgICAgcmV0dXJuIHZJbmRleDtcbiAgICB9XG5cbiAgICAvKlxuICAgICAqIEdldHMgd2hldGhlciB0aGUgY29sdW1uIGxheW91dCBpcyBoaWRkZW4uXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIGxldCBpc0hpZGRlbiA9IHRoaXMuY29sdW1uR3JvdXAuaGlkZGVuO1xuICAgICAqIGBgYFxuICAgICAqIEBtZW1iZXJvZiBJZ3hDb2x1bW5Hcm91cENvbXBvbmVudFxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgZ2V0IGhpZGRlbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2hpZGRlbjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBjb2x1bW4gbGF5b3V0IGhpZGRlbiBwcm9wZXJ0eS5cbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogPGlneC1jb2x1bW4tbGF5b3V0IFtoaWRkZW5dID0gXCJ0cnVlXCI+PC9pZ3gtY29sdW1uLT5cbiAgICAgKiBgYGBcbiAgICAgKiBAbWVtYmVyb2YgSWd4Q29sdW1uR3JvdXBDb21wb25lbnRcbiAgICAgKi9cbiAgICBzZXQgaGlkZGVuKHZhbHVlOiBib29sZWFuKSB7XG4gICAgICAgIHRoaXMuX2hpZGRlbiA9IHZhbHVlO1xuICAgICAgICB0aGlzLmNoaWxkcmVuLmZvckVhY2goY2hpbGQgPT4gY2hpbGQuaGlkZGVuID0gdmFsdWUpO1xuICAgICAgICBpZiAodGhpcy5ncmlkICYmIHRoaXMuZ3JpZC5jb2x1bW5zICYmIHRoaXMuZ3JpZC5jb2x1bW5zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIC8vIHJlc2V0IGluZGV4ZXMgaW4gY2FzZSBjb2x1bW5zIGFyZSBoaWRkZW4vc2hvd24gcnVudGltZVxuICAgICAgICAgICAgdGhpcy5ncmlkLmNvbHVtbnMuZmlsdGVyKHggPT4geC5jb2x1bW5Hcm91cCkuZm9yRWFjaCggeCA9PiB4LnBvcHVsYXRlVmlzaWJsZUluZGV4ZXMoKSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKkBoaWRkZW5cbiAgICAqL1xuICAgIG5nQWZ0ZXJDb250ZW50SW5pdCgpIHtcbiAgICAgICAgc3VwZXIubmdBZnRlckNvbnRlbnRJbml0KCk7XG4gICAgICAgIGlmICghdGhpcy5oaWRkZW4pIHtcbiAgICAgICAgICAgIHRoaXMuaGlkZGVuID0gdGhpcy5hbGxDaGlsZHJlbi5zb21lKHggPT4geC5oaWRkZW4pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5jaGlsZHJlbi5mb3JFYWNoKGNoaWxkID0+IGNoaWxkLmhpZGRlbiA9IHRoaXMuaGlkZGVuKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuY2hpbGRyZW4uZm9yRWFjaChjaGlsZCA9PiB7XG4gICAgICAgICAgICBjaGlsZC5kaXNhYmxlSGlkaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgIGNoaWxkLmRpc2FibGVQaW5uaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgIGNoaWxkLm1vdmFibGUgPSBmYWxzZTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLypcbiAgICAgKiBHZXRzIHdoZXRoZXIgdGhlIGdyb3VwIGNvbnRhaW5zIHRoZSBsYXN0IHBpbm5lZCBjaGlsZCBjb2x1bW4gb2YgdGhlIGNvbHVtbiBsYXlvdXQuXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIGxldCBjb2x1bXNIYXNMYXN0UGlubmVkID0gdGhpcy5jb2x1bW5MYXlvdXQuaGFzTGFzdFBpbm5lZENoaWxkQ29sdW1uO1xuICAgICAqIGBgYFxuICAgICAqIEBtZW1iZXJvZiBJZ3hDb2x1bW5MYXlvdXRDb21wb25lbnRcbiAgICAgKi9cbiAgICBnZXQgaGFzTGFzdFBpbm5lZENoaWxkQ29sdW1uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jaGlsZHJlbi5zb21lKGNoaWxkID0+IGNoaWxkLmlzTGFzdFBpbm5lZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpAaGlkZGVuXG4gICAgKi9cbiAgICBwdWJsaWMgcG9wdWxhdGVWaXNpYmxlSW5kZXhlcygpIHtcbiAgICAgICAgdGhpcy5jaGlsZHJlblZpc2libGVJbmRleGVzID0gW107XG4gICAgICAgIGNvbnN0IGdyaWQgPSB0aGlzLmdyaWRBUEkuZ3JpZDtcbiAgICAgICAgY29uc3QgY29sdW1ucyA9IGdyaWQgJiYgZ3JpZC5waW5uZWRDb2x1bW5zICYmIGdyaWQudW5waW5uZWRDb2x1bW5zID8gZ3JpZC5waW5uZWRDb2x1bW5zLmNvbmNhdChncmlkLnVucGlubmVkQ29sdW1ucykgOiBbXTtcbiAgICAgICAgY29uc3Qgb3JkZXJlZENvbHMgPSBjb2x1bW5zXG4gICAgICAgIC5maWx0ZXIoeCA9PiAheC5jb2x1bW5Hcm91cCAmJiAheC5oaWRkZW4pXG4gICAgICAgIC5zb3J0KChhLCBiKSA9PiBhLnJvd1N0YXJ0IC0gYi5yb3dTdGFydCB8fCBjb2x1bW5zLmluZGV4T2YoYS5wYXJlbnQpIC0gY29sdW1ucy5pbmRleE9mKGIucGFyZW50KSB8fCBhLmNvbFN0YXJ0IC0gYi5jb2xTdGFydCk7XG4gICAgICAgIHRoaXMuY2hpbGRyZW4uZm9yRWFjaChjaGlsZCA9PiB7XG4gICAgICAgICAgICBjb25zdCBycyA9IGNoaWxkLnJvd1N0YXJ0IHx8IDE7XG4gICAgICAgICAgICBsZXQgdkluZGV4ID0gMDtcbiAgICAgICAgICAgIC8vIGZpbHRlciBvdXQgYWxsIGNvbHMgd2l0aCBsYXJnZXIgcm93U3RhcnRcbiAgICAgICAgICAgIGNvbnN0IGNvbHMgPSBvcmRlcmVkQ29scy5maWx0ZXIoYyA9PlxuICAgICAgICAgICAgICAgICFjLmNvbHVtbkdyb3VwICYmIChjLnJvd1N0YXJ0IHx8IDEpIDw9IHJzKTtcbiAgICAgICAgICAgIHZJbmRleCA9IGNvbHMuaW5kZXhPZihjaGlsZCk7XG4gICAgICAgICAgICB0aGlzLmNoaWxkcmVuVmlzaWJsZUluZGV4ZXMucHVzaCh7Y29sdW1uOiBjaGlsZCwgaW5kZXg6IHZJbmRleH0pO1xuICAgICAgICB9KTtcbiAgICB9XG5cbn1cbiJdfQ==