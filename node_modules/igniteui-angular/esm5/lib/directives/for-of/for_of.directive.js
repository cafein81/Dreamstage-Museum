/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import * as tslib_1 from "tslib";
import { CommonModule } from '@angular/common';
import { ChangeDetectorRef, ComponentFactoryResolver, Directive, EventEmitter, Input, IterableDiffers, NgModule, NgZone, Output, TemplateRef, ViewContainerRef } from '@angular/core';
import { DisplayContainerComponent } from './display.container';
import { HVirtualHelperComponent } from './horizontal.virtual.helper.component';
import { VirtualHelperComponent } from './virtual.helper.component';
import { IgxScrollInertiaModule } from './../scroll-inertia/scroll_inertia.directive';
import { IgxForOfSyncService } from './for_of.sync.service';
/**
 * @template T
 */
var IgxForOfDirective = /** @class */ (function () {
    function IgxForOfDirective(_viewContainer, _template, _differs, resolver, cdr, _zone) {
        this._viewContainer = _viewContainer;
        this._template = _template;
        this._differs = _differs;
        this.resolver = resolver;
        this.cdr = cdr;
        this._zone = _zone;
        /**
         * The current state of the directive. It contains `startIndex` and `chunkSize`.
         * state.startIndex - The index of the item at which the current visible chunk begins.
         * state.chunkSize - The number of items the current visible chunk holds.
         * These options can be used when implementing remote virtualization as they provide the necessary state information.
         * ```typescript
         * const gridState = this.parentVirtDir.state;
         * ```
         */
        this.state = {
            startIndex: 0,
            chunkSize: 0
        };
        /**
         * The total count of the virtual data items, when using remote service.
         * ```typescript
         * this.parentVirtDir.totalItemCount = data.Count;
         * ```
         */
        this.totalItemCount = null;
        /**
         * An event that is emitted after a new chunk has been loaded.
         * ```html
         * <ng-template igxFor [igxForOf]="data" [igxForScrollOrientation]="'horizontal'" (onChunkLoad)="chunkLoad($event)"></ng-template>
         * ```
         * ```typescript
         * chunkLoad(e){
         * alert("chunk loaded!");
         * }
         * ```
         */
        this.onChunkLoad = new EventEmitter();
        /**
         * An event that is emitted after data has been changed.
         * ```html
         * <ng-template igxFor [igxForOf]="data" [igxForScrollOrientation]="'horizontal'" (onDataChanged)="dataChanged($event)"></ng-template>
         * ```
         * ```typescript
         * dataChanged(e){
         * alert("data changed!");
         * }
         * ```
         */
        this.onDataChanged = new EventEmitter();
        this.onBeforeViewDestroyed = new EventEmitter();
        /**
         * An event that is emitted on chunk loading to emit the current state information - startIndex, endIndex, totalCount.
         * Can be used for implementing remote load on demand for the igxFor data.
         * ```html
         * <ng-template igxFor [igxForOf]="data" [igxForScrollOrientation]="'horizontal'" (onChunkPreload)="chunkPreload($event)"></ng-template>
         * ```
         * ```typescript
         * chunkPreload(e){
         * alert("chunk is loading!");
         * }
         * ```
         */
        this.onChunkPreload = new EventEmitter();
        this._sizesCache = [];
        this._differ = null;
        this.heightCache = [];
        this.MAX_PERF_SCROLL_DIFF = 4;
        /**
         * Height that is being virtualized.
         */
        this._virtHeight = 0;
        /**
         * Ratio for height that's being virtualizaed and the one visible
         * If _virtHeightRatio = 1, the visible height and the virtualized are the same, also _maxHeight > _virtHeight.
         */
        this._virtHeightRatio = 1;
        /**
         * Internal track for scroll top that is being virtualized
         */
        this._virtScrollTop = 0;
        /**
         * If the next onScroll event is triggered due to internal setting of scrollTop
         */
        this._bScrollInternal = false;
        // End properties related to virtual height handling
        this._embeddedViews = [];
    }
    Object.defineProperty(IgxForOfDirective.prototype, "sizesCache", {
        get: /**
         * @protected
         * @return {?}
         */
        function () {
            return this._sizesCache;
        },
        set: /**
         * @protected
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._sizesCache = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxForOfDirective.prototype, "_isScrolledToBottom", {
        get: /**
         * @private
         * @return {?}
         */
        function () {
            if (!this.getVerticalScroll()) {
                return true;
            }
            /** @type {?} */
            var scrollTop = this.getVerticalScroll().scrollTop;
            /** @type {?} */
            var scrollHeight = this.getVerticalScroll().scrollHeight;
            // Use === and not >= because `scrollTop + container size` can't be bigger than `scrollHeight`, unless something isn't updated.
            // Also use Math.round because Chrome has some inconsistencies and `scrollTop + container` can be float when zooming the page.
            return Math.round(scrollTop + this.igxForContainerSize) === scrollHeight;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxForOfDirective.prototype, "_isAtBottomIndex", {
        get: /**
         * @private
         * @return {?}
         */
        function () {
            return this.igxForOf && this.state.startIndex + this.state.chunkSize > this.igxForOf.length;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxForOfDirective.prototype, "isRemote", {
        /**
         * @hidden
         */
        get: /**
         * @hidden
         * @protected
         * @return {?}
         */
        function () {
            return this.totalItemCount !== null;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @hidden
     */
    /**
     * @hidden
     * @protected
     * @return {?}
     */
    IgxForOfDirective.prototype.removeScrollEventListeners = /**
     * @hidden
     * @protected
     * @return {?}
     */
    function () {
        var _this = this;
        if (this.igxForScrollOrientation === 'horizontal') {
            this._zone.runOutsideAngular(function () {
                return _this.getHorizontalScroll().removeEventListener('scroll', _this.func);
            });
        }
        else {
            /** @type {?} */
            var vertical_1 = this.getVerticalScroll();
            if (vertical_1) {
                this._zone.runOutsideAngular(function () {
                    return vertical_1.removeEventListener('scroll', _this.verticalScrollHandler);
                });
            }
        }
    };
    /**
     * @param {?} event
     * @return {?}
     */
    IgxForOfDirective.prototype.verticalScrollHandler = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        this.onScroll(event);
    };
    /**
     * @return {?}
     */
    IgxForOfDirective.prototype.isScrollable = /**
     * @return {?}
     */
    function () {
        return this.vh.instance.height > parseInt(this.igxForContainerSize, 10);
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @return {?}
     */
    IgxForOfDirective.prototype.ngOnInit = /**
     * @hidden
     * @return {?}
     */
    function () {
        var _this = this;
        /** @type {?} */
        var totalSize = 0;
        /** @type {?} */
        var vc = this.igxForScrollContainer ? this.igxForScrollContainer._viewContainer : this._viewContainer;
        this.igxForSizePropName = this.igxForSizePropName || 'width';
        /** @type {?} */
        var dcFactory = this.resolver.resolveComponentFactory(DisplayContainerComponent);
        this.dc = this._viewContainer.createComponent(dcFactory, 0);
        this.dc.instance.scrollDirection = this.igxForScrollOrientation;
        if (typeof MSGesture === 'function') {
            // On Edge and IE when scrolling on touch the page scroll instead of the grid.
            this.dc.instance._viewContainer.element.nativeElement.style.touchAction = 'none';
        }
        if (this.igxForOf && this.igxForOf.length) {
            this.dc.instance.notVirtual = !(this.igxForContainerSize && this.state.chunkSize < this.igxForOf.length);
            totalSize = this.initSizesCache(this.igxForOf);
            this.hScroll = this.getElement(vc, 'igx-horizontal-virtual-helper');
            if (this.hScroll) {
                this.state.startIndex = this.getIndexAt(this.hScroll.scrollLeft, this.sizesCache, 0);
            }
            this.state.chunkSize = this._calculateChunkSize();
            for (var i = 0; i < this.state.chunkSize && this.igxForOf[i] !== undefined; i++) {
                /** @type {?} */
                var input = this.igxForOf[i];
                /** @type {?} */
                var embeddedView = this.dc.instance._vcr.createEmbeddedView(this._template, { $implicit: input, index: this.igxForOf.indexOf(input) });
                this._embeddedViews.push(embeddedView);
            }
        }
        if (this.igxForScrollOrientation === 'vertical') {
            this.dc.instance._viewContainer.element.nativeElement.style.top = '0px';
            /** @type {?} */
            var factory = this.resolver.resolveComponentFactory(VirtualHelperComponent);
            this.vh = vc.createComponent(factory);
            this._maxHeight = this._calcMaxBrowserHeight();
            this.vh.instance.height = this.igxForOf ? this._calcHeight() : 0;
            this._zone.runOutsideAngular(function () {
                _this.verticalScrollHandler = _this.verticalScrollHandler.bind(_this);
                _this.vh.instance.elementRef.nativeElement.addEventListener('scroll', _this.verticalScrollHandler);
                _this.dc.instance.scrollContainer = _this.vh.instance.elementRef.nativeElement;
            });
        }
        if (this.igxForScrollOrientation === 'horizontal') {
            this.func = function (evt) { _this.onHScroll(evt); };
            this.hScroll = this.getElement(vc, 'igx-horizontal-virtual-helper');
            if (!this.hScroll) {
                /** @type {?} */
                var hvFactory = this.resolver.resolveComponentFactory(HVirtualHelperComponent);
                this.hvh = vc.createComponent(hvFactory);
                this.hvh.instance.width = totalSize;
                this.hScroll = this.hvh.instance.elementRef.nativeElement;
                this._zone.runOutsideAngular(function () {
                    _this.hvh.instance.elementRef.nativeElement.addEventListener('scroll', _this.func);
                    _this.dc.instance.scrollContainer = _this.hScroll;
                });
            }
            else {
                this._zone.runOutsideAngular(function () {
                    _this.hScroll.addEventListener('scroll', _this.func);
                    _this.dc.instance.scrollContainer = _this.hScroll;
                });
            }
            /** @type {?} */
            var scrollOffset = this.hScroll.scrollLeft -
                (this.sizesCache && this.sizesCache.length ? this.sizesCache[this.state.startIndex] : 0);
            this.dc.instance._viewContainer.element.nativeElement.style.left = -scrollOffset + 'px';
        }
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @return {?}
     */
    IgxForOfDirective.prototype.ngOnDestroy = /**
     * @hidden
     * @return {?}
     */
    function () {
        this.removeScrollEventListeners();
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @param {?} changes
     * @return {?}
     */
    IgxForOfDirective.prototype.ngOnChanges = /**
     * @hidden
     * @param {?} changes
     * @return {?}
     */
    function (changes) {
        /** @type {?} */
        var forOf = 'igxForOf';
        if (forOf in changes) {
            /** @type {?} */
            var value = changes[forOf].currentValue;
            if (!this._differ && value) {
                try {
                    this._differ = this._differs.find(value).create(this.igxForTrackBy);
                }
                catch (e) {
                    throw new Error("Cannot find a differ supporting object \"" + value + "\" of type \"" + getTypeNameForDebugging(value) + "\".\n                     NgFor only supports binding to Iterables such as Arrays.");
                }
            }
        }
        /** @type {?} */
        var defaultItemSize = 'igxForItemSize';
        if (defaultItemSize in changes && !changes[defaultItemSize].firstChange && this.igxForScrollOrientation === 'vertical') {
            // handle default item size changed.
            this.initSizesCache(this.igxForOf);
            this._applyChanges();
        }
        /** @type {?} */
        var containerSize = 'igxForContainerSize';
        if (containerSize in changes && !changes[containerSize].firstChange && this.igxForOf) {
            this._recalcOnContainerChange(changes);
        }
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @return {?}
     */
    IgxForOfDirective.prototype.ngDoCheck = /**
     * @hidden
     * @return {?}
     */
    function () {
        var _this = this;
        if (this._differ) {
            /** @type {?} */
            var changes = this._differ.diff(this.igxForOf);
            if (changes) {
                //  re-init cache.
                if (!this.igxForOf) {
                    return;
                }
                this._updateSizeCache();
                this._zone.run(function () {
                    _this._applyChanges();
                    _this.cdr.markForCheck();
                    _this._updateScrollOffset();
                    _this.onDataChanged.emit();
                });
            }
        }
    };
    /**
     * Shifts the scroll thumb position.
     * ```typescript
     * this.parentVirtDir.addScrollTop(5);
     * ```
     * @param addTop negative value to scroll up and positive to scroll down;
     */
    /**
     * Shifts the scroll thumb position.
     * ```typescript
     * this.parentVirtDir.addScrollTop(5);
     * ```
     * @param {?} addTop negative value to scroll up and positive to scroll down;
     * @return {?}
     */
    IgxForOfDirective.prototype.addScrollTop = /**
     * Shifts the scroll thumb position.
     * ```typescript
     * this.parentVirtDir.addScrollTop(5);
     * ```
     * @param {?} addTop negative value to scroll up and positive to scroll down;
     * @return {?}
     */
    function (addTop) {
        if (addTop === 0 && this.igxForScrollOrientation === 'horizontal') {
            return false;
        }
        /** @type {?} */
        var originalVirtScrollTop = this._virtScrollTop;
        /** @type {?} */
        var containerSize = parseInt(this.igxForContainerSize, 10);
        /** @type {?} */
        var maxVirtScrollTop = this._virtHeight - containerSize;
        this._bScrollInternal = true;
        this._virtScrollTop += addTop;
        this._virtScrollTop = this._virtScrollTop > 0 ?
            (this._virtScrollTop < maxVirtScrollTop ? this._virtScrollTop : maxVirtScrollTop) :
            0;
        this.vh.instance.elementRef.nativeElement.scrollTop += addTop / this._virtHeightRatio;
        if (Math.abs(addTop / this._virtHeightRatio) < 1) {
            // Actual scroll delta that was added is smaller than 1 and onScroll handler doesn't trigger when scrolling < 1px
            /** @type {?} */
            var scrollOffset = this.fixedUpdateAllElements(this._virtScrollTop);
            // scrollOffset = scrollOffset !== parseInt(this.igxForItemSize, 10) ? scrollOffset : 0;
            this.dc.instance._viewContainer.element.nativeElement.style.top = -(scrollOffset) + 'px';
        }
        /** @type {?} */
        var curScrollTop = this.vh.instance.elementRef.nativeElement.scrollTop;
        /** @type {?} */
        var maxRealScrollTop = this.vh.instance.elementRef.nativeElement.scrollHeight - containerSize;
        if ((this._virtScrollTop > 0 && curScrollTop === 0) ||
            (this._virtScrollTop < maxVirtScrollTop && curScrollTop === maxRealScrollTop)) {
            // Actual scroll position is at the top or bottom, but virtual one is not at the top or bottom (there's more to scroll)
            // Recalculate actual scroll position based on the virtual scroll.
            this.vh.instance.elementRef.nativeElement.scrollTop = this._virtScrollTop / this._virtHeightRatio;
        }
        else if (this._virtScrollTop === 0 && curScrollTop > 0) {
            // Actual scroll position is not at the top, but virtual scroll is. Just update the actual scroll
            this.vh.instance.elementRef.nativeElement.scrollTop = 0;
        }
        else if (this._virtScrollTop === maxVirtScrollTop && curScrollTop < maxRealScrollTop) {
            // Actual scroll position is not at the bottom, but virtual scroll is. Just update the acual scroll
            this.vh.instance.elementRef.nativeElement.scrollTop = maxRealScrollTop;
        }
        return this._virtScrollTop !== originalVirtScrollTop;
    };
    /**
     * Scrolls to the specified index.
     * ```typescript
     * this.parentVirtDir.scrollTo(5);
     * ```
     * @param index
     */
    /**
     * Scrolls to the specified index.
     * ```typescript
     * this.parentVirtDir.scrollTo(5);
     * ```
     * @param {?} index
     * @return {?}
     */
    IgxForOfDirective.prototype.scrollTo = /**
     * Scrolls to the specified index.
     * ```typescript
     * this.parentVirtDir.scrollTo(5);
     * ```
     * @param {?} index
     * @return {?}
     */
    function (index) {
        if (index < 0 || index > (this.isRemote ? this.totalItemCount : this.igxForOf.length) - 1) {
            return;
        }
        /** @type {?} */
        var containerSize = parseInt(this.igxForContainerSize, 10);
        /** @type {?} */
        var scr = this.igxForScrollOrientation === 'horizontal' ?
            this.hScroll.scrollLeft : this.vh.instance.elementRef.nativeElement.scrollTop;
        /** @type {?} */
        var isPrevItem = index < this.state.startIndex || scr > this.sizesCache[index];
        /** @type {?} */
        var nextScroll = isPrevItem ? this.sizesCache[index] : this.sizesCache[index + 1] - containerSize;
        if (nextScroll < 0) {
            return;
        }
        if (this.igxForScrollOrientation === 'horizontal') {
            this.hScroll.scrollLeft = nextScroll;
        }
        else {
            /** @type {?} */
            var maxVirtScrollTop = this._virtHeight - containerSize;
            if (nextScroll > maxVirtScrollTop) {
                nextScroll = maxVirtScrollTop;
            }
            this._bScrollInternal = true;
            this._virtScrollTop = nextScroll;
            this.vh.instance.elementRef.nativeElement.scrollTop = this._virtScrollTop / this._virtHeightRatio;
            this._adjustToIndex = !isPrevItem ? index : null;
        }
    };
    /**
     * Scrolls by one item into the appropriate next direction.
     * For "horizontal" orientation that will be the right column and for "vertical" that is the lower row.
     * ```typescript
     * this.parentVirtDir.scrollNext();
     * ```
     */
    /**
     * Scrolls by one item into the appropriate next direction.
     * For "horizontal" orientation that will be the right column and for "vertical" that is the lower row.
     * ```typescript
     * this.parentVirtDir.scrollNext();
     * ```
     * @return {?}
     */
    IgxForOfDirective.prototype.scrollNext = /**
     * Scrolls by one item into the appropriate next direction.
     * For "horizontal" orientation that will be the right column and for "vertical" that is the lower row.
     * ```typescript
     * this.parentVirtDir.scrollNext();
     * ```
     * @return {?}
     */
    function () {
        /** @type {?} */
        var scr = Math.ceil(this.igxForScrollOrientation === 'horizontal' ?
            this.hScroll.scrollLeft :
            this.vh.instance.elementRef.nativeElement.scrollTop);
        /** @type {?} */
        var endIndex = this.getIndexAt(scr + parseInt(this.igxForContainerSize, 10), this.sizesCache, 0);
        this.scrollTo(endIndex);
    };
    /**
     * Scrolls by one item into the appropriate previous direction.
     * For "horizontal" orientation that will be the left column and for "vertical" that is the upper row.
     * ```typescript
     * this.parentVirtDir.scrollPrev();
     * ```
     */
    /**
     * Scrolls by one item into the appropriate previous direction.
     * For "horizontal" orientation that will be the left column and for "vertical" that is the upper row.
     * ```typescript
     * this.parentVirtDir.scrollPrev();
     * ```
     * @return {?}
     */
    IgxForOfDirective.prototype.scrollPrev = /**
     * Scrolls by one item into the appropriate previous direction.
     * For "horizontal" orientation that will be the left column and for "vertical" that is the upper row.
     * ```typescript
     * this.parentVirtDir.scrollPrev();
     * ```
     * @return {?}
     */
    function () {
        this.scrollTo(this.state.startIndex - 1);
    };
    /**
     * Scrolls by one page into the appropriate next direction.
     * For "horizontal" orientation that will be one view to the right and for "vertical" that is one view to the bottom.
     * ```typescript
     * this.parentVirtDir.scrollNextPage();
     * ```
     */
    /**
     * Scrolls by one page into the appropriate next direction.
     * For "horizontal" orientation that will be one view to the right and for "vertical" that is one view to the bottom.
     * ```typescript
     * this.parentVirtDir.scrollNextPage();
     * ```
     * @return {?}
     */
    IgxForOfDirective.prototype.scrollNextPage = /**
     * Scrolls by one page into the appropriate next direction.
     * For "horizontal" orientation that will be one view to the right and for "vertical" that is one view to the bottom.
     * ```typescript
     * this.parentVirtDir.scrollNextPage();
     * ```
     * @return {?}
     */
    function () {
        if (this.igxForScrollOrientation === 'horizontal') {
            this.hvh.instance.elementRef.nativeElement.scrollLeft += parseInt(this.igxForContainerSize, 10);
        }
        else {
            this.addScrollTop(parseInt(this.igxForContainerSize, 10));
        }
    };
    /**
     * Scrolls by one page into the appropriate previous direction.
     * For "horizontal" orientation that will be one view to the left and for "vertical" that is one view to the top.
     * ```typescript
     * this.parentVirtDir.scrollPrevPage();
     * ```
     */
    /**
     * Scrolls by one page into the appropriate previous direction.
     * For "horizontal" orientation that will be one view to the left and for "vertical" that is one view to the top.
     * ```typescript
     * this.parentVirtDir.scrollPrevPage();
     * ```
     * @return {?}
     */
    IgxForOfDirective.prototype.scrollPrevPage = /**
     * Scrolls by one page into the appropriate previous direction.
     * For "horizontal" orientation that will be one view to the left and for "vertical" that is one view to the top.
     * ```typescript
     * this.parentVirtDir.scrollPrevPage();
     * ```
     * @return {?}
     */
    function () {
        if (this.igxForScrollOrientation === 'horizontal') {
            this.hvh.instance.elementRef.nativeElement.scrollLeft -= parseInt(this.igxForContainerSize, 10);
        }
        else {
            /** @type {?} */
            var containerSize = (parseInt(this.igxForContainerSize, 10));
            this.addScrollTop(-containerSize);
        }
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @param {?} colIndex
     * @return {?}
     */
    IgxForOfDirective.prototype.getColumnScrollLeft = /**
     * @hidden
     * @param {?} colIndex
     * @return {?}
     */
    function (colIndex) {
        return this.sizesCache[colIndex];
    };
    /**
     * Returns a reference to the vertical scrollbar DOM element.
     * ```typescript
     * this.parentVirtDir.getVerticalScroll();
     * ```
     */
    /**
     * Returns a reference to the vertical scrollbar DOM element.
     * ```typescript
     * this.parentVirtDir.getVerticalScroll();
     * ```
     * @return {?}
     */
    IgxForOfDirective.prototype.getVerticalScroll = /**
     * Returns a reference to the vertical scrollbar DOM element.
     * ```typescript
     * this.parentVirtDir.getVerticalScroll();
     * ```
     * @return {?}
     */
    function () {
        if (this.vh) {
            return this.vh.instance.elementRef.nativeElement;
        }
        return null;
    };
    /**
     * Returns the total number of items that are fully visible.
     * ```typescript
     * this.parentVirtDir.getItemCountInView();
     * ```
     */
    /**
     * Returns the total number of items that are fully visible.
     * ```typescript
     * this.parentVirtDir.getItemCountInView();
     * ```
     * @return {?}
     */
    IgxForOfDirective.prototype.getItemCountInView = /**
     * Returns the total number of items that are fully visible.
     * ```typescript
     * this.parentVirtDir.getItemCountInView();
     * ```
     * @return {?}
     */
    function () {
        /** @type {?} */
        var position = this.igxForScrollOrientation === 'horizontal' ?
            this.hScroll.scrollLeft :
            this.vh.instance.elementRef.nativeElement.scrollTop;
        /** @type {?} */
        var startIndex = this.getIndexAt(position, this.sizesCache, 0);
        if (position - this.sizesCache[startIndex] > 0) {
            // fisrt item is not fully in view
            startIndex++;
        }
        /** @type {?} */
        var endIndex = this.getIndexAt(position + parseInt(this.igxForContainerSize, 10), this.sizesCache, 0);
        return endIndex - startIndex;
    };
    /**
     * Returns a reference to the horizontal scrollbar DOM element.
     * ```typescript
     * this.parentVirtDir.getHorizontalScroll();
     * ```
     */
    /**
     * Returns a reference to the horizontal scrollbar DOM element.
     * ```typescript
     * this.parentVirtDir.getHorizontalScroll();
     * ```
     * @return {?}
     */
    IgxForOfDirective.prototype.getHorizontalScroll = /**
     * Returns a reference to the horizontal scrollbar DOM element.
     * ```typescript
     * this.parentVirtDir.getHorizontalScroll();
     * ```
     * @return {?}
     */
    function () {
        return this.getElement(this._viewContainer, 'igx-horizontal-virtual-helper') || this.hScroll;
    };
    /**
     * Returns the size of the element at the specified index.
     * ```typescript
     * this.parentVirtDir.getSizeAt(1);
     * ```
     */
    /**
     * Returns the size of the element at the specified index.
     * ```typescript
     * this.parentVirtDir.getSizeAt(1);
     * ```
     * @param {?} index
     * @return {?}
     */
    IgxForOfDirective.prototype.getSizeAt = /**
     * Returns the size of the element at the specified index.
     * ```typescript
     * this.parentVirtDir.getSizeAt(1);
     * ```
     * @param {?} index
     * @return {?}
     */
    function (index) {
        return this.sizesCache[index + 1] - this.sizesCache[index];
    };
    /**
     * Returns the scroll offset of the element at the specified index.
     * ```typescript
     * this.parentVirtDir.getScrollForIndex(1);
     * ```
     */
    /**
     * Returns the scroll offset of the element at the specified index.
     * ```typescript
     * this.parentVirtDir.getScrollForIndex(1);
     * ```
     * @param {?} index
     * @param {?=} bottom
     * @return {?}
     */
    IgxForOfDirective.prototype.getScrollForIndex = /**
     * Returns the scroll offset of the element at the specified index.
     * ```typescript
     * this.parentVirtDir.getScrollForIndex(1);
     * ```
     * @param {?} index
     * @param {?=} bottom
     * @return {?}
     */
    function (index, bottom) {
        /** @type {?} */
        var containerSize = parseInt(this.igxForContainerSize, 10);
        /** @type {?} */
        var scroll = bottom ? Math.max(0, this.sizesCache[index + 1] - containerSize) : this.sizesCache[index];
        return scroll;
    };
    /**
     * @hidden
     * Function that is called when scrolling vertically
     */
    /**
     * @hidden
     * Function that is called when scrolling vertically
     * @protected
     * @param {?} event
     * @return {?}
     */
    IgxForOfDirective.prototype.onScroll = /**
     * @hidden
     * Function that is called when scrolling vertically
     * @protected
     * @param {?} event
     * @return {?}
     */
    function (event) {
        var _this = this;
        /* in certain situations this may be called when no scrollbar is visible */
        if (!parseInt(this.vh.instance.elementRef.nativeElement.style.height, 10)) {
            return;
        }
        /** @type {?} */
        var containerSize = parseInt(this.igxForContainerSize, 10);
        /** @type {?} */
        var maxRealScrollTop = event.target.children[0].scrollHeight - containerSize;
        /** @type {?} */
        var realPercentScrolled = event.target.scrollTop / maxRealScrollTop;
        if (!this._bScrollInternal) {
            /** @type {?} */
            var maxVirtScrollTop = this._virtHeight - containerSize;
            this._virtScrollTop = realPercentScrolled * maxVirtScrollTop;
        }
        else {
            this._bScrollInternal = false;
        }
        /** @type {?} */
        var prevStartIndex = this.state.startIndex;
        /** @type {?} */
        var scrollOffset = this.fixedUpdateAllElements(this._virtScrollTop);
        this.dc.instance._viewContainer.element.nativeElement.style.top = -(scrollOffset) + 'px';
        requestAnimationFrame(function () {
            // check if height/width has changes in views.
            _this.recalcUpdateSizes();
        });
        this.dc.changeDetectorRef.detectChanges();
        if (prevStartIndex !== this.state.startIndex) {
            this.onChunkLoad.emit(this.state);
        }
    };
    /**
     * @hidden
     * Function that recaculates and updates cache sizes.
     */
    /**
     * @hidden
     * Function that recaculates and updates cache sizes.
     * @return {?}
     */
    IgxForOfDirective.prototype.recalcUpdateSizes = /**
     * @hidden
     * Function that recaculates and updates cache sizes.
     * @return {?}
     */
    function () {
        /** @type {?} */
        var dimension = this.igxForScrollOrientation === 'horizontal' ?
            this.igxForSizePropName : 'height';
        /** @type {?} */
        var diffs = [];
        /** @type {?} */
        var totalDiff = 0;
        for (var i = 0; i < this._embeddedViews.length; i++) {
            /** @type {?} */
            var view = this._embeddedViews[i];
            /** @type {?} */
            var rNode = view.rootNodes.find(function (node) { return node.nodeType === Node.ELEMENT_NODE; });
            if (rNode) {
                /** @type {?} */
                var h = rNode.offsetHeight ? rNode.offsetHeight : parseInt(this.igxForItemSize, 10);
                /** @type {?} */
                var index = this.state.startIndex + i;
                if (!this.isRemote && !this.igxForOf[index]) {
                    continue;
                }
                /** @type {?} */
                var oldVal = dimension === 'height' ? this.heightCache[index] : this.igxForOf[index][dimension];
                /** @type {?} */
                var newVal = dimension === 'height' ? h : rNode.clientWidth;
                if (dimension === 'height') {
                    this.heightCache[index] = newVal;
                }
                else {
                    this.igxForOf[index][dimension] = newVal;
                }
                /** @type {?} */
                var currDiff = newVal - oldVal;
                diffs.push(currDiff);
                totalDiff += currDiff;
                this.sizesCache[index + 1] += totalDiff;
            }
        }
        // update cache
        if (Math.abs(totalDiff) > 0) {
            for (var j = this.state.startIndex + this.state.chunkSize + 1; j < this.sizesCache.length; j++) {
                this.sizesCache[j] += totalDiff;
            }
            // update scrBar heights/widths
            if (this.igxForScrollOrientation === 'horizontal') {
                /** @type {?} */
                var totalWidth = parseInt(this.hScroll.children[0].style.width, 10) + totalDiff;
                this.hScroll.children[0].style.width = totalWidth + 'px';
            }
            /** @type {?} */
            var reducer = function (acc, val) { return acc + val; };
            if (this.igxForScrollOrientation === 'vertical') {
                /** @type {?} */
                var scrToBottom = this._isScrolledToBottom && !this.dc.instance.notVirtual;
                /** @type {?} */
                var hSum = this.heightCache.reduce(reducer);
                if (hSum > this._maxHeight) {
                    this._virtHeightRatio = hSum / this._maxHeight;
                }
                this.vh.instance.height = Math.min(this.vh.instance.height + totalDiff, this._maxHeight);
                this._virtHeight = hSum;
                if (!this.vh.instance.destroyed) {
                    this.vh.instance.cdr.detectChanges();
                }
                if (scrToBottom && !this._isAtBottomIndex) {
                    /** @type {?} */
                    var containerSize = parseInt(this.igxForContainerSize, 10);
                    /** @type {?} */
                    var scrollOffset = this.fixedUpdateAllElements(this._virtHeight - containerSize);
                    this.dc.instance._viewContainer.element.nativeElement.style.top = -(scrollOffset) + 'px';
                    return;
                }
                if (this._adjustToIndex) {
                    // in case scrolled to specific index where after scroll heights are changed
                    // need to adjust the offsets so that item is last in view.
                    /** @type {?} */
                    var updatesToIndex = this._adjustToIndex - this.state.startIndex + 1;
                    /** @type {?} */
                    var sumDiffs = diffs.slice(0, updatesToIndex).reduce(reducer);
                    /** @type {?} */
                    var currOffset = parseInt(this.dc.instance._viewContainer.element.nativeElement.style.top, 10);
                    this.dc.instance._viewContainer.element.nativeElement.style.top = (currOffset - sumDiffs) + 'px';
                    this._adjustToIndex = null;
                }
            }
        }
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @protected
     * @param {?} inScrollTop
     * @return {?}
     */
    IgxForOfDirective.prototype.fixedUpdateAllElements = /**
     * @hidden
     * @protected
     * @param {?} inScrollTop
     * @return {?}
     */
    function (inScrollTop) {
        /** @type {?} */
        var count = this.isRemote ? this.totalItemCount : this.igxForOf.length;
        /** @type {?} */
        var newStart = this.getIndexAt(inScrollTop, this.sizesCache, 0);
        if (newStart + this.state.chunkSize > count) {
            newStart = count - this.state.chunkSize;
        }
        /** @type {?} */
        var prevStart = this.state.startIndex;
        /** @type {?} */
        var diff = newStart - this.state.startIndex;
        this.state.startIndex = newStart;
        if (diff) {
            this.onChunkPreload.emit(this.state);
            if (!this.isRemote) {
                /*recalculate and apply page size.*/
                if (diff > 0 && diff <= this.MAX_PERF_SCROLL_DIFF) {
                    this.moveApplyScrollNext(prevStart);
                }
                else if (diff < 0 && Math.abs(diff) <= this.MAX_PERF_SCROLL_DIFF) {
                    this.moveApplyScrollPrev(prevStart);
                }
                else {
                    this.fixedApplyScroll();
                }
            }
        }
        return inScrollTop - this.sizesCache[this.state.startIndex];
    };
    /**
     * @hidden
     * The function applies an optimized state change for scrolling down/right employing context change with view rearrangement
     */
    /**
     * @hidden
     * The function applies an optimized state change for scrolling down/right employing context change with view rearrangement
     * @protected
     * @param {?} prevIndex
     * @return {?}
     */
    IgxForOfDirective.prototype.moveApplyScrollNext = /**
     * @hidden
     * The function applies an optimized state change for scrolling down/right employing context change with view rearrangement
     * @protected
     * @param {?} prevIndex
     * @return {?}
     */
    function (prevIndex) {
        /** @type {?} */
        var start = prevIndex + this.state.chunkSize;
        for (var i = start; i < start + this.state.startIndex - prevIndex && this.igxForOf[i] !== undefined; i++) {
            /** @type {?} */
            var input = this.igxForOf[i];
            /** @type {?} */
            var embView = this._embeddedViews.shift();
            /** @type {?} */
            var cntx = embView.context;
            cntx.$implicit = input;
            cntx.index = this.getContextIndex(input);
            /** @type {?} */
            var view = this.dc.instance._vcr.detach(0);
            this.dc.instance._vcr.insert(view);
            this._embeddedViews.push(embView);
        }
    };
    /**
     * @hidden
     * The function applies an optimized state change for scrolling up/left employing context change with view rearrangement
     */
    /**
     * @hidden
     * The function applies an optimized state change for scrolling up/left employing context change with view rearrangement
     * @protected
     * @param {?} prevIndex
     * @return {?}
     */
    IgxForOfDirective.prototype.moveApplyScrollPrev = /**
     * @hidden
     * The function applies an optimized state change for scrolling up/left employing context change with view rearrangement
     * @protected
     * @param {?} prevIndex
     * @return {?}
     */
    function (prevIndex) {
        for (var i = prevIndex - 1; i >= this.state.startIndex && this.igxForOf[i] !== undefined; i--) {
            /** @type {?} */
            var input = this.igxForOf[i];
            /** @type {?} */
            var embView = this._embeddedViews.pop();
            /** @type {?} */
            var cntx = embView.context;
            cntx.$implicit = input;
            cntx.index = this.getContextIndex(input);
            /** @type {?} */
            var view = this.dc.instance._vcr.detach(this.dc.instance._vcr.length - 1);
            this.dc.instance._vcr.insert(view, 0);
            this._embeddedViews.unshift(embView);
        }
    };
    /**
     * @hidden
    */
    /**
     * @hidden
     * @protected
     * @param {?} input
     * @return {?}
     */
    IgxForOfDirective.prototype.getContextIndex = /**
     * @hidden
     * @protected
     * @param {?} input
     * @return {?}
     */
    function (input) {
        return this.isRemote ? this.state.startIndex + this.igxForOf.indexOf(input) : this.igxForOf.indexOf(input);
    };
    /**
     * @hidden
     * The function applies an optimized state change through context change for each view
     */
    /**
     * @hidden
     * The function applies an optimized state change through context change for each view
     * @protected
     * @return {?}
     */
    IgxForOfDirective.prototype.fixedApplyScroll = /**
     * @hidden
     * The function applies an optimized state change through context change for each view
     * @protected
     * @return {?}
     */
    function () {
        /** @type {?} */
        var j = 0;
        /** @type {?} */
        var endIndex = this.state.startIndex + this.state.chunkSize;
        for (var i = this.state.startIndex; i < endIndex && this.igxForOf[i] !== undefined; i++) {
            /** @type {?} */
            var input = this.igxForOf[i];
            /** @type {?} */
            var embView = this._embeddedViews[j++];
            /** @type {?} */
            var cntx = ((/** @type {?} */ (embView))).context;
            cntx.$implicit = input;
            cntx.index = this.getContextIndex(input);
        }
    };
    /**
     * @hidden
     * Function that is called when scrolling horizontally
     */
    /**
     * @hidden
     * Function that is called when scrolling horizontally
     * @protected
     * @param {?} event
     * @return {?}
     */
    IgxForOfDirective.prototype.onHScroll = /**
     * @hidden
     * Function that is called when scrolling horizontally
     * @protected
     * @param {?} event
     * @return {?}
     */
    function (event) {
        /* in certain situations this may be called when no scrollbar is visible */
        if (!parseInt(this.hScroll.children[0].style.width, 10)) {
            return;
        }
        /** @type {?} */
        var curScrollLeft = event.target.scrollLeft;
        /** @type {?} */
        var prevStartIndex = this.state.startIndex;
        // Updating horizontal chunks
        /** @type {?} */
        var scrollOffset = this.fixedUpdateAllElements(curScrollLeft);
        this.dc.instance._viewContainer.element.nativeElement.style.left = -scrollOffset + 'px';
        this.dc.changeDetectorRef.detectChanges();
        if (prevStartIndex !== this.state.startIndex) {
            this.onChunkLoad.emit(this.state);
        }
    };
    Object.defineProperty(IgxForOfDirective.prototype, "igxForTrackBy", {
        /**
         * Gets the function used to track changes in the items collection.
         * By default the object references are compared. However this can be optimized if you have unique identifier
         * value that can be used for the comparison instead of the object ref or if you have some other property values
         * in the item object that should be tracked for changes.
         * This option is similar to ngForTrackBy.
         * ```typescript
         * const trackFunc = this.parentVirtDir.igxForTrackBy;
         * ```
         */
        get: /**
         * Gets the function used to track changes in the items collection.
         * By default the object references are compared. However this can be optimized if you have unique identifier
         * value that can be used for the comparison instead of the object ref or if you have some other property values
         * in the item object that should be tracked for changes.
         * This option is similar to ngForTrackBy.
         * ```typescript
         * const trackFunc = this.parentVirtDir.igxForTrackBy;
         * ```
         * @return {?}
         */
        function () { return this._trackByFn; },
        /**
         * Sets the function used to track changes in the items collection.
         * This function can be set in scenarios where you want to optimize or
         * customize the tracking of changes for the items in the collection.
         * The igxForTrackBy function takes the index and the current item as arguments and needs to return the unique identifier for this item.
         * ```typescript
         * this.parentVirtDir.igxForTrackBy = (index, item) => {
         *      return item.id + item.width;
         * };
         * ```
         */
        set: /**
         * Sets the function used to track changes in the items collection.
         * This function can be set in scenarios where you want to optimize or
         * customize the tracking of changes for the items in the collection.
         * The igxForTrackBy function takes the index and the current item as arguments and needs to return the unique identifier for this item.
         * ```typescript
         * this.parentVirtDir.igxForTrackBy = (index, item) => {
         *      return item.id + item.width;
         * };
         * ```
         * @param {?} fn
         * @return {?}
         */
        function (fn) { this._trackByFn = fn; },
        enumerable: true,
        configurable: true
    });
    /**
     * @hidden
     */
    /**
     * @hidden
     * @protected
     * @return {?}
     */
    IgxForOfDirective.prototype._applyChanges = /**
     * @hidden
     * @protected
     * @return {?}
     */
    function () {
        /** @type {?} */
        var prevChunkSize = this.state.chunkSize;
        this.applyChunkSizeChange();
        this._recalcScrollBarSize();
        if (this.igxForOf && this.igxForOf.length && this.dc) {
            /** @type {?} */
            var embeddedViewCopy = Object.assign([], this._embeddedViews);
            /** @type {?} */
            var startIndex = this.state.startIndex;
            /** @type {?} */
            var endIndex = this.state.chunkSize + this.state.startIndex;
            if (this.isRemote) {
                startIndex = 0;
                endIndex = this.igxForOf.length;
            }
            for (var i = startIndex; i < endIndex && this.igxForOf[i] !== undefined; i++) {
                /** @type {?} */
                var input = this.igxForOf[i];
                /** @type {?} */
                var embView = embeddedViewCopy.shift();
                /** @type {?} */
                var cntx = ((/** @type {?} */ (embView))).context;
                cntx.$implicit = input;
                cntx.index = this.getContextIndex(input);
            }
            this.dc.changeDetectorRef.detectChanges();
            if (prevChunkSize !== this.state.chunkSize) {
                this.onChunkLoad.emit(this.state);
            }
            if (this.igxForScrollOrientation === 'vertical') {
                this.recalcUpdateSizes();
            }
        }
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @protected
     * @return {?}
     */
    IgxForOfDirective.prototype._calcMaxBrowserHeight = /**
     * @hidden
     * @protected
     * @return {?}
     */
    function () {
        /** @type {?} */
        var div = document.createElement('div');
        /** @type {?} */
        var style = div.style;
        style.position = 'absolute';
        style.top = '9999999999999999px';
        document.body.appendChild(div);
        /** @type {?} */
        var size = Math.abs(div.getBoundingClientRect()['top']);
        document.body.removeChild(div);
        return size;
    };
    /**
     * @hidden
     * Recalculates the chunkSize based on current startIndex and returns the new size.
     * This should be called after this.state.startIndex is updated, not before.
     */
    /**
     * @hidden
     * Recalculates the chunkSize based on current startIndex and returns the new size.
     * This should be called after this.state.startIndex is updated, not before.
     * @protected
     * @return {?}
     */
    IgxForOfDirective.prototype._calculateChunkSize = /**
     * @hidden
     * Recalculates the chunkSize based on current startIndex and returns the new size.
     * This should be called after this.state.startIndex is updated, not before.
     * @protected
     * @return {?}
     */
    function () {
        /** @type {?} */
        var chunkSize = 0;
        if (this.igxForContainerSize !== null && this.igxForContainerSize !== undefined) {
            if (!this.sizesCache) {
                this.initSizesCache(this.igxForOf);
            }
            chunkSize = this._calcMaxChunkSize();
            if (this.igxForOf && chunkSize > this.igxForOf.length) {
                chunkSize = this.igxForOf.length;
            }
        }
        else {
            if (this.igxForOf) {
                chunkSize = this.igxForOf.length;
            }
        }
        return chunkSize;
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @protected
     * @param {?} viewref
     * @param {?} nodeName
     * @return {?}
     */
    IgxForOfDirective.prototype.getElement = /**
     * @hidden
     * @protected
     * @param {?} viewref
     * @param {?} nodeName
     * @return {?}
     */
    function (viewref, nodeName) {
        /** @type {?} */
        var elem = viewref.element.nativeElement.parentNode.getElementsByTagName(nodeName);
        return elem.length > 0 ? elem[0] : null;
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @protected
     * @param {?} items
     * @return {?}
     */
    IgxForOfDirective.prototype.initSizesCache = /**
     * @hidden
     * @protected
     * @param {?} items
     * @return {?}
     */
    function (items) {
        /** @type {?} */
        var totalSize = 0;
        /** @type {?} */
        var size = 0;
        /** @type {?} */
        var dimension = this.igxForScrollOrientation === 'horizontal' ?
            this.igxForSizePropName : 'height';
        /** @type {?} */
        var i = 0;
        this.sizesCache = [];
        this.heightCache = [];
        this.sizesCache.push(0);
        /** @type {?} */
        var count = this.isRemote ? this.totalItemCount : items.length;
        for (i; i < count; i++) {
            if (dimension === 'height') {
                // cols[i][dimension] = parseInt(this.igxForItemSize, 10) || 0;
                size = parseInt(this.igxForItemSize, 10) || 0;
                this.heightCache.push(size);
            }
            else {
                size = this._getItemSize(items[i], dimension);
            }
            totalSize += size;
            this.sizesCache.push(totalSize);
        }
        return totalSize;
    };
    /**
     * @protected
     * @return {?}
     */
    IgxForOfDirective.prototype._updateSizeCache = /**
     * @protected
     * @return {?}
     */
    function () {
        if (this.igxForScrollOrientation === 'horizontal') {
            this.initSizesCache(this.igxForOf);
            return;
        }
        /** @type {?} */
        var scr = this.vh.instance.elementRef.nativeElement;
        /** @type {?} */
        var oldHeight = this.heightCache.length > 0 ? this.heightCache.reduce(function (acc, val) { return acc + val; }) : 0;
        /** @type {?} */
        var newHeight = this.initSizesCache(this.igxForOf);
        /** @type {?} */
        var diff = oldHeight - newHeight;
        // if data has been changed while container is scrolled
        // should update scroll top/left according to change so that same startIndex is in view
        if (Math.abs(diff) > 0 && scr.scrollTop > 0) {
            this.recalcUpdateSizes();
            /** @type {?} */
            var offset = parseInt(this.dc.instance._viewContainer.element.nativeElement.style.top, 10);
            scr.scrollTop = this.sizesCache[this.state.startIndex] - offset;
        }
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @protected
     * @return {?}
     */
    IgxForOfDirective.prototype._calcMaxChunkSize = /**
     * @hidden
     * @protected
     * @return {?}
     */
    function () {
        var _this = this;
        /** @type {?} */
        var i = 0;
        /** @type {?} */
        var length = 0;
        /** @type {?} */
        var maxLength = 0;
        /** @type {?} */
        var arr = [];
        /** @type {?} */
        var sum = 0;
        /** @type {?} */
        var availableSize = parseInt(this.igxForContainerSize, 10);
        if (!availableSize) {
            return 0;
        }
        /** @type {?} */
        var dimension = this.igxForScrollOrientation === 'horizontal' ?
            this.igxForSizePropName : 'height';
        /** @type {?} */
        var reducer = function (accumulator, currentItem) { return accumulator + _this._getItemSize(currentItem, dimension); };
        for (i; i < this.igxForOf.length; i++) {
            /** @type {?} */
            var item = this.igxForOf[i];
            if (dimension === 'height') {
                item = { value: this.igxForOf[i], height: this.heightCache[i] };
            }
            /** @type {?} */
            var size = dimension === 'height' ?
                this.heightCache[i] :
                this._getItemSize(item, dimension);
            sum = arr.reduce(reducer, size);
            if (sum < availableSize) {
                arr.push(item);
                length = arr.length;
                if (i === this.igxForOf.length - 1) {
                    // reached end without exceeding
                    // include prev items until size is filled or first item is reached.
                    /** @type {?} */
                    var curItem = dimension === 'height' ? arr[0].value : arr[0];
                    /** @type {?} */
                    var prevIndex = this.igxForOf.indexOf(curItem) - 1;
                    while (prevIndex >= 0 && sum <= availableSize) {
                        curItem = dimension === 'height' ? arr[0].value : arr[0];
                        prevIndex = this.igxForOf.indexOf(curItem) - 1;
                        /** @type {?} */
                        var prevItem = this.igxForOf[prevIndex];
                        /** @type {?} */
                        var prevSize = dimension === 'height' ?
                            this.heightCache[prevIndex] :
                            parseInt(prevItem[dimension], 10);
                        sum = arr.reduce(reducer, prevSize);
                        arr.unshift(prevItem);
                        length = arr.length;
                    }
                }
            }
            else {
                arr.push(item);
                length = arr.length + 1;
                arr.shift();
            }
            if (length > maxLength) {
                maxLength = length;
            }
        }
        return maxLength;
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @protected
     * @param {?} left
     * @param {?} set
     * @param {?} index
     * @return {?}
     */
    IgxForOfDirective.prototype.getIndexAt = /**
     * @hidden
     * @protected
     * @param {?} left
     * @param {?} set
     * @param {?} index
     * @return {?}
     */
    function (left, set, index) {
        /** @type {?} */
        var start = 0;
        /** @type {?} */
        var end = set.length - 1;
        if (left === 0) {
            return 0;
        }
        while (start <= end) {
            /** @type {?} */
            var midIdx = Math.floor((start + end) / 2);
            /** @type {?} */
            var midLeft = set[midIdx];
            /** @type {?} */
            var cmp = left - midLeft;
            if (cmp > 0) {
                start = midIdx + 1;
            }
            else if (cmp < 0) {
                end = midIdx - 1;
            }
            else {
                return midIdx;
            }
        }
        return end;
    };
    /**
     * @protected
     * @return {?}
     */
    IgxForOfDirective.prototype._recalcScrollBarSize = /**
     * @protected
     * @return {?}
     */
    function () {
        /** @type {?} */
        var count = this.isRemote ? this.totalItemCount : (this.igxForOf ? this.igxForOf.length : 0);
        this.dc.instance.notVirtual = !(this.igxForContainerSize && this.dc && this.state.chunkSize < count);
        if (this.igxForScrollOrientation === 'horizontal') {
            /** @type {?} */
            var totalWidth = this.igxForContainerSize ? this.initSizesCache(this.igxForOf) : 0;
            this.hScroll.style.width = this.igxForContainerSize + 'px';
            this.hScroll.children[0].style.width = totalWidth + 'px';
        }
        if (this.igxForScrollOrientation === 'vertical') {
            this.vh.instance.elementRef.nativeElement.style.height = parseInt(this.igxForContainerSize, 10) + 'px';
            this.vh.instance.height = this._calcHeight();
        }
    };
    /**
     * @protected
     * @return {?}
     */
    IgxForOfDirective.prototype._calcHeight = /**
     * @protected
     * @return {?}
     */
    function () {
        /** @type {?} */
        var height;
        if (this.heightCache) {
            height = this.heightCache.reduce(function (acc, val) { return acc + val; }, 0);
        }
        else {
            height = this.initSizesCache(this.igxForOf);
        }
        this._virtHeight = height;
        if (height > this._maxHeight) {
            this._virtHeightRatio = height / this._maxHeight;
            height = this._maxHeight;
        }
        return height;
    };
    /**
     * @protected
     * @param {?} changes
     * @return {?}
     */
    IgxForOfDirective.prototype._recalcOnContainerChange = /**
     * @protected
     * @param {?} changes
     * @return {?}
     */
    function (changes) {
        this.dc.instance._viewContainer.element.nativeElement.style.top = '0px';
        this.dc.instance._viewContainer.element.nativeElement.style.left = '0px';
        /** @type {?} */
        var prevChunkSize = this.state.chunkSize;
        this.applyChunkSizeChange();
        this._recalcScrollBarSize();
        if (prevChunkSize !== this.state.chunkSize) {
            this.onChunkLoad.emit(this.state);
        }
        if (this.sizesCache && this.hScroll && this.hScroll.scrollLeft !== 0) {
            // Updating horizontal chunks and offsets based on the new scrollLeft
            /** @type {?} */
            var scrollOffset = this.fixedUpdateAllElements(this.hScroll.scrollLeft);
            this.dc.instance._viewContainer.element.nativeElement.style.left = -scrollOffset + 'px';
        }
    };
    /**
     * @hidden
     * Removes an elemenet from the embedded views and updates chunkSize.
     */
    /**
     * @hidden
     * Removes an elemenet from the embedded views and updates chunkSize.
     * @protected
     * @return {?}
     */
    IgxForOfDirective.prototype.removeLastElem = /**
     * @hidden
     * Removes an elemenet from the embedded views and updates chunkSize.
     * @protected
     * @return {?}
     */
    function () {
        /** @type {?} */
        var oldElem = this._embeddedViews.pop();
        this.onBeforeViewDestroyed.emit(oldElem);
        oldElem.destroy();
        this.state.chunkSize--;
    };
    /**
     * @hidden
     * If there exists an element that we can create embedded view for creates it, appends it and updates chunkSize
     */
    /**
     * @hidden
     * If there exists an element that we can create embedded view for creates it, appends it and updates chunkSize
     * @protected
     * @return {?}
     */
    IgxForOfDirective.prototype.addLastElem = /**
     * @hidden
     * If there exists an element that we can create embedded view for creates it, appends it and updates chunkSize
     * @protected
     * @return {?}
     */
    function () {
        var _this = this;
        /** @type {?} */
        var elemIndex = this.state.startIndex + this.state.chunkSize;
        if (!this.isRemote && !this.igxForOf) {
            return;
        }
        if (elemIndex >= this.igxForOf.length) {
            elemIndex = this.igxForOf.length - this.state.chunkSize;
        }
        /** @type {?} */
        var input = this.igxForOf[elemIndex];
        /** @type {?} */
        var embeddedView = this.dc.instance._vcr.createEmbeddedView(this._template, { $implicit: input, index: elemIndex });
        this._embeddedViews.push(embeddedView);
        this.state.chunkSize++;
        this._zone.run(function () {
            _this.cdr.markForCheck();
        });
    };
    /**
     * Recalculates chunkSize and adds/removes elements if need due to the change.
     * this.state.chunkSize is updated in @addLastElem() or @removeLastElem()
     */
    /**
     * Recalculates chunkSize and adds/removes elements if need due to the change.
     * this.state.chunkSize is updated in \@addLastElem() or \@removeLastElem()
     * @protected
     * @return {?}
     */
    IgxForOfDirective.prototype.applyChunkSizeChange = /**
     * Recalculates chunkSize and adds/removes elements if need due to the change.
     * this.state.chunkSize is updated in \@addLastElem() or \@removeLastElem()
     * @protected
     * @return {?}
     */
    function () {
        /** @type {?} */
        var chunkSize = this.isRemote ? (this.igxForOf ? this.igxForOf.length : 0) : this._calculateChunkSize();
        if (chunkSize > this.state.chunkSize) {
            /** @type {?} */
            var diff = chunkSize - this.state.chunkSize;
            for (var i = 0; i < diff; i++) {
                this.addLastElem();
            }
        }
        else if (chunkSize < this.state.chunkSize) {
            /** @type {?} */
            var diff = this.state.chunkSize - chunkSize;
            for (var i = 0; i < diff; i++) {
                this.removeLastElem();
            }
        }
    };
    /**
     * @protected
     * @return {?}
     */
    IgxForOfDirective.prototype._updateScrollOffset = /**
     * @protected
     * @return {?}
     */
    function () {
        if (this.igxForScrollOrientation === 'horizontal') {
            this._updateHScrollOffset();
        }
        else {
            this._updateVScrollOffset();
        }
    };
    /**
     * @private
     * @return {?}
     */
    IgxForOfDirective.prototype._updateVScrollOffset = /**
     * @private
     * @return {?}
     */
    function () {
        /** @type {?} */
        var scrollOffset = 0;
        /** @type {?} */
        var vScroll = this.vh.instance.elementRef.nativeElement;
        scrollOffset = vScroll && parseInt(vScroll.style.height, 10) ?
            vScroll.scrollTop - this.sizesCache[this.state.startIndex] : 0;
        this.dc.instance._viewContainer.element.nativeElement.style.top = -(scrollOffset) + 'px';
    };
    /**
     * @private
     * @return {?}
     */
    IgxForOfDirective.prototype._updateHScrollOffset = /**
     * @private
     * @return {?}
     */
    function () {
        /** @type {?} */
        var scrollOffset = 0;
        scrollOffset = this.hScroll && parseInt(this.hScroll.children[0].style.width, 10) ?
            this.hScroll.scrollLeft - this.sizesCache[this.state.startIndex] : 0;
        this.dc.instance._viewContainer.element.nativeElement.style.left = -scrollOffset + 'px';
    };
    /**
     * @private
     * @param {?} item
     * @param {?} dimension
     * @return {?}
     */
    IgxForOfDirective.prototype._getItemSize = /**
     * @private
     * @param {?} item
     * @param {?} dimension
     * @return {?}
     */
    function (item, dimension) {
        /** @type {?} */
        var dim = item[dimension];
        return typeof dim === 'number' ? dim : this.igxForItemSize;
    };
    IgxForOfDirective.decorators = [
        { type: Directive, args: [{ selector: '[igxFor][igxForOf]' },] }
    ];
    /** @nocollapse */
    IgxForOfDirective.ctorParameters = function () { return [
        { type: ViewContainerRef },
        { type: TemplateRef },
        { type: IterableDiffers },
        { type: ComponentFactoryResolver },
        { type: ChangeDetectorRef },
        { type: NgZone }
    ]; };
    IgxForOfDirective.propDecorators = {
        igxForOf: [{ type: Input }],
        igxForSizePropName: [{ type: Input }],
        igxForScrollOrientation: [{ type: Input }],
        igxForScrollContainer: [{ type: Input }],
        igxForContainerSize: [{ type: Input }],
        igxForItemSize: [{ type: Input }],
        onChunkLoad: [{ type: Output }],
        onDataChanged: [{ type: Output }],
        onBeforeViewDestroyed: [{ type: Output }],
        onChunkPreload: [{ type: Output }],
        igxForTrackBy: [{ type: Input }]
    };
    return IgxForOfDirective;
}());
export { IgxForOfDirective };
if (false) {
    /**
     * An \@Input property that sets the data to be rendered.
     * ```html
     * <ng-template igxFor let-item [igxForOf]="data" [igxForScrollOrientation]="'horizontal'"></ng-template>
     * ```
     * @type {?}
     */
    IgxForOfDirective.prototype.igxForOf;
    /**
     * An \@Input property that sets the property name from which to read the size in the data object.
     * @type {?}
     */
    IgxForOfDirective.prototype.igxForSizePropName;
    /**
     * An \@Input property that specifies the scroll orientation.
     * Scroll orientation can be "vertical" or "horizontal".
     * ```html
     * <ng-template igxFor let-item [igxForOf]="data" [igxForScrollOrientation]="'horizontal'"></ng-template>
     * ```
     * @type {?}
     */
    IgxForOfDirective.prototype.igxForScrollOrientation;
    /**
     * Optionally pass the parent `igxFor` instance to create a virtual template scrolling both horizontally and vertically.
     * ```html
     * <ng-template #scrollContainer igxFor let-rowData [igxForOf]="data"
     *       [igxForScrollOrientation]="'vertical'"
     *       [igxForContainerSize]="'500px'"
     *       [igxForItemSize]="'50px'"
     *       let-rowIndex="index">
     *       <div [style.display]="'flex'" [style.height]="'50px'">
     *           <ng-template #childContainer igxFor let-item [igxForOf]="data"
     *               [igxForScrollOrientation]="'horizontal'"
     *               [igxForScrollContainer]="parentVirtDir"
     *               [igxForContainerSize]="'500px'">
     *                   <div [style.min-width]="'50px'">{{rowIndex}} : {{item.text}}</div>
     *           </ng-template>
     *       </div>
     * </ng-template>
     * ```
     * @type {?}
     */
    IgxForOfDirective.prototype.igxForScrollContainer;
    /**
     * An \@Input property that sets the px-affixed size of the container along the axis of scrolling.
     * For "horizontal" orientation this value is the width of the container and for "vertical" is the height.
     * ```html
     * <ng-template igxFor let-item [igxForOf]="data" [igxForContainerSize]="'500px'"
     *      [igxForScrollOrientation]="'horizontal'">
     * </ng-template>
     * ```
     * @type {?}
     */
    IgxForOfDirective.prototype.igxForContainerSize;
    /**
     * An \@Input property that sets the px-affixed size of the item along the axis of scrolling.
     * For "horizontal" orientation this value is the width of the column and for "vertical" is the height or the row.
     * ```html
     * <ng-template igxFor let-item [igxForOf]="data" [igxForScrollOrientation]="'horizontal'" [igxForItemSize]="'50px'"></ng-template>
     * ```
     * @type {?}
     */
    IgxForOfDirective.prototype.igxForItemSize;
    /**
     * @hidden
     * @type {?}
     */
    IgxForOfDirective.prototype.dc;
    /**
     * The current state of the directive. It contains `startIndex` and `chunkSize`.
     * state.startIndex - The index of the item at which the current visible chunk begins.
     * state.chunkSize - The number of items the current visible chunk holds.
     * These options can be used when implementing remote virtualization as they provide the necessary state information.
     * ```typescript
     * const gridState = this.parentVirtDir.state;
     * ```
     * @type {?}
     */
    IgxForOfDirective.prototype.state;
    /**
     * The total count of the virtual data items, when using remote service.
     * ```typescript
     * this.parentVirtDir.totalItemCount = data.Count;
     * ```
     * @type {?}
     */
    IgxForOfDirective.prototype.totalItemCount;
    /**
     * An event that is emitted after a new chunk has been loaded.
     * ```html
     * <ng-template igxFor [igxForOf]="data" [igxForScrollOrientation]="'horizontal'" (onChunkLoad)="chunkLoad($event)"></ng-template>
     * ```
     * ```typescript
     * chunkLoad(e){
     * alert("chunk loaded!");
     * }
     * ```
     * @type {?}
     */
    IgxForOfDirective.prototype.onChunkLoad;
    /**
     * An event that is emitted after data has been changed.
     * ```html
     * <ng-template igxFor [igxForOf]="data" [igxForScrollOrientation]="'horizontal'" (onDataChanged)="dataChanged($event)"></ng-template>
     * ```
     * ```typescript
     * dataChanged(e){
     * alert("data changed!");
     * }
     * ```
     * @type {?}
     */
    IgxForOfDirective.prototype.onDataChanged;
    /** @type {?} */
    IgxForOfDirective.prototype.onBeforeViewDestroyed;
    /**
     * An event that is emitted on chunk loading to emit the current state information - startIndex, endIndex, totalCount.
     * Can be used for implementing remote load on demand for the igxFor data.
     * ```html
     * <ng-template igxFor [igxForOf]="data" [igxForScrollOrientation]="'horizontal'" (onChunkPreload)="chunkPreload($event)"></ng-template>
     * ```
     * ```typescript
     * chunkPreload(e){
     * alert("chunk is loading!");
     * }
     * ```
     * @type {?}
     */
    IgxForOfDirective.prototype.onChunkPreload;
    /**
     * @type {?}
     * @protected
     */
    IgxForOfDirective.prototype.hScroll;
    /**
     * @type {?}
     * @protected
     */
    IgxForOfDirective.prototype.func;
    /**
     * @type {?}
     * @protected
     */
    IgxForOfDirective.prototype._sizesCache;
    /**
     * @type {?}
     * @protected
     */
    IgxForOfDirective.prototype.vh;
    /**
     * @type {?}
     * @protected
     */
    IgxForOfDirective.prototype.hvh;
    /**
     * @type {?}
     * @protected
     */
    IgxForOfDirective.prototype._differ;
    /**
     * @type {?}
     * @protected
     */
    IgxForOfDirective.prototype._trackByFn;
    /**
     * @type {?}
     * @protected
     */
    IgxForOfDirective.prototype.heightCache;
    /**
     * @type {?}
     * @private
     */
    IgxForOfDirective.prototype._adjustToIndex;
    /**
     * @type {?}
     * @private
     */
    IgxForOfDirective.prototype.MAX_PERF_SCROLL_DIFF;
    /**
     * Maximum height for an element of the browser.
     * @type {?}
     * @private
     */
    IgxForOfDirective.prototype._maxHeight;
    /**
     * Height that is being virtualized.
     * @type {?}
     * @protected
     */
    IgxForOfDirective.prototype._virtHeight;
    /**
     * Ratio for height that's being virtualizaed and the one visible
     * If _virtHeightRatio = 1, the visible height and the virtualized are the same, also _maxHeight > _virtHeight.
     * @type {?}
     * @private
     */
    IgxForOfDirective.prototype._virtHeightRatio;
    /**
     * Internal track for scroll top that is being virtualized
     * @type {?}
     * @protected
     */
    IgxForOfDirective.prototype._virtScrollTop;
    /**
     * If the next onScroll event is triggered due to internal setting of scrollTop
     * @type {?}
     * @protected
     */
    IgxForOfDirective.prototype._bScrollInternal;
    /**
     * @type {?}
     * @protected
     */
    IgxForOfDirective.prototype._embeddedViews;
    /**
     * @type {?}
     * @private
     */
    IgxForOfDirective.prototype._viewContainer;
    /**
     * @type {?}
     * @protected
     */
    IgxForOfDirective.prototype._template;
    /**
     * @type {?}
     * @protected
     */
    IgxForOfDirective.prototype._differs;
    /**
     * @type {?}
     * @private
     */
    IgxForOfDirective.prototype.resolver;
    /** @type {?} */
    IgxForOfDirective.prototype.cdr;
    /**
     * @type {?}
     * @protected
     */
    IgxForOfDirective.prototype._zone;
}
/**
 * @param {?} type
 * @return {?}
 */
export function getTypeNameForDebugging(type) {
    /** @type {?} */
    var name = 'name';
    return type[name] || typeof type;
}
/**
 * @record
 */
export function IForOfState() { }
if (false) {
    /** @type {?|undefined} */
    IForOfState.prototype.startIndex;
    /** @type {?|undefined} */
    IForOfState.prototype.chunkSize;
}
/**
 * @record
 */
export function IForOfDataChangingEventArgs() { }
if (false) {
    /** @type {?} */
    IForOfDataChangingEventArgs.prototype.containerSize;
}
/**
 * @template T
 */
var IgxGridForOfDirective = /** @class */ (function (_super) {
    tslib_1.__extends(IgxGridForOfDirective, _super);
    function IgxGridForOfDirective(_viewContainer, _template, _differs, resolver, cdr, _zone, syncService) {
        var _this = _super.call(this, _viewContainer, _template, _differs, resolver, cdr, _zone) || this;
        _this.syncService = syncService;
        /**
         * @hidden \@internal
         * An event that is emitted after data has been changed but before the view is refreshed
         */
        _this.onDataChanging = new EventEmitter();
        return _this;
    }
    Object.defineProperty(IgxGridForOfDirective.prototype, "igxGridForOf", {
        get: /**
         * @return {?}
         */
        function () {
            return this.igxForOf;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this.igxForOf = value;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    IgxGridForOfDirective.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        this.syncService.setMaster(this);
        _super.prototype.ngOnInit.call(this);
        this.removeScrollEventListeners();
    };
    /**
     * @param {?} changes
     * @return {?}
     */
    IgxGridForOfDirective.prototype.ngOnChanges = /**
     * @param {?} changes
     * @return {?}
     */
    function (changes) {
        /** @type {?} */
        var forOf = 'igxGridForOf';
        this.syncService.setMaster(this);
        if (forOf in changes) {
            /** @type {?} */
            var value = changes[forOf].currentValue;
            if (!this._differ && value) {
                try {
                    this._differ = this._differs.find(value).create(this.igxForTrackBy);
                }
                catch (e) {
                    throw new Error("Cannot find a differ supporting object \"" + value + "\" of type \"" + getTypeNameForDebugging(value) + "\".\n                     NgFor only supports binding to Iterables such as Arrays.");
                }
            }
        }
        /** @type {?} */
        var defaultItemSize = 'igxForItemSize';
        if (defaultItemSize in changes && !changes[defaultItemSize].firstChange && this.igxForScrollOrientation === 'vertical') {
            // handle default item size changed.
            this.initSizesCache(this.igxForOf);
        }
        /** @type {?} */
        var containerSize = 'igxForContainerSize';
        if (containerSize in changes && !changes[containerSize].firstChange && this.igxForOf) {
            this._recalcOnContainerChange(changes);
        }
    };
    Object.defineProperty(IgxGridForOfDirective.prototype, "sizesCache", {
        /**
         * @hidden
         * @internal
         */
        get: /**
         * @hidden
         * \@internal
         * @return {?}
         */
        function () {
            if (this.syncService.isMaster(this)) {
                return this._sizesCache;
            }
            return this.syncService.sizesCache(this.igxForScrollOrientation);
        },
        /**
         * @hidden
         * @internal
         */
        set: /**
         * @hidden
         * \@internal
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._sizesCache = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxGridForOfDirective.prototype, "itemsDimension", {
        get: /**
         * @protected
         * @return {?}
         */
        function () {
            return this.igxForScrollOrientation === 'horizontal' ? this.igxForSizePropName : 'height';
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @protected
     * @param {?} item
     * @return {?}
     */
    IgxGridForOfDirective.prototype.getItemSize = /**
     * @protected
     * @param {?} item
     * @return {?}
     */
    function (item) {
        /** @type {?} */
        var size = 0;
        /** @type {?} */
        var dimension = this.igxForScrollOrientation === 'horizontal' ?
            this.igxForSizePropName : 'height';
        if (dimension === 'height') {
            size = parseInt(this.igxForItemSize, 10) || 0;
            if (item && item.summaries) {
                size = item.max;
            }
            else if (item && item.groups && item.height) {
                size = item.height;
            }
        }
        else {
            size = parseInt(item[dimension], 10) || 0;
        }
        return size;
    };
    /**
     * @protected
     * @param {?} items
     * @return {?}
     */
    IgxGridForOfDirective.prototype.initSizesCache = /**
     * @protected
     * @param {?} items
     * @return {?}
     */
    function (items) {
        if (!this.syncService.isMaster(this)) {
            /** @type {?} */
            var masterSizesCache = this.syncService.sizesCache(this.igxForScrollOrientation);
            return masterSizesCache[masterSizesCache.length - 1];
        }
        /** @type {?} */
        var totalSize = 0;
        /** @type {?} */
        var size = 0;
        /** @type {?} */
        var i = 0;
        this.sizesCache = [];
        this.heightCache = [];
        this.sizesCache.push(0);
        /** @type {?} */
        var count = this.isRemote ? this.totalItemCount : items.length;
        for (i; i < count; i++) {
            size = this.getItemSize(items[i]);
            if (this.itemsDimension === 'height') {
                this.heightCache.push(size);
            }
            totalSize += size;
            this.sizesCache.push(totalSize);
        }
        return totalSize;
    };
    /**
     * @protected
     * @param {?=} changes
     * @return {?}
     */
    IgxGridForOfDirective.prototype._updateSizeCache = /**
     * @protected
     * @param {?=} changes
     * @return {?}
     */
    function (changes) {
        var _this = this;
        if (changes === void 0) { changes = null; }
        if (this.igxForScrollOrientation === 'horizontal') {
            this.initSizesCache(this.igxForOf);
            return;
        }
        /** @type {?} */
        var scr = this.vh.instance.elementRef.nativeElement;
        /** @type {?} */
        var oldHeight = this.heightCache.length > 0 ? this.heightCache.reduce(function (acc, val) { return acc + val; }) : 0;
        /** @type {?} */
        var newHeight = oldHeight;
        if (changes && !this.isRemote) {
            newHeight = this.handleCacheChanges(changes);
        }
        else {
            newHeight = this.initSizesCache(this.igxForOf);
        }
        /** @type {?} */
        var diff = oldHeight - newHeight;
        // if data has been changed while container is scrolled
        // should update scroll top/left according to change so that same startIndex is in view
        if (Math.abs(diff) > 0) {
            requestAnimationFrame(function () {
                _this.recalcUpdateSizes();
                /** @type {?} */
                var offset = parseInt(_this.dc.instance._viewContainer.element.nativeElement.style.top, 10);
                if (scr.scrollTop !== 0) {
                    scr.scrollTop = _this.sizesCache[_this.state.startIndex] - offset;
                }
                else {
                    _this._updateScrollOffset();
                }
            });
        }
    };
    /**
     * @protected
     * @param {?} changes
     * @return {?}
     */
    IgxGridForOfDirective.prototype.handleCacheChanges = /**
     * @protected
     * @param {?} changes
     * @return {?}
     */
    function (changes) {
        var _this = this;
        /** @type {?} */
        var identityChanges = [];
        /** @type {?} */
        var newHeightCache = [];
        /** @type {?} */
        var newSizesCache = [];
        newSizesCache.push(0);
        /** @type {?} */
        var newHeight = 0;
        // When there are more than one removed items the changes are not reliable so those with identity change should be default size.
        /** @type {?} */
        var numRemovedItems = 0;
        changes.forEachRemovedItem(function () { return numRemovedItems++; });
        // Get the identity changes to determine later if those that have changed their indexes should be assigned default item size.
        changes.forEachIdentityChange(function (item) {
            if (item.currentIndex !== item.previousIndex) {
                // Filter out ones that have not changed their index.
                identityChanges[item.currentIndex] = item;
            }
        });
        // Processing each item that is passed to the igxForOf so far seem to be most reliable. We parse the updated list of items.
        changes.forEachItem(function (item) {
            if (item.previousIndex !== null &&
                (numRemovedItems < 2 || !identityChanges.length || identityChanges[item.currentIndex])) {
                // Reuse cache on those who have previousIndex.
                // When there are more than one removed items currently the changes are not readable so ones with identity change
                // should be racalculated.
                newHeightCache[item.currentIndex] = _this.heightCache[item.previousIndex];
            }
            else {
                // Assign default item size.
                newHeightCache[item.currentIndex] = _this.getItemSize(item.item);
            }
            newSizesCache[item.currentIndex + 1] = newSizesCache[item.currentIndex] + newHeightCache[item.currentIndex];
            newHeight += newHeightCache[item.currentIndex];
        });
        this.heightCache = newHeightCache;
        this.sizesCache = newSizesCache;
        return newHeight;
    };
    /**
     * @hidden
     * @internal
     */
    /**
     * @hidden
     * \@internal
     * @return {?}
     */
    IgxGridForOfDirective.prototype.assumeMaster = /**
     * @hidden
     * \@internal
     * @return {?}
     */
    function () {
        this._sizesCache = this.syncService.sizesCache(this.igxForScrollOrientation);
        this.syncService.setMaster(this, true);
    };
    /**
     * @return {?}
     */
    IgxGridForOfDirective.prototype.ngDoCheck = /**
     * @return {?}
     */
    function () {
        if (this._differ) {
            /** @type {?} */
            var changes = this._differ.diff(this.igxForOf);
            if (changes) {
                /** @type {?} */
                var args = {
                    containerSize: this.igxForContainerSize
                };
                this.onDataChanging.emit(args);
                //  re-init cache.
                if (!this.igxForOf) {
                    return;
                }
                /* we need to reset the master dir if all rows are removed
                (e.g. because of filtering); if all columns are hidden, rows are
                still rendered empty, so we should not reset master */
                if (!this.igxForOf.length &&
                    this.igxForScrollOrientation === 'vertical') {
                    this.syncService.resetMaster();
                }
                this.syncService.setMaster(this);
                this.igxForContainerSize = args.containerSize;
                this._updateSizeCache(changes);
                this._applyChanges();
                this._updateScrollOffset();
                this.onDataChanged.emit();
            }
        }
    };
    /**
     * @param {?} event
     * @return {?}
     */
    IgxGridForOfDirective.prototype.onScroll = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        var _this = this;
        if (!parseInt(this.vh.instance.elementRef.nativeElement.style.height, 10)) {
            return;
        }
        /** @type {?} */
        var containerSize = parseInt(this.igxForContainerSize, 10);
        /** @type {?} */
        var maxRealScrollTop = event.target.children[0].scrollHeight - containerSize;
        /** @type {?} */
        var realPercentScrolled = event.target.scrollTop / maxRealScrollTop;
        if (!this._bScrollInternal) {
            /** @type {?} */
            var maxVirtScrollTop = this._virtHeight - containerSize;
            this._virtScrollTop = realPercentScrolled * maxVirtScrollTop;
        }
        else {
            this._bScrollInternal = false;
        }
        /** @type {?} */
        var scrollOffset = this.fixedUpdateAllElements(this._virtScrollTop);
        this.dc.instance._viewContainer.element.nativeElement.style.top = -(scrollOffset) + 'px';
        requestAnimationFrame(function () {
            _this.recalcUpdateSizes();
        });
    };
    /**
     * @param {?} scrollAmount
     * @return {?}
     */
    IgxGridForOfDirective.prototype.onHScroll = /**
     * @param {?} scrollAmount
     * @return {?}
     */
    function (scrollAmount) {
        /* in certain situations this may be called when no scrollbar is visible */
        if (!this.hScroll || !parseInt(this.hScroll.children[0].style.width, 10)) {
            return;
        }
        // Updating horizontal chunks
        /** @type {?} */
        var scrollOffset = this.fixedUpdateAllElements(scrollAmount);
        this.dc.instance._viewContainer.element.nativeElement.style.left = -scrollOffset + 'px';
    };
    /**
     * @protected
     * @return {?}
     */
    IgxGridForOfDirective.prototype.addLastElem = /**
     * @protected
     * @return {?}
     */
    function () {
        /** @type {?} */
        var elemIndex = this.state.startIndex + this.state.chunkSize;
        if (!this.isRemote && !this.igxForOf) {
            return;
        }
        if (elemIndex >= this.igxForOf.length) {
            elemIndex = this.igxForOf.length - this.state.chunkSize;
        }
        /** @type {?} */
        var input = this.igxForOf[elemIndex];
        /** @type {?} */
        var embeddedView = this.dc.instance._vcr.createEmbeddedView(this._template, { $implicit: input, index: elemIndex });
        this._embeddedViews.push(embeddedView);
        this.state.chunkSize++;
    };
    /**
     * @protected
     * @param {?} prevChunkSize
     * @return {?}
     */
    IgxGridForOfDirective.prototype._updateViews = /**
     * @protected
     * @param {?} prevChunkSize
     * @return {?}
     */
    function (prevChunkSize) {
        var _this = this;
        if (this.igxForOf && this.igxForOf.length && this.dc) {
            /** @type {?} */
            var embeddedViewCopy = Object.assign([], this._embeddedViews);
            /** @type {?} */
            var startIndex = void 0;
            /** @type {?} */
            var endIndex = void 0;
            if (this.isRemote) {
                startIndex = 0;
                endIndex = this.igxForOf.length;
            }
            else {
                /** @type {?} */
                var inScrollTop = this.igxForScrollOrientation === 'horizontal' ?
                    this.hScroll.scrollLeft :
                    this.vh.instance.elementRef.nativeElement.scrollTop;
                startIndex = this.getIndexAt(inScrollTop, this.sizesCache, 0);
                if (startIndex + this.state.chunkSize > this.igxForOf.length) {
                    startIndex = this.igxForOf.length - this.state.chunkSize;
                }
                this.state.startIndex = startIndex;
                endIndex = this.state.chunkSize + this.state.startIndex;
            }
            for (var i = startIndex; i < endIndex && this.igxForOf[i] !== undefined; i++) {
                /** @type {?} */
                var input = this.igxForOf[i];
                /** @type {?} */
                var embView = embeddedViewCopy.shift();
                /** @type {?} */
                var cntx = ((/** @type {?} */ (embView))).context;
                cntx.$implicit = input;
                cntx.index = this.getContextIndex(input);
            }
            if (prevChunkSize !== this.state.chunkSize) {
                this.onChunkLoad.emit(this.state);
            }
            if (this.igxForScrollOrientation === 'vertical') {
                requestAnimationFrame(function () {
                    _this.recalcUpdateSizes();
                });
            }
        }
    };
    /**
     * @protected
     * @return {?}
     */
    IgxGridForOfDirective.prototype._applyChanges = /**
     * @protected
     * @return {?}
     */
    function () {
        /** @type {?} */
        var prevChunkSize = this.state.chunkSize;
        this.applyChunkSizeChange();
        this._recalcScrollBarSize();
        this._updateViews(prevChunkSize);
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @protected
     * @return {?}
     */
    IgxGridForOfDirective.prototype._calcMaxChunkSize = /**
     * @hidden
     * @protected
     * @return {?}
     */
    function () {
        if (this.syncService.isMaster(this)) {
            return _super.prototype._calcMaxChunkSize.call(this);
        }
        return this.syncService.chunkSize(this.igxForScrollOrientation);
    };
    IgxGridForOfDirective.decorators = [
        { type: Directive, args: [{
                    selector: '[igxGridFor][igxGridForOf]'
                },] }
    ];
    /** @nocollapse */
    IgxGridForOfDirective.ctorParameters = function () { return [
        { type: ViewContainerRef },
        { type: TemplateRef },
        { type: IterableDiffers },
        { type: ComponentFactoryResolver },
        { type: ChangeDetectorRef },
        { type: NgZone },
        { type: IgxForOfSyncService }
    ]; };
    IgxGridForOfDirective.propDecorators = {
        igxGridForOf: [{ type: Input }],
        onDataChanging: [{ type: Output }]
    };
    return IgxGridForOfDirective;
}(IgxForOfDirective));
export { IgxGridForOfDirective };
if (false) {
    /**
     * @hidden \@internal
     * An event that is emitted after data has been changed but before the view is refreshed
     * @type {?}
     */
    IgxGridForOfDirective.prototype.onDataChanging;
    /**
     * @type {?}
     * @protected
     */
    IgxGridForOfDirective.prototype.syncService;
}
/**
 * @hidden
 */
var IgxForOfModule = /** @class */ (function () {
    function IgxForOfModule() {
    }
    IgxForOfModule.decorators = [
        { type: NgModule, args: [{
                    declarations: [IgxForOfDirective, IgxGridForOfDirective, DisplayContainerComponent, VirtualHelperComponent, HVirtualHelperComponent],
                    entryComponents: [DisplayContainerComponent, VirtualHelperComponent, HVirtualHelperComponent],
                    exports: [IgxForOfDirective, IgxGridForOfDirective],
                    imports: [IgxScrollInertiaModule, CommonModule]
                },] }
    ];
    return IgxForOfModule;
}());
export { IgxForOfModule };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZm9yX29mLmRpcmVjdGl2ZS5qcyIsInNvdXJjZVJvb3QiOiJuZzovL2lnbml0ZXVpLWFuZ3VsYXIvIiwic291cmNlcyI6WyJsaWIvZGlyZWN0aXZlcy9mb3Itb2YvZm9yX29mLmRpcmVjdGl2ZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7OztBQUFBLE9BQU8sRUFBRSxZQUFZLEVBQWtCLE1BQU0saUJBQWlCLENBQUM7QUFDL0QsT0FBTyxFQUNILGlCQUFpQixFQUVqQix3QkFBd0IsRUFFeEIsU0FBUyxFQUdULFlBQVksRUFDWixLQUFLLEVBR0wsZUFBZSxFQUNmLFFBQVEsRUFDUixNQUFNLEVBSU4sTUFBTSxFQUVOLFdBQVcsRUFFWCxnQkFBZ0IsRUFFbkIsTUFBTSxlQUFlLENBQUM7QUFFdkIsT0FBTyxFQUFFLHlCQUF5QixFQUFFLE1BQU0scUJBQXFCLENBQUM7QUFDaEUsT0FBTyxFQUFFLHVCQUF1QixFQUFFLE1BQU0sdUNBQXVDLENBQUM7QUFDaEYsT0FBTyxFQUFFLHNCQUFzQixFQUFFLE1BQU0sNEJBQTRCLENBQUM7QUFDcEUsT0FBTyxFQUFFLHNCQUFzQixFQUFFLE1BQU0sOENBQThDLENBQUM7QUFDdEYsT0FBTyxFQUFFLG1CQUFtQixFQUFFLE1BQU0sdUJBQXVCLENBQUM7Ozs7QUFFNUQ7SUF1TUksMkJBQ1ksY0FBZ0MsRUFDOUIsU0FBeUMsRUFDekMsUUFBeUIsRUFDM0IsUUFBa0MsRUFDbkMsR0FBc0IsRUFDbkIsS0FBYTtRQUxmLG1CQUFjLEdBQWQsY0FBYyxDQUFrQjtRQUM5QixjQUFTLEdBQVQsU0FBUyxDQUFnQztRQUN6QyxhQUFRLEdBQVIsUUFBUSxDQUFpQjtRQUMzQixhQUFRLEdBQVIsUUFBUSxDQUEwQjtRQUNuQyxRQUFHLEdBQUgsR0FBRyxDQUFtQjtRQUNuQixVQUFLLEdBQUwsS0FBSyxDQUFROzs7Ozs7Ozs7O1FBdkhwQixVQUFLLEdBQWdCO1lBQ3hCLFVBQVUsRUFBRSxDQUFDO1lBQ2IsU0FBUyxFQUFFLENBQUM7U0FD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QUE7SUFRQSxDQUFDOztnQkFSQSxRQUFRLFNBQUM7b0JBQ04sWUFBWSxFQUFFLENBQUMsaUJBQWlCLEVBQUUscUJBQXFCLEVBQUUseUJBQXlCLEVBQUUsc0JBQXNCLEVBQUUsdUJBQXVCLENBQUM7b0JBQ3BJLGVBQWUsRUFBRSxDQUFDLHlCQUF5QixFQUFFLHNCQUFzQixFQUFFLHVCQUF1QixDQUFDO29CQUM3RixPQUFPLEVBQUUsQ0FBQyxpQkFBaUIsRUFBRSxxQkFBcUIsQ0FBQztvQkFDbkQsT0FBTyxFQUFFLENBQUMsc0JBQXNCLEVBQUUsWUFBWSxDQUFDO2lCQUNsRDs7SUFHRCxxQkFBQztDQUFBLEFBUkQsSUFRQztTQURZLGNBQWMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBDb21tb25Nb2R1bGUsIE5nRm9yT2ZDb250ZXh0IH0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcbmltcG9ydCB7XG4gICAgQ2hhbmdlRGV0ZWN0b3JSZWYsXG4gICAgQ29tcG9uZW50RmFjdG9yeSxcbiAgICBDb21wb25lbnRGYWN0b3J5UmVzb2x2ZXIsXG4gICAgQ29tcG9uZW50UmVmLFxuICAgIERpcmVjdGl2ZSxcbiAgICBEb0NoZWNrLFxuICAgIEVtYmVkZGVkVmlld1JlZixcbiAgICBFdmVudEVtaXR0ZXIsXG4gICAgSW5wdXQsXG4gICAgSXRlcmFibGVDaGFuZ2VzLFxuICAgIEl0ZXJhYmxlRGlmZmVyLFxuICAgIEl0ZXJhYmxlRGlmZmVycyxcbiAgICBOZ01vZHVsZSxcbiAgICBOZ1pvbmUsXG4gICAgT25DaGFuZ2VzLFxuICAgIE9uRGVzdHJveSxcbiAgICBPbkluaXQsXG4gICAgT3V0cHV0LFxuICAgIFNpbXBsZUNoYW5nZXMsXG4gICAgVGVtcGxhdGVSZWYsXG4gICAgVHJhY2tCeUZ1bmN0aW9uLFxuICAgIFZpZXdDb250YWluZXJSZWYsXG4gICAgVmlld1JlZlxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuaW1wb3J0IHsgRGlzcGxheUNvbnRhaW5lckNvbXBvbmVudCB9IGZyb20gJy4vZGlzcGxheS5jb250YWluZXInO1xuaW1wb3J0IHsgSFZpcnR1YWxIZWxwZXJDb21wb25lbnQgfSBmcm9tICcuL2hvcml6b250YWwudmlydHVhbC5oZWxwZXIuY29tcG9uZW50JztcbmltcG9ydCB7IFZpcnR1YWxIZWxwZXJDb21wb25lbnQgfSBmcm9tICcuL3ZpcnR1YWwuaGVscGVyLmNvbXBvbmVudCc7XG5pbXBvcnQgeyBJZ3hTY3JvbGxJbmVydGlhTW9kdWxlIH0gZnJvbSAnLi8uLi9zY3JvbGwtaW5lcnRpYS9zY3JvbGxfaW5lcnRpYS5kaXJlY3RpdmUnO1xuaW1wb3J0IHsgSWd4Rm9yT2ZTeW5jU2VydmljZSB9IGZyb20gJy4vZm9yX29mLnN5bmMuc2VydmljZSc7XG5cbkBEaXJlY3RpdmUoeyBzZWxlY3RvcjogJ1tpZ3hGb3JdW2lneEZvck9mXScgfSlcbmV4cG9ydCBjbGFzcyBJZ3hGb3JPZkRpcmVjdGl2ZTxUPiBpbXBsZW1lbnRzIE9uSW5pdCwgT25DaGFuZ2VzLCBEb0NoZWNrLCBPbkRlc3Ryb3kge1xuXG4gICAgLyoqXG4gICAgICogQW4gQElucHV0IHByb3BlcnR5IHRoYXQgc2V0cyB0aGUgZGF0YSB0byBiZSByZW5kZXJlZC5cbiAgICAgKiBgYGBodG1sXG4gICAgICogPG5nLXRlbXBsYXRlIGlneEZvciBsZXQtaXRlbSBbaWd4Rm9yT2ZdPVwiZGF0YVwiIFtpZ3hGb3JTY3JvbGxPcmllbnRhdGlvbl09XCInaG9yaXpvbnRhbCdcIj48L25nLXRlbXBsYXRlPlxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgcHVibGljIGlneEZvck9mOiBhbnlbXTtcblxuICAgIC8qKlxuICAgICAqIEFuIEBJbnB1dCBwcm9wZXJ0eSB0aGF0IHNldHMgdGhlIHByb3BlcnR5IG5hbWUgZnJvbSB3aGljaCB0byByZWFkIHRoZSBzaXplIGluIHRoZSBkYXRhIG9iamVjdC5cbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHB1YmxpYyBpZ3hGb3JTaXplUHJvcE5hbWU7XG5cbiAgICAvKipcbiAgICAgKiBBbiBASW5wdXQgcHJvcGVydHkgdGhhdCBzcGVjaWZpZXMgdGhlIHNjcm9sbCBvcmllbnRhdGlvbi5cbiAgICAgKiBTY3JvbGwgb3JpZW50YXRpb24gY2FuIGJlIFwidmVydGljYWxcIiBvciBcImhvcml6b250YWxcIi5cbiAgICAgKiBgYGBodG1sXG4gICAgICogPG5nLXRlbXBsYXRlIGlneEZvciBsZXQtaXRlbSBbaWd4Rm9yT2ZdPVwiZGF0YVwiIFtpZ3hGb3JTY3JvbGxPcmllbnRhdGlvbl09XCInaG9yaXpvbnRhbCdcIj48L25nLXRlbXBsYXRlPlxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgcHVibGljIGlneEZvclNjcm9sbE9yaWVudGF0aW9uOiBzdHJpbmc7XG5cbiAgICAvKipcbiAgICAgKiBPcHRpb25hbGx5IHBhc3MgdGhlIHBhcmVudCBgaWd4Rm9yYCBpbnN0YW5jZSB0byBjcmVhdGUgYSB2aXJ0dWFsIHRlbXBsYXRlIHNjcm9sbGluZyBib3RoIGhvcml6b250YWxseSBhbmQgdmVydGljYWxseS5cbiAgICAgKiBgYGBodG1sXG4gICAgICogPG5nLXRlbXBsYXRlICNzY3JvbGxDb250YWluZXIgaWd4Rm9yIGxldC1yb3dEYXRhIFtpZ3hGb3JPZl09XCJkYXRhXCJcbiAgICAgKiAgICAgICBbaWd4Rm9yU2Nyb2xsT3JpZW50YXRpb25dPVwiJ3ZlcnRpY2FsJ1wiXG4gICAgICogICAgICAgW2lneEZvckNvbnRhaW5lclNpemVdPVwiJzUwMHB4J1wiXG4gICAgICogICAgICAgW2lneEZvckl0ZW1TaXplXT1cIic1MHB4J1wiXG4gICAgICogICAgICAgbGV0LXJvd0luZGV4PVwiaW5kZXhcIj5cbiAgICAgKiAgICAgICA8ZGl2IFtzdHlsZS5kaXNwbGF5XT1cIidmbGV4J1wiIFtzdHlsZS5oZWlnaHRdPVwiJzUwcHgnXCI+XG4gICAgICogICAgICAgICAgIDxuZy10ZW1wbGF0ZSAjY2hpbGRDb250YWluZXIgaWd4Rm9yIGxldC1pdGVtIFtpZ3hGb3JPZl09XCJkYXRhXCJcbiAgICAgKiAgICAgICAgICAgICAgIFtpZ3hGb3JTY3JvbGxPcmllbnRhdGlvbl09XCInaG9yaXpvbnRhbCdcIlxuICAgICAqICAgICAgICAgICAgICAgW2lneEZvclNjcm9sbENvbnRhaW5lcl09XCJwYXJlbnRWaXJ0RGlyXCJcbiAgICAgKiAgICAgICAgICAgICAgIFtpZ3hGb3JDb250YWluZXJTaXplXT1cIic1MDBweCdcIj5cbiAgICAgKiAgICAgICAgICAgICAgICAgICA8ZGl2IFtzdHlsZS5taW4td2lkdGhdPVwiJzUwcHgnXCI+e3tyb3dJbmRleH19IDoge3tpdGVtLnRleHR9fTwvZGl2PlxuICAgICAqICAgICAgICAgICA8L25nLXRlbXBsYXRlPlxuICAgICAqICAgICAgIDwvZGl2PlxuICAgICAqIDwvbmctdGVtcGxhdGU+XG4gICAgICogYGBgXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBwdWJsaWMgaWd4Rm9yU2Nyb2xsQ29udGFpbmVyOiBhbnk7XG5cbiAgICAvKipcbiAgICAgKiBBbiBASW5wdXQgcHJvcGVydHkgdGhhdCBzZXRzIHRoZSBweC1hZmZpeGVkIHNpemUgb2YgdGhlIGNvbnRhaW5lciBhbG9uZyB0aGUgYXhpcyBvZiBzY3JvbGxpbmcuXG4gICAgICogRm9yIFwiaG9yaXpvbnRhbFwiIG9yaWVudGF0aW9uIHRoaXMgdmFsdWUgaXMgdGhlIHdpZHRoIG9mIHRoZSBjb250YWluZXIgYW5kIGZvciBcInZlcnRpY2FsXCIgaXMgdGhlIGhlaWdodC5cbiAgICAgKiBgYGBodG1sXG4gICAgICogPG5nLXRlbXBsYXRlIGlneEZvciBsZXQtaXRlbSBbaWd4Rm9yT2ZdPVwiZGF0YVwiIFtpZ3hGb3JDb250YWluZXJTaXplXT1cIic1MDBweCdcIlxuICAgICAqICAgICAgW2lneEZvclNjcm9sbE9yaWVudGF0aW9uXT1cIidob3Jpem9udGFsJ1wiPlxuICAgICAqIDwvbmctdGVtcGxhdGU+XG4gICAgICogYGBgXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBwdWJsaWMgaWd4Rm9yQ29udGFpbmVyU2l6ZTogYW55O1xuXG4gICAgLyoqXG4gICAgICogQW4gQElucHV0IHByb3BlcnR5IHRoYXQgc2V0cyB0aGUgcHgtYWZmaXhlZCBzaXplIG9mIHRoZSBpdGVtIGFsb25nIHRoZSBheGlzIG9mIHNjcm9sbGluZy5cbiAgICAgKiBGb3IgXCJob3Jpem9udGFsXCIgb3JpZW50YXRpb24gdGhpcyB2YWx1ZSBpcyB0aGUgd2lkdGggb2YgdGhlIGNvbHVtbiBhbmQgZm9yIFwidmVydGljYWxcIiBpcyB0aGUgaGVpZ2h0IG9yIHRoZSByb3cuXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxuZy10ZW1wbGF0ZSBpZ3hGb3IgbGV0LWl0ZW0gW2lneEZvck9mXT1cImRhdGFcIiBbaWd4Rm9yU2Nyb2xsT3JpZW50YXRpb25dPVwiJ2hvcml6b250YWwnXCIgW2lneEZvckl0ZW1TaXplXT1cIic1MHB4J1wiPjwvbmctdGVtcGxhdGU+XG4gICAgICogYGBgXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBwdWJsaWMgaWd4Rm9ySXRlbVNpemU6IGFueTtcblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBwdWJsaWMgZGM6IENvbXBvbmVudFJlZjxEaXNwbGF5Q29udGFpbmVyQ29tcG9uZW50PjtcblxuICAgIC8qKlxuICAgICAqIFRoZSBjdXJyZW50IHN0YXRlIG9mIHRoZSBkaXJlY3RpdmUuIEl0IGNvbnRhaW5zIGBzdGFydEluZGV4YCBhbmQgYGNodW5rU2l6ZWAuXG4gICAgICogc3RhdGUuc3RhcnRJbmRleCAtIFRoZSBpbmRleCBvZiB0aGUgaXRlbSBhdCB3aGljaCB0aGUgY3VycmVudCB2aXNpYmxlIGNodW5rIGJlZ2lucy5cbiAgICAgKiBzdGF0ZS5jaHVua1NpemUgLSBUaGUgbnVtYmVyIG9mIGl0ZW1zIHRoZSBjdXJyZW50IHZpc2libGUgY2h1bmsgaG9sZHMuXG4gICAgICogVGhlc2Ugb3B0aW9ucyBjYW4gYmUgdXNlZCB3aGVuIGltcGxlbWVudGluZyByZW1vdGUgdmlydHVhbGl6YXRpb24gYXMgdGhleSBwcm92aWRlIHRoZSBuZWNlc3Nhcnkgc3RhdGUgaW5mb3JtYXRpb24uXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIGNvbnN0IGdyaWRTdGF0ZSA9IHRoaXMucGFyZW50VmlydERpci5zdGF0ZTtcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBwdWJsaWMgc3RhdGU6IElGb3JPZlN0YXRlID0ge1xuICAgICAgICBzdGFydEluZGV4OiAwLFxuICAgICAgICBjaHVua1NpemU6IDBcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFRoZSB0b3RhbCBjb3VudCBvZiB0aGUgdmlydHVhbCBkYXRhIGl0ZW1zLCB3aGVuIHVzaW5nIHJlbW90ZSBzZXJ2aWNlLlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiB0aGlzLnBhcmVudFZpcnREaXIudG90YWxJdGVtQ291bnQgPSBkYXRhLkNvdW50O1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIHB1YmxpYyB0b3RhbEl0ZW1Db3VudDogbnVtYmVyID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEFuIGV2ZW50IHRoYXQgaXMgZW1pdHRlZCBhZnRlciBhIG5ldyBjaHVuayBoYXMgYmVlbiBsb2FkZWQuXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxuZy10ZW1wbGF0ZSBpZ3hGb3IgW2lneEZvck9mXT1cImRhdGFcIiBbaWd4Rm9yU2Nyb2xsT3JpZW50YXRpb25dPVwiJ2hvcml6b250YWwnXCIgKG9uQ2h1bmtMb2FkKT1cImNodW5rTG9hZCgkZXZlbnQpXCI+PC9uZy10ZW1wbGF0ZT5cbiAgICAgKiBgYGBcbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogY2h1bmtMb2FkKGUpe1xuICAgICAqIGFsZXJ0KFwiY2h1bmsgbG9hZGVkIVwiKTtcbiAgICAgKiB9XG4gICAgICogYGBgXG4gICAgICovXG4gICAgQE91dHB1dCgpXG4gICAgcHVibGljIG9uQ2h1bmtMb2FkID0gbmV3IEV2ZW50RW1pdHRlcjxJRm9yT2ZTdGF0ZT4oKTtcblxuICAgIC8qKlxuICAgICAqIEFuIGV2ZW50IHRoYXQgaXMgZW1pdHRlZCBhZnRlciBkYXRhIGhhcyBiZWVuIGNoYW5nZWQuXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxuZy10ZW1wbGF0ZSBpZ3hGb3IgW2lneEZvck9mXT1cImRhdGFcIiBbaWd4Rm9yU2Nyb2xsT3JpZW50YXRpb25dPVwiJ2hvcml6b250YWwnXCIgKG9uRGF0YUNoYW5nZWQpPVwiZGF0YUNoYW5nZWQoJGV2ZW50KVwiPjwvbmctdGVtcGxhdGU+XG4gICAgICogYGBgXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIGRhdGFDaGFuZ2VkKGUpe1xuICAgICAqIGFsZXJ0KFwiZGF0YSBjaGFuZ2VkIVwiKTtcbiAgICAgKiB9XG4gICAgICogYGBgXG4gICAgICovXG4gICAgQE91dHB1dCgpXG4gICAgcHVibGljIG9uRGF0YUNoYW5nZWQgPSBuZXcgRXZlbnRFbWl0dGVyPGFueT4oKTtcblxuICAgIEBPdXRwdXQoKVxuICAgIHB1YmxpYyBvbkJlZm9yZVZpZXdEZXN0cm95ZWQgPSBuZXcgRXZlbnRFbWl0dGVyPEVtYmVkZGVkVmlld1JlZjxhbnk+PigpO1xuXG4gICAgLyoqXG4gICAgICogQW4gZXZlbnQgdGhhdCBpcyBlbWl0dGVkIG9uIGNodW5rIGxvYWRpbmcgdG8gZW1pdCB0aGUgY3VycmVudCBzdGF0ZSBpbmZvcm1hdGlvbiAtIHN0YXJ0SW5kZXgsIGVuZEluZGV4LCB0b3RhbENvdW50LlxuICAgICAqIENhbiBiZSB1c2VkIGZvciBpbXBsZW1lbnRpbmcgcmVtb3RlIGxvYWQgb24gZGVtYW5kIGZvciB0aGUgaWd4Rm9yIGRhdGEuXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxuZy10ZW1wbGF0ZSBpZ3hGb3IgW2lneEZvck9mXT1cImRhdGFcIiBbaWd4Rm9yU2Nyb2xsT3JpZW50YXRpb25dPVwiJ2hvcml6b250YWwnXCIgKG9uQ2h1bmtQcmVsb2FkKT1cImNodW5rUHJlbG9hZCgkZXZlbnQpXCI+PC9uZy10ZW1wbGF0ZT5cbiAgICAgKiBgYGBcbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogY2h1bmtQcmVsb2FkKGUpe1xuICAgICAqIGFsZXJ0KFwiY2h1bmsgaXMgbG9hZGluZyFcIik7XG4gICAgICogfVxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIEBPdXRwdXQoKVxuICAgIHB1YmxpYyBvbkNodW5rUHJlbG9hZCA9IG5ldyBFdmVudEVtaXR0ZXI8SUZvck9mU3RhdGU+KCk7XG5cbiAgICBwcm90ZWN0ZWQgaFNjcm9sbDtcbiAgICBwcm90ZWN0ZWQgZnVuYztcbiAgICBwcm90ZWN0ZWQgX3NpemVzQ2FjaGU6IG51bWJlcltdID0gW107XG4gICAgcHJvdGVjdGVkIHZoOiBDb21wb25lbnRSZWY8VmlydHVhbEhlbHBlckNvbXBvbmVudD47XG4gICAgcHJvdGVjdGVkIGh2aDogQ29tcG9uZW50UmVmPEhWaXJ0dWFsSGVscGVyQ29tcG9uZW50PjtcbiAgICBwcm90ZWN0ZWQgX2RpZmZlcjogSXRlcmFibGVEaWZmZXI8VD4gfCBudWxsID0gbnVsbDtcbiAgICBwcm90ZWN0ZWQgX3RyYWNrQnlGbjogVHJhY2tCeUZ1bmN0aW9uPFQ+O1xuICAgIHByb3RlY3RlZCBoZWlnaHRDYWNoZSA9IFtdO1xuICAgIHByaXZhdGUgX2FkanVzdFRvSW5kZXg7XG4gICAgcHJpdmF0ZSBNQVhfUEVSRl9TQ1JPTExfRElGRiA9IDQ7XG5cbiAgICBwcm90ZWN0ZWQgZ2V0IHNpemVzQ2FjaGUoKTogbnVtYmVyW10ge1xuICAgICAgICByZXR1cm4gdGhpcy5fc2l6ZXNDYWNoZTtcbiAgICB9XG4gICAgcHJvdGVjdGVkIHNldCBzaXplc0NhY2hlKHZhbHVlOiBudW1iZXJbXSkge1xuICAgICAgICB0aGlzLl9zaXplc0NhY2hlID0gdmFsdWU7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBnZXQgX2lzU2Nyb2xsZWRUb0JvdHRvbSgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmdldFZlcnRpY2FsU2Nyb2xsKCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNjcm9sbFRvcCA9IHRoaXMuZ2V0VmVydGljYWxTY3JvbGwoKS5zY3JvbGxUb3A7XG4gICAgICAgIGNvbnN0IHNjcm9sbEhlaWdodCA9IHRoaXMuZ2V0VmVydGljYWxTY3JvbGwoKS5zY3JvbGxIZWlnaHQ7XG4gICAgICAgIC8vIFVzZSA9PT0gYW5kIG5vdCA+PSBiZWNhdXNlIGBzY3JvbGxUb3AgKyBjb250YWluZXIgc2l6ZWAgY2FuJ3QgYmUgYmlnZ2VyIHRoYW4gYHNjcm9sbEhlaWdodGAsIHVubGVzcyBzb21ldGhpbmcgaXNuJ3QgdXBkYXRlZC5cbiAgICAgICAgLy8gQWxzbyB1c2UgTWF0aC5yb3VuZCBiZWNhdXNlIENocm9tZSBoYXMgc29tZSBpbmNvbnNpc3RlbmNpZXMgYW5kIGBzY3JvbGxUb3AgKyBjb250YWluZXJgIGNhbiBiZSBmbG9hdCB3aGVuIHpvb21pbmcgdGhlIHBhZ2UuXG4gICAgICAgIHJldHVybiBNYXRoLnJvdW5kKHNjcm9sbFRvcCArIHRoaXMuaWd4Rm9yQ29udGFpbmVyU2l6ZSkgPT09IHNjcm9sbEhlaWdodDtcbiAgICB9XG5cbiAgICBwcml2YXRlIGdldCBfaXNBdEJvdHRvbUluZGV4KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pZ3hGb3JPZiAmJiB0aGlzLnN0YXRlLnN0YXJ0SW5kZXggKyB0aGlzLnN0YXRlLmNodW5rU2l6ZSA+IHRoaXMuaWd4Rm9yT2YubGVuZ3RoO1xuICAgIH1cblxuICAgIC8vIFN0YXJ0IHByb3BlcnRpZXMgcmVsYXRlZCB0byB2aXJ0dWFsIGhlaWdodCBoYW5kbGluZyBkdWUgdG8gYnJvd3NlciBsaW1pdGF0aW9uXG4gICAgLyoqIE1heGltdW0gaGVpZ2h0IGZvciBhbiBlbGVtZW50IG9mIHRoZSBicm93c2VyLiAqL1xuICAgIHByaXZhdGUgX21heEhlaWdodDtcblxuICAgIC8qKiBIZWlnaHQgdGhhdCBpcyBiZWluZyB2aXJ0dWFsaXplZC4gKi9cbiAgICBwcm90ZWN0ZWQgX3ZpcnRIZWlnaHQgPSAwO1xuXG4gICAgLyoqXG4gICAgICogUmF0aW8gZm9yIGhlaWdodCB0aGF0J3MgYmVpbmcgdmlydHVhbGl6YWVkIGFuZCB0aGUgb25lIHZpc2libGVcbiAgICAgKiBJZiBfdmlydEhlaWdodFJhdGlvID0gMSwgdGhlIHZpc2libGUgaGVpZ2h0IGFuZCB0aGUgdmlydHVhbGl6ZWQgYXJlIHRoZSBzYW1lLCBhbHNvIF9tYXhIZWlnaHQgPiBfdmlydEhlaWdodC5cbiAgICAgKi9cbiAgICBwcml2YXRlIF92aXJ0SGVpZ2h0UmF0aW8gPSAxO1xuXG4gICAgLyoqIEludGVybmFsIHRyYWNrIGZvciBzY3JvbGwgdG9wIHRoYXQgaXMgYmVpbmcgdmlydHVhbGl6ZWQgKi9cbiAgICBwcm90ZWN0ZWQgX3ZpcnRTY3JvbGxUb3AgPSAwO1xuXG4gICAgLyoqIElmIHRoZSBuZXh0IG9uU2Nyb2xsIGV2ZW50IGlzIHRyaWdnZXJlZCBkdWUgdG8gaW50ZXJuYWwgc2V0dGluZyBvZiBzY3JvbGxUb3AgKi9cbiAgICBwcm90ZWN0ZWQgX2JTY3JvbGxJbnRlcm5hbCA9IGZhbHNlO1xuICAgIC8vIEVuZCBwcm9wZXJ0aWVzIHJlbGF0ZWQgdG8gdmlydHVhbCBoZWlnaHQgaGFuZGxpbmdcblxuICAgIHByb3RlY3RlZCBfZW1iZWRkZWRWaWV3czogQXJyYXk8RW1iZWRkZWRWaWV3UmVmPGFueT4+ID0gW107XG5cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAgICAgcHJpdmF0ZSBfdmlld0NvbnRhaW5lcjogVmlld0NvbnRhaW5lclJlZixcbiAgICAgICAgcHJvdGVjdGVkIF90ZW1wbGF0ZTogVGVtcGxhdGVSZWY8TmdGb3JPZkNvbnRleHQ8VD4+LFxuICAgICAgICBwcm90ZWN0ZWQgX2RpZmZlcnM6IEl0ZXJhYmxlRGlmZmVycyxcbiAgICAgICAgcHJpdmF0ZSByZXNvbHZlcjogQ29tcG9uZW50RmFjdG9yeVJlc29sdmVyLFxuICAgICAgICBwdWJsaWMgY2RyOiBDaGFuZ2VEZXRlY3RvclJlZixcbiAgICAgICAgcHJvdGVjdGVkIF96b25lOiBOZ1pvbmUpIHsgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHByb3RlY3RlZCBnZXQgaXNSZW1vdGUoKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiB0aGlzLnRvdGFsSXRlbUNvdW50ICE9PSBudWxsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgcmVtb3ZlU2Nyb2xsRXZlbnRMaXN0ZW5lcnMoKSB7XG4gICAgICAgIGlmICh0aGlzLmlneEZvclNjcm9sbE9yaWVudGF0aW9uID09PSAnaG9yaXpvbnRhbCcpIHtcbiAgICAgICAgICAgIHRoaXMuX3pvbmUucnVuT3V0c2lkZUFuZ3VsYXIoKCkgPT5cbiAgICAgICAgICAgICAgICB0aGlzLmdldEhvcml6b250YWxTY3JvbGwoKS5yZW1vdmVFdmVudExpc3RlbmVyKCdzY3JvbGwnLCB0aGlzLmZ1bmMpXG4gICAgICAgICAgICApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgdmVydGljYWwgPSB0aGlzLmdldFZlcnRpY2FsU2Nyb2xsKCk7XG4gICAgICAgICAgICBpZiAodmVydGljYWwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl96b25lLnJ1bk91dHNpZGVBbmd1bGFyKCgpID0+XG4gICAgICAgICAgICAgICAgICAgIHZlcnRpY2FsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIHRoaXMudmVydGljYWxTY3JvbGxIYW5kbGVyKVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwdWJsaWMgdmVydGljYWxTY3JvbGxIYW5kbGVyKGV2ZW50KSB7XG4gICAgICAgIHRoaXMub25TY3JvbGwoZXZlbnQpO1xuICAgIH1cblxuICAgIHB1YmxpYyBpc1Njcm9sbGFibGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZoLmluc3RhbmNlLmhlaWdodCA+IHBhcnNlSW50KHRoaXMuaWd4Rm9yQ29udGFpbmVyU2l6ZSwgMTApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBwdWJsaWMgbmdPbkluaXQoKTogdm9pZCB7XG4gICAgICAgIGxldCB0b3RhbFNpemUgPSAwO1xuICAgICAgICBjb25zdCB2YyA9IHRoaXMuaWd4Rm9yU2Nyb2xsQ29udGFpbmVyID8gdGhpcy5pZ3hGb3JTY3JvbGxDb250YWluZXIuX3ZpZXdDb250YWluZXIgOiB0aGlzLl92aWV3Q29udGFpbmVyO1xuICAgICAgICB0aGlzLmlneEZvclNpemVQcm9wTmFtZSA9IHRoaXMuaWd4Rm9yU2l6ZVByb3BOYW1lIHx8ICd3aWR0aCc7XG5cbiAgICAgICAgY29uc3QgZGNGYWN0b3J5OiBDb21wb25lbnRGYWN0b3J5PERpc3BsYXlDb250YWluZXJDb21wb25lbnQ+ID0gdGhpcy5yZXNvbHZlci5yZXNvbHZlQ29tcG9uZW50RmFjdG9yeShEaXNwbGF5Q29udGFpbmVyQ29tcG9uZW50KTtcbiAgICAgICAgdGhpcy5kYyA9IHRoaXMuX3ZpZXdDb250YWluZXIuY3JlYXRlQ29tcG9uZW50KGRjRmFjdG9yeSwgMCk7XG4gICAgICAgIHRoaXMuZGMuaW5zdGFuY2Uuc2Nyb2xsRGlyZWN0aW9uID0gdGhpcy5pZ3hGb3JTY3JvbGxPcmllbnRhdGlvbjtcbiAgICAgICAgaWYgKHR5cGVvZiBNU0dlc3R1cmUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIC8vIE9uIEVkZ2UgYW5kIElFIHdoZW4gc2Nyb2xsaW5nIG9uIHRvdWNoIHRoZSBwYWdlIHNjcm9sbCBpbnN0ZWFkIG9mIHRoZSBncmlkLlxuICAgICAgICAgICAgdGhpcy5kYy5pbnN0YW5jZS5fdmlld0NvbnRhaW5lci5lbGVtZW50Lm5hdGl2ZUVsZW1lbnQuc3R5bGUudG91Y2hBY3Rpb24gPSAnbm9uZSc7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuaWd4Rm9yT2YgJiYgdGhpcy5pZ3hGb3JPZi5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMuZGMuaW5zdGFuY2Uubm90VmlydHVhbCA9ICEodGhpcy5pZ3hGb3JDb250YWluZXJTaXplICYmIHRoaXMuc3RhdGUuY2h1bmtTaXplIDwgdGhpcy5pZ3hGb3JPZi5sZW5ndGgpO1xuICAgICAgICAgICAgdG90YWxTaXplID0gdGhpcy5pbml0U2l6ZXNDYWNoZSh0aGlzLmlneEZvck9mKTtcbiAgICAgICAgICAgIHRoaXMuaFNjcm9sbCA9IHRoaXMuZ2V0RWxlbWVudCh2YywgJ2lneC1ob3Jpem9udGFsLXZpcnR1YWwtaGVscGVyJyk7XG4gICAgICAgICAgICBpZiAodGhpcy5oU2Nyb2xsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0ZS5zdGFydEluZGV4ID0gdGhpcy5nZXRJbmRleEF0KHRoaXMuaFNjcm9sbC5zY3JvbGxMZWZ0LCB0aGlzLnNpemVzQ2FjaGUsIDApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5zdGF0ZS5jaHVua1NpemUgPSB0aGlzLl9jYWxjdWxhdGVDaHVua1NpemUoKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5zdGF0ZS5jaHVua1NpemUgJiYgdGhpcy5pZ3hGb3JPZltpXSAhPT0gdW5kZWZpbmVkOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCBpbnB1dCA9IHRoaXMuaWd4Rm9yT2ZbaV07XG4gICAgICAgICAgICAgICAgY29uc3QgZW1iZWRkZWRWaWV3ID0gdGhpcy5kYy5pbnN0YW5jZS5fdmNyLmNyZWF0ZUVtYmVkZGVkVmlldyhcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fdGVtcGxhdGUsXG4gICAgICAgICAgICAgICAgICAgIHsgJGltcGxpY2l0OiBpbnB1dCwgaW5kZXg6IHRoaXMuaWd4Rm9yT2YuaW5kZXhPZihpbnB1dCkgfVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgdGhpcy5fZW1iZWRkZWRWaWV3cy5wdXNoKGVtYmVkZGVkVmlldyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5pZ3hGb3JTY3JvbGxPcmllbnRhdGlvbiA9PT0gJ3ZlcnRpY2FsJykge1xuICAgICAgICAgICAgdGhpcy5kYy5pbnN0YW5jZS5fdmlld0NvbnRhaW5lci5lbGVtZW50Lm5hdGl2ZUVsZW1lbnQuc3R5bGUudG9wID0gJzBweCc7XG4gICAgICAgICAgICBjb25zdCBmYWN0b3J5OiBDb21wb25lbnRGYWN0b3J5PFZpcnR1YWxIZWxwZXJDb21wb25lbnQ+ID0gdGhpcy5yZXNvbHZlci5yZXNvbHZlQ29tcG9uZW50RmFjdG9yeShWaXJ0dWFsSGVscGVyQ29tcG9uZW50KTtcbiAgICAgICAgICAgIHRoaXMudmggPSB2Yy5jcmVhdGVDb21wb25lbnQoZmFjdG9yeSk7XG5cbiAgICAgICAgICAgIHRoaXMuX21heEhlaWdodCA9IHRoaXMuX2NhbGNNYXhCcm93c2VySGVpZ2h0KCk7XG4gICAgICAgICAgICB0aGlzLnZoLmluc3RhbmNlLmhlaWdodCA9IHRoaXMuaWd4Rm9yT2YgPyB0aGlzLl9jYWxjSGVpZ2h0KCkgOiAwO1xuICAgICAgICAgICAgdGhpcy5fem9uZS5ydW5PdXRzaWRlQW5ndWxhcigoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy52ZXJ0aWNhbFNjcm9sbEhhbmRsZXIgPSB0aGlzLnZlcnRpY2FsU2Nyb2xsSGFuZGxlci5iaW5kKHRoaXMpO1xuICAgICAgICAgICAgICAgIHRoaXMudmguaW5zdGFuY2UuZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIHRoaXMudmVydGljYWxTY3JvbGxIYW5kbGVyKTtcbiAgICAgICAgICAgICAgICB0aGlzLmRjLmluc3RhbmNlLnNjcm9sbENvbnRhaW5lciA9IHRoaXMudmguaW5zdGFuY2UuZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5pZ3hGb3JTY3JvbGxPcmllbnRhdGlvbiA9PT0gJ2hvcml6b250YWwnKSB7XG4gICAgICAgICAgICB0aGlzLmZ1bmMgPSAoZXZ0KSA9PiB7IHRoaXMub25IU2Nyb2xsKGV2dCk7IH07XG4gICAgICAgICAgICB0aGlzLmhTY3JvbGwgPSB0aGlzLmdldEVsZW1lbnQodmMsICdpZ3gtaG9yaXpvbnRhbC12aXJ0dWFsLWhlbHBlcicpO1xuICAgICAgICAgICAgaWYgKCF0aGlzLmhTY3JvbGwpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBodkZhY3Rvcnk6IENvbXBvbmVudEZhY3Rvcnk8SFZpcnR1YWxIZWxwZXJDb21wb25lbnQ+ID1cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXNvbHZlci5yZXNvbHZlQ29tcG9uZW50RmFjdG9yeShIVmlydHVhbEhlbHBlckNvbXBvbmVudCk7XG4gICAgICAgICAgICAgICAgdGhpcy5odmggPSB2Yy5jcmVhdGVDb21wb25lbnQoaHZGYWN0b3J5KTtcbiAgICAgICAgICAgICAgICB0aGlzLmh2aC5pbnN0YW5jZS53aWR0aCA9IHRvdGFsU2l6ZTtcbiAgICAgICAgICAgICAgICB0aGlzLmhTY3JvbGwgPSB0aGlzLmh2aC5pbnN0YW5jZS5lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQ7XG4gICAgICAgICAgICAgICAgdGhpcy5fem9uZS5ydW5PdXRzaWRlQW5ndWxhcigoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaHZoLmluc3RhbmNlLmVsZW1lbnRSZWYubmF0aXZlRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdzY3JvbGwnLCB0aGlzLmZ1bmMpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRjLmluc3RhbmNlLnNjcm9sbENvbnRhaW5lciA9IHRoaXMuaFNjcm9sbDtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fem9uZS5ydW5PdXRzaWRlQW5ndWxhcigoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaFNjcm9sbC5hZGRFdmVudExpc3RlbmVyKCdzY3JvbGwnLCB0aGlzLmZ1bmMpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRjLmluc3RhbmNlLnNjcm9sbENvbnRhaW5lciA9IHRoaXMuaFNjcm9sbDtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3Qgc2Nyb2xsT2Zmc2V0ID0gdGhpcy5oU2Nyb2xsLnNjcm9sbExlZnQgLVxuICAgICAgICAgICAgICAgICh0aGlzLnNpemVzQ2FjaGUgJiYgdGhpcy5zaXplc0NhY2hlLmxlbmd0aCA/IHRoaXMuc2l6ZXNDYWNoZVt0aGlzLnN0YXRlLnN0YXJ0SW5kZXhdIDogMCk7XG4gICAgICAgICAgICB0aGlzLmRjLmluc3RhbmNlLl92aWV3Q29udGFpbmVyLmVsZW1lbnQubmF0aXZlRWxlbWVudC5zdHlsZS5sZWZ0ID0gLXNjcm9sbE9mZnNldCArICdweCc7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHVibGljIG5nT25EZXN0cm95KCkge1xuICAgICAgICB0aGlzLnJlbW92ZVNjcm9sbEV2ZW50TGlzdGVuZXJzKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHB1YmxpYyBuZ09uQ2hhbmdlcyhjaGFuZ2VzOiBTaW1wbGVDaGFuZ2VzKTogdm9pZCB7XG4gICAgICAgIGNvbnN0IGZvck9mID0gJ2lneEZvck9mJztcbiAgICAgICAgaWYgKGZvck9mIGluIGNoYW5nZXMpIHtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gY2hhbmdlc1tmb3JPZl0uY3VycmVudFZhbHVlO1xuICAgICAgICAgICAgaWYgKCF0aGlzLl9kaWZmZXIgJiYgdmFsdWUpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9kaWZmZXIgPSB0aGlzLl9kaWZmZXJzLmZpbmQodmFsdWUpLmNyZWF0ZSh0aGlzLmlneEZvclRyYWNrQnkpO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgICAgICAgICAgICAgYENhbm5vdCBmaW5kIGEgZGlmZmVyIHN1cHBvcnRpbmcgb2JqZWN0IFwiJHt2YWx1ZX1cIiBvZiB0eXBlIFwiJHtnZXRUeXBlTmFtZUZvckRlYnVnZ2luZyh2YWx1ZSl9XCIuXG4gICAgICAgICAgICAgICAgICAgICBOZ0ZvciBvbmx5IHN1cHBvcnRzIGJpbmRpbmcgdG8gSXRlcmFibGVzIHN1Y2ggYXMgQXJyYXlzLmApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBkZWZhdWx0SXRlbVNpemUgPSAnaWd4Rm9ySXRlbVNpemUnO1xuICAgICAgICBpZiAoZGVmYXVsdEl0ZW1TaXplIGluIGNoYW5nZXMgJiYgIWNoYW5nZXNbZGVmYXVsdEl0ZW1TaXplXS5maXJzdENoYW5nZSAmJiB0aGlzLmlneEZvclNjcm9sbE9yaWVudGF0aW9uID09PSAndmVydGljYWwnKSB7XG4gICAgICAgICAgICAvLyBoYW5kbGUgZGVmYXVsdCBpdGVtIHNpemUgY2hhbmdlZC5cbiAgICAgICAgICAgIHRoaXMuaW5pdFNpemVzQ2FjaGUodGhpcy5pZ3hGb3JPZik7XG4gICAgICAgICAgICB0aGlzLl9hcHBseUNoYW5nZXMoKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjb250YWluZXJTaXplID0gJ2lneEZvckNvbnRhaW5lclNpemUnO1xuICAgICAgICBpZiAoY29udGFpbmVyU2l6ZSBpbiBjaGFuZ2VzICYmICFjaGFuZ2VzW2NvbnRhaW5lclNpemVdLmZpcnN0Q2hhbmdlICYmIHRoaXMuaWd4Rm9yT2YpIHtcbiAgICAgICAgICAgIHRoaXMuX3JlY2FsY09uQ29udGFpbmVyQ2hhbmdlKGNoYW5nZXMpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHB1YmxpYyBuZ0RvQ2hlY2soKTogdm9pZCB7XG4gICAgICAgIGlmICh0aGlzLl9kaWZmZXIpIHtcbiAgICAgICAgICAgIGNvbnN0IGNoYW5nZXMgPSB0aGlzLl9kaWZmZXIuZGlmZih0aGlzLmlneEZvck9mKTtcbiAgICAgICAgICAgIGlmIChjaGFuZ2VzKSB7XG4gICAgICAgICAgICAgICAgLy8gIHJlLWluaXQgY2FjaGUuXG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLmlneEZvck9mKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5fdXBkYXRlU2l6ZUNhY2hlKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fem9uZS5ydW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9hcHBseUNoYW5nZXMoKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jZHIubWFya0ZvckNoZWNrKCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3VwZGF0ZVNjcm9sbE9mZnNldCgpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm9uRGF0YUNoYW5nZWQuZW1pdCgpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2hpZnRzIHRoZSBzY3JvbGwgdGh1bWIgcG9zaXRpb24uXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIHRoaXMucGFyZW50VmlydERpci5hZGRTY3JvbGxUb3AoNSk7XG4gICAgICogYGBgXG4gICAgICogQHBhcmFtIGFkZFRvcCBuZWdhdGl2ZSB2YWx1ZSB0byBzY3JvbGwgdXAgYW5kIHBvc2l0aXZlIHRvIHNjcm9sbCBkb3duO1xuICAgICAqL1xuICAgIHB1YmxpYyBhZGRTY3JvbGxUb3AoYWRkVG9wOiBudW1iZXIpOiBib29sZWFuIHtcbiAgICAgICAgaWYgKGFkZFRvcCA9PT0gMCAmJiB0aGlzLmlneEZvclNjcm9sbE9yaWVudGF0aW9uID09PSAnaG9yaXpvbnRhbCcpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBvcmlnaW5hbFZpcnRTY3JvbGxUb3AgPSB0aGlzLl92aXJ0U2Nyb2xsVG9wO1xuICAgICAgICBjb25zdCBjb250YWluZXJTaXplID0gcGFyc2VJbnQodGhpcy5pZ3hGb3JDb250YWluZXJTaXplLCAxMCk7XG4gICAgICAgIGNvbnN0IG1heFZpcnRTY3JvbGxUb3AgPSB0aGlzLl92aXJ0SGVpZ2h0IC0gY29udGFpbmVyU2l6ZTtcblxuICAgICAgICB0aGlzLl9iU2Nyb2xsSW50ZXJuYWwgPSB0cnVlO1xuICAgICAgICB0aGlzLl92aXJ0U2Nyb2xsVG9wICs9IGFkZFRvcDtcbiAgICAgICAgdGhpcy5fdmlydFNjcm9sbFRvcCA9IHRoaXMuX3ZpcnRTY3JvbGxUb3AgPiAwID9cbiAgICAgICAgICAgICh0aGlzLl92aXJ0U2Nyb2xsVG9wIDwgbWF4VmlydFNjcm9sbFRvcCA/IHRoaXMuX3ZpcnRTY3JvbGxUb3AgOiBtYXhWaXJ0U2Nyb2xsVG9wKSA6XG4gICAgICAgICAgICAwO1xuXG4gICAgICAgIHRoaXMudmguaW5zdGFuY2UuZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LnNjcm9sbFRvcCArPSBhZGRUb3AgLyB0aGlzLl92aXJ0SGVpZ2h0UmF0aW87XG4gICAgICAgIGlmIChNYXRoLmFicyhhZGRUb3AgLyB0aGlzLl92aXJ0SGVpZ2h0UmF0aW8pIDwgMSkge1xuICAgICAgICAgICAgLy8gQWN0dWFsIHNjcm9sbCBkZWx0YSB0aGF0IHdhcyBhZGRlZCBpcyBzbWFsbGVyIHRoYW4gMSBhbmQgb25TY3JvbGwgaGFuZGxlciBkb2Vzbid0IHRyaWdnZXIgd2hlbiBzY3JvbGxpbmcgPCAxcHhcbiAgICAgICAgICAgIGNvbnN0IHNjcm9sbE9mZnNldCA9IHRoaXMuZml4ZWRVcGRhdGVBbGxFbGVtZW50cyh0aGlzLl92aXJ0U2Nyb2xsVG9wKTtcbiAgICAgICAgICAgIC8vIHNjcm9sbE9mZnNldCA9IHNjcm9sbE9mZnNldCAhPT0gcGFyc2VJbnQodGhpcy5pZ3hGb3JJdGVtU2l6ZSwgMTApID8gc2Nyb2xsT2Zmc2V0IDogMDtcbiAgICAgICAgICAgIHRoaXMuZGMuaW5zdGFuY2UuX3ZpZXdDb250YWluZXIuZWxlbWVudC5uYXRpdmVFbGVtZW50LnN0eWxlLnRvcCA9IC0oc2Nyb2xsT2Zmc2V0KSArICdweCc7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBjdXJTY3JvbGxUb3AgPSB0aGlzLnZoLmluc3RhbmNlLmVsZW1lbnRSZWYubmF0aXZlRWxlbWVudC5zY3JvbGxUb3A7XG4gICAgICAgIGNvbnN0IG1heFJlYWxTY3JvbGxUb3AgPSB0aGlzLnZoLmluc3RhbmNlLmVsZW1lbnRSZWYubmF0aXZlRWxlbWVudC5zY3JvbGxIZWlnaHQgLSBjb250YWluZXJTaXplO1xuICAgICAgICBpZiAoKHRoaXMuX3ZpcnRTY3JvbGxUb3AgPiAwICYmIGN1clNjcm9sbFRvcCA9PT0gMCkgfHxcbiAgICAgICAgICAgICh0aGlzLl92aXJ0U2Nyb2xsVG9wIDwgbWF4VmlydFNjcm9sbFRvcCAmJiBjdXJTY3JvbGxUb3AgPT09IG1heFJlYWxTY3JvbGxUb3ApKSB7XG4gICAgICAgICAgICAvLyBBY3R1YWwgc2Nyb2xsIHBvc2l0aW9uIGlzIGF0IHRoZSB0b3Agb3IgYm90dG9tLCBidXQgdmlydHVhbCBvbmUgaXMgbm90IGF0IHRoZSB0b3Agb3IgYm90dG9tICh0aGVyZSdzIG1vcmUgdG8gc2Nyb2xsKVxuICAgICAgICAgICAgLy8gUmVjYWxjdWxhdGUgYWN0dWFsIHNjcm9sbCBwb3NpdGlvbiBiYXNlZCBvbiB0aGUgdmlydHVhbCBzY3JvbGwuXG4gICAgICAgICAgICB0aGlzLnZoLmluc3RhbmNlLmVsZW1lbnRSZWYubmF0aXZlRWxlbWVudC5zY3JvbGxUb3AgPSB0aGlzLl92aXJ0U2Nyb2xsVG9wIC8gdGhpcy5fdmlydEhlaWdodFJhdGlvO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuX3ZpcnRTY3JvbGxUb3AgPT09IDAgJiYgY3VyU2Nyb2xsVG9wID4gMCkge1xuICAgICAgICAgICAgLy8gQWN0dWFsIHNjcm9sbCBwb3NpdGlvbiBpcyBub3QgYXQgdGhlIHRvcCwgYnV0IHZpcnR1YWwgc2Nyb2xsIGlzLiBKdXN0IHVwZGF0ZSB0aGUgYWN0dWFsIHNjcm9sbFxuICAgICAgICAgICAgdGhpcy52aC5pbnN0YW5jZS5lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQuc2Nyb2xsVG9wID0gMDtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLl92aXJ0U2Nyb2xsVG9wID09PSBtYXhWaXJ0U2Nyb2xsVG9wICYmIGN1clNjcm9sbFRvcCA8IG1heFJlYWxTY3JvbGxUb3ApIHtcbiAgICAgICAgICAgIC8vIEFjdHVhbCBzY3JvbGwgcG9zaXRpb24gaXMgbm90IGF0IHRoZSBib3R0b20sIGJ1dCB2aXJ0dWFsIHNjcm9sbCBpcy4gSnVzdCB1cGRhdGUgdGhlIGFjdWFsIHNjcm9sbFxuICAgICAgICAgICAgdGhpcy52aC5pbnN0YW5jZS5lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQuc2Nyb2xsVG9wID0gbWF4UmVhbFNjcm9sbFRvcDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fdmlydFNjcm9sbFRvcCAhPT0gb3JpZ2luYWxWaXJ0U2Nyb2xsVG9wO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNjcm9sbHMgdG8gdGhlIHNwZWNpZmllZCBpbmRleC5cbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogdGhpcy5wYXJlbnRWaXJ0RGlyLnNjcm9sbFRvKDUpO1xuICAgICAqIGBgYFxuICAgICAqIEBwYXJhbSBpbmRleFxuICAgICAqL1xuICAgIHB1YmxpYyBzY3JvbGxUbyhpbmRleCkge1xuICAgICAgICBpZiAoaW5kZXggPCAwIHx8IGluZGV4ID4gKHRoaXMuaXNSZW1vdGUgPyB0aGlzLnRvdGFsSXRlbUNvdW50IDogdGhpcy5pZ3hGb3JPZi5sZW5ndGgpIC0gMSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNvbnRhaW5lclNpemUgPSBwYXJzZUludCh0aGlzLmlneEZvckNvbnRhaW5lclNpemUsIDEwKTtcbiAgICAgICAgY29uc3Qgc2NyID0gdGhpcy5pZ3hGb3JTY3JvbGxPcmllbnRhdGlvbiA9PT0gJ2hvcml6b250YWwnID9cbiAgICAgICAgICAgIHRoaXMuaFNjcm9sbC5zY3JvbGxMZWZ0IDogdGhpcy52aC5pbnN0YW5jZS5lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQuc2Nyb2xsVG9wO1xuICAgICAgICBjb25zdCBpc1ByZXZJdGVtID0gaW5kZXggPCB0aGlzLnN0YXRlLnN0YXJ0SW5kZXggfHwgc2NyID4gdGhpcy5zaXplc0NhY2hlW2luZGV4XTtcbiAgICAgICAgbGV0IG5leHRTY3JvbGwgPSBpc1ByZXZJdGVtID8gdGhpcy5zaXplc0NhY2hlW2luZGV4XSA6IHRoaXMuc2l6ZXNDYWNoZVtpbmRleCArIDFdIC0gY29udGFpbmVyU2l6ZTtcbiAgICAgICAgaWYgKG5leHRTY3JvbGwgPCAwKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuaWd4Rm9yU2Nyb2xsT3JpZW50YXRpb24gPT09ICdob3Jpem9udGFsJykge1xuICAgICAgICAgICAgdGhpcy5oU2Nyb2xsLnNjcm9sbExlZnQgPSBuZXh0U2Nyb2xsO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgbWF4VmlydFNjcm9sbFRvcCA9IHRoaXMuX3ZpcnRIZWlnaHQgLSBjb250YWluZXJTaXplO1xuICAgICAgICAgICAgaWYgKG5leHRTY3JvbGwgPiBtYXhWaXJ0U2Nyb2xsVG9wKSB7XG4gICAgICAgICAgICAgICAgbmV4dFNjcm9sbCA9IG1heFZpcnRTY3JvbGxUb3A7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9iU2Nyb2xsSW50ZXJuYWwgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5fdmlydFNjcm9sbFRvcCA9IG5leHRTY3JvbGw7XG4gICAgICAgICAgICB0aGlzLnZoLmluc3RhbmNlLmVsZW1lbnRSZWYubmF0aXZlRWxlbWVudC5zY3JvbGxUb3AgPSB0aGlzLl92aXJ0U2Nyb2xsVG9wIC8gdGhpcy5fdmlydEhlaWdodFJhdGlvO1xuICAgICAgICAgICAgdGhpcy5fYWRqdXN0VG9JbmRleCA9ICFpc1ByZXZJdGVtID8gaW5kZXggOiBudWxsO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2Nyb2xscyBieSBvbmUgaXRlbSBpbnRvIHRoZSBhcHByb3ByaWF0ZSBuZXh0IGRpcmVjdGlvbi5cbiAgICAgKiBGb3IgXCJob3Jpem9udGFsXCIgb3JpZW50YXRpb24gdGhhdCB3aWxsIGJlIHRoZSByaWdodCBjb2x1bW4gYW5kIGZvciBcInZlcnRpY2FsXCIgdGhhdCBpcyB0aGUgbG93ZXIgcm93LlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiB0aGlzLnBhcmVudFZpcnREaXIuc2Nyb2xsTmV4dCgpO1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIHB1YmxpYyBzY3JvbGxOZXh0KCkge1xuICAgICAgICBjb25zdCBzY3IgPSBNYXRoLmNlaWwodGhpcy5pZ3hGb3JTY3JvbGxPcmllbnRhdGlvbiA9PT0gJ2hvcml6b250YWwnID9cbiAgICAgICAgICAgIHRoaXMuaFNjcm9sbC5zY3JvbGxMZWZ0IDpcbiAgICAgICAgICAgIHRoaXMudmguaW5zdGFuY2UuZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LnNjcm9sbFRvcCk7XG4gICAgICAgIGNvbnN0IGVuZEluZGV4ID0gdGhpcy5nZXRJbmRleEF0KFxuICAgICAgICAgICAgc2NyICsgcGFyc2VJbnQodGhpcy5pZ3hGb3JDb250YWluZXJTaXplLCAxMCksXG4gICAgICAgICAgICB0aGlzLnNpemVzQ2FjaGUsXG4gICAgICAgICAgICAwXG4gICAgICAgICk7XG4gICAgICAgIHRoaXMuc2Nyb2xsVG8oZW5kSW5kZXgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNjcm9sbHMgYnkgb25lIGl0ZW0gaW50byB0aGUgYXBwcm9wcmlhdGUgcHJldmlvdXMgZGlyZWN0aW9uLlxuICAgICAqIEZvciBcImhvcml6b250YWxcIiBvcmllbnRhdGlvbiB0aGF0IHdpbGwgYmUgdGhlIGxlZnQgY29sdW1uIGFuZCBmb3IgXCJ2ZXJ0aWNhbFwiIHRoYXQgaXMgdGhlIHVwcGVyIHJvdy5cbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogdGhpcy5wYXJlbnRWaXJ0RGlyLnNjcm9sbFByZXYoKTtcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBwdWJsaWMgc2Nyb2xsUHJldigpIHtcbiAgICAgICAgdGhpcy5zY3JvbGxUbyh0aGlzLnN0YXRlLnN0YXJ0SW5kZXggLSAxKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTY3JvbGxzIGJ5IG9uZSBwYWdlIGludG8gdGhlIGFwcHJvcHJpYXRlIG5leHQgZGlyZWN0aW9uLlxuICAgICAqIEZvciBcImhvcml6b250YWxcIiBvcmllbnRhdGlvbiB0aGF0IHdpbGwgYmUgb25lIHZpZXcgdG8gdGhlIHJpZ2h0IGFuZCBmb3IgXCJ2ZXJ0aWNhbFwiIHRoYXQgaXMgb25lIHZpZXcgdG8gdGhlIGJvdHRvbS5cbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogdGhpcy5wYXJlbnRWaXJ0RGlyLnNjcm9sbE5leHRQYWdlKCk7XG4gICAgICogYGBgXG4gICAgICovXG4gICAgcHVibGljIHNjcm9sbE5leHRQYWdlKCkge1xuICAgICAgICBpZiAodGhpcy5pZ3hGb3JTY3JvbGxPcmllbnRhdGlvbiA9PT0gJ2hvcml6b250YWwnKSB7XG4gICAgICAgICAgICB0aGlzLmh2aC5pbnN0YW5jZS5lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQuc2Nyb2xsTGVmdCArPSBwYXJzZUludCh0aGlzLmlneEZvckNvbnRhaW5lclNpemUsIDEwKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuYWRkU2Nyb2xsVG9wKHBhcnNlSW50KHRoaXMuaWd4Rm9yQ29udGFpbmVyU2l6ZSwgMTApKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNjcm9sbHMgYnkgb25lIHBhZ2UgaW50byB0aGUgYXBwcm9wcmlhdGUgcHJldmlvdXMgZGlyZWN0aW9uLlxuICAgICAqIEZvciBcImhvcml6b250YWxcIiBvcmllbnRhdGlvbiB0aGF0IHdpbGwgYmUgb25lIHZpZXcgdG8gdGhlIGxlZnQgYW5kIGZvciBcInZlcnRpY2FsXCIgdGhhdCBpcyBvbmUgdmlldyB0byB0aGUgdG9wLlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiB0aGlzLnBhcmVudFZpcnREaXIuc2Nyb2xsUHJldlBhZ2UoKTtcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBwdWJsaWMgc2Nyb2xsUHJldlBhZ2UoKSB7XG4gICAgICAgIGlmICh0aGlzLmlneEZvclNjcm9sbE9yaWVudGF0aW9uID09PSAnaG9yaXpvbnRhbCcpIHtcbiAgICAgICAgICAgIHRoaXMuaHZoLmluc3RhbmNlLmVsZW1lbnRSZWYubmF0aXZlRWxlbWVudC5zY3JvbGxMZWZ0IC09IHBhcnNlSW50KHRoaXMuaWd4Rm9yQ29udGFpbmVyU2l6ZSwgMTApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgY29udGFpbmVyU2l6ZSA9IChwYXJzZUludCh0aGlzLmlneEZvckNvbnRhaW5lclNpemUsIDEwKSk7XG4gICAgICAgICAgICB0aGlzLmFkZFNjcm9sbFRvcCgtY29udGFpbmVyU2l6ZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHVibGljIGdldENvbHVtblNjcm9sbExlZnQoY29sSW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2l6ZXNDYWNoZVtjb2xJbmRleF07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIHJlZmVyZW5jZSB0byB0aGUgdmVydGljYWwgc2Nyb2xsYmFyIERPTSBlbGVtZW50LlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiB0aGlzLnBhcmVudFZpcnREaXIuZ2V0VmVydGljYWxTY3JvbGwoKTtcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0VmVydGljYWxTY3JvbGwoKSB7XG4gICAgICAgIGlmICh0aGlzLnZoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy52aC5pbnN0YW5jZS5lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgdG90YWwgbnVtYmVyIG9mIGl0ZW1zIHRoYXQgYXJlIGZ1bGx5IHZpc2libGUuXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIHRoaXMucGFyZW50VmlydERpci5nZXRJdGVtQ291bnRJblZpZXcoKTtcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0SXRlbUNvdW50SW5WaWV3KCkge1xuICAgICAgICBjb25zdCBwb3NpdGlvbiA9IHRoaXMuaWd4Rm9yU2Nyb2xsT3JpZW50YXRpb24gPT09ICdob3Jpem9udGFsJyA/XG4gICAgICAgICAgICB0aGlzLmhTY3JvbGwuc2Nyb2xsTGVmdCA6XG4gICAgICAgICAgICB0aGlzLnZoLmluc3RhbmNlLmVsZW1lbnRSZWYubmF0aXZlRWxlbWVudC5zY3JvbGxUb3A7XG4gICAgICAgIGxldCBzdGFydEluZGV4ID0gdGhpcy5nZXRJbmRleEF0KFxuICAgICAgICAgICAgcG9zaXRpb24sXG4gICAgICAgICAgICB0aGlzLnNpemVzQ2FjaGUsXG4gICAgICAgICAgICAwXG4gICAgICAgICk7XG4gICAgICAgIGlmIChwb3NpdGlvbiAtIHRoaXMuc2l6ZXNDYWNoZVtzdGFydEluZGV4XSA+IDApIHtcbiAgICAgICAgICAgIC8vIGZpc3J0IGl0ZW0gaXMgbm90IGZ1bGx5IGluIHZpZXdcbiAgICAgICAgICAgIHN0YXJ0SW5kZXgrKztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBlbmRJbmRleCA9IHRoaXMuZ2V0SW5kZXhBdChcbiAgICAgICAgICAgIHBvc2l0aW9uICsgcGFyc2VJbnQodGhpcy5pZ3hGb3JDb250YWluZXJTaXplLCAxMCksXG4gICAgICAgICAgICB0aGlzLnNpemVzQ2FjaGUsXG4gICAgICAgICAgICAwXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybiBlbmRJbmRleCAtIHN0YXJ0SW5kZXg7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIHJlZmVyZW5jZSB0byB0aGUgaG9yaXpvbnRhbCBzY3JvbGxiYXIgRE9NIGVsZW1lbnQuXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIHRoaXMucGFyZW50VmlydERpci5nZXRIb3Jpem9udGFsU2Nyb2xsKCk7XG4gICAgICogYGBgXG4gICAgICovXG4gICAgcHVibGljIGdldEhvcml6b250YWxTY3JvbGwoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldEVsZW1lbnQodGhpcy5fdmlld0NvbnRhaW5lciwgJ2lneC1ob3Jpem9udGFsLXZpcnR1YWwtaGVscGVyJykgfHwgdGhpcy5oU2Nyb2xsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHNpemUgb2YgdGhlIGVsZW1lbnQgYXQgdGhlIHNwZWNpZmllZCBpbmRleC5cbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogdGhpcy5wYXJlbnRWaXJ0RGlyLmdldFNpemVBdCgxKTtcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0U2l6ZUF0KGluZGV4OiBudW1iZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2l6ZXNDYWNoZVtpbmRleCArIDFdIC0gdGhpcy5zaXplc0NhY2hlW2luZGV4XTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBzY3JvbGwgb2Zmc2V0IG9mIHRoZSBlbGVtZW50IGF0IHRoZSBzcGVjaWZpZWQgaW5kZXguXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIHRoaXMucGFyZW50VmlydERpci5nZXRTY3JvbGxGb3JJbmRleCgxKTtcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0U2Nyb2xsRm9ySW5kZXgoaW5kZXg6IG51bWJlciwgYm90dG9tPzogYm9vbGVhbikge1xuICAgICAgICBjb25zdCBjb250YWluZXJTaXplID0gcGFyc2VJbnQodGhpcy5pZ3hGb3JDb250YWluZXJTaXplLCAxMCk7XG4gICAgICAgIGNvbnN0IHNjcm9sbCA9IGJvdHRvbSA/IE1hdGgubWF4KDAsIHRoaXMuc2l6ZXNDYWNoZVtpbmRleCArIDFdIC0gY29udGFpbmVyU2l6ZSkgOiB0aGlzLnNpemVzQ2FjaGVbaW5kZXhdO1xuICAgICAgICByZXR1cm4gc2Nyb2xsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKiBGdW5jdGlvbiB0aGF0IGlzIGNhbGxlZCB3aGVuIHNjcm9sbGluZyB2ZXJ0aWNhbGx5XG4gICAgICovXG4gICAgcHJvdGVjdGVkIG9uU2Nyb2xsKGV2ZW50KSB7XG4gICAgICAgIC8qIGluIGNlcnRhaW4gc2l0dWF0aW9ucyB0aGlzIG1heSBiZSBjYWxsZWQgd2hlbiBubyBzY3JvbGxiYXIgaXMgdmlzaWJsZSAqL1xuICAgICAgICBpZiAoIXBhcnNlSW50KHRoaXMudmguaW5zdGFuY2UuZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LnN0eWxlLmhlaWdodCwgMTApKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBjb250YWluZXJTaXplID0gcGFyc2VJbnQodGhpcy5pZ3hGb3JDb250YWluZXJTaXplLCAxMCk7XG4gICAgICAgIGNvbnN0IG1heFJlYWxTY3JvbGxUb3AgPSBldmVudC50YXJnZXQuY2hpbGRyZW5bMF0uc2Nyb2xsSGVpZ2h0IC0gY29udGFpbmVyU2l6ZTtcbiAgICAgICAgY29uc3QgcmVhbFBlcmNlbnRTY3JvbGxlZCA9IGV2ZW50LnRhcmdldC5zY3JvbGxUb3AgLyBtYXhSZWFsU2Nyb2xsVG9wO1xuICAgICAgICBpZiAoIXRoaXMuX2JTY3JvbGxJbnRlcm5hbCkge1xuICAgICAgICAgICAgY29uc3QgbWF4VmlydFNjcm9sbFRvcCA9IHRoaXMuX3ZpcnRIZWlnaHQgLSBjb250YWluZXJTaXplO1xuICAgICAgICAgICAgdGhpcy5fdmlydFNjcm9sbFRvcCA9IHJlYWxQZXJjZW50U2Nyb2xsZWQgKiBtYXhWaXJ0U2Nyb2xsVG9wO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fYlNjcm9sbEludGVybmFsID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcHJldlN0YXJ0SW5kZXggPSB0aGlzLnN0YXRlLnN0YXJ0SW5kZXg7XG4gICAgICAgIGNvbnN0IHNjcm9sbE9mZnNldCA9IHRoaXMuZml4ZWRVcGRhdGVBbGxFbGVtZW50cyh0aGlzLl92aXJ0U2Nyb2xsVG9wKTtcblxuICAgICAgICB0aGlzLmRjLmluc3RhbmNlLl92aWV3Q29udGFpbmVyLmVsZW1lbnQubmF0aXZlRWxlbWVudC5zdHlsZS50b3AgPSAtKHNjcm9sbE9mZnNldCkgKyAncHgnO1xuXG4gICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgICAgICAgICAvLyBjaGVjayBpZiBoZWlnaHQvd2lkdGggaGFzIGNoYW5nZXMgaW4gdmlld3MuXG4gICAgICAgICAgICB0aGlzLnJlY2FsY1VwZGF0ZVNpemVzKCk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmRjLmNoYW5nZURldGVjdG9yUmVmLmRldGVjdENoYW5nZXMoKTtcbiAgICAgICAgaWYgKHByZXZTdGFydEluZGV4ICE9PSB0aGlzLnN0YXRlLnN0YXJ0SW5kZXgpIHtcbiAgICAgICAgICAgIHRoaXMub25DaHVua0xvYWQuZW1pdCh0aGlzLnN0YXRlKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKiBGdW5jdGlvbiB0aGF0IHJlY2FjdWxhdGVzIGFuZCB1cGRhdGVzIGNhY2hlIHNpemVzLlxuICAgICAqL1xuICAgIHB1YmxpYyByZWNhbGNVcGRhdGVTaXplcygpIHtcbiAgICAgICAgY29uc3QgZGltZW5zaW9uID0gdGhpcy5pZ3hGb3JTY3JvbGxPcmllbnRhdGlvbiA9PT0gJ2hvcml6b250YWwnID9cbiAgICAgICAgdGhpcy5pZ3hGb3JTaXplUHJvcE5hbWUgOiAnaGVpZ2h0JztcbiAgICAgICAgY29uc3QgZGlmZnMgPSBbXTtcbiAgICAgICAgbGV0IHRvdGFsRGlmZiA9IDA7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5fZW1iZWRkZWRWaWV3cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgdmlldyA9IHRoaXMuX2VtYmVkZGVkVmlld3NbaV07XG4gICAgICAgICAgICBjb25zdCByTm9kZSA9IHZpZXcucm9vdE5vZGVzLmZpbmQoKG5vZGUpID0+IG5vZGUubm9kZVR5cGUgPT09IE5vZGUuRUxFTUVOVF9OT0RFKTtcbiAgICAgICAgICAgIGlmIChyTm9kZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGggPSByTm9kZS5vZmZzZXRIZWlnaHQgPyByTm9kZS5vZmZzZXRIZWlnaHQgOiBwYXJzZUludCh0aGlzLmlneEZvckl0ZW1TaXplLCAxMCk7XG4gICAgICAgICAgICAgICAgY29uc3QgaW5kZXggPSB0aGlzLnN0YXRlLnN0YXJ0SW5kZXggKyBpO1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5pc1JlbW90ZSAmJiAhdGhpcy5pZ3hGb3JPZltpbmRleF0pIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IG9sZFZhbCA9IGRpbWVuc2lvbiA9PT0gJ2hlaWdodCcgPyB0aGlzLmhlaWdodENhY2hlW2luZGV4XSA6IHRoaXMuaWd4Rm9yT2ZbaW5kZXhdW2RpbWVuc2lvbl07XG4gICAgICAgICAgICAgICAgY29uc3QgbmV3VmFsID0gZGltZW5zaW9uID09PSAnaGVpZ2h0JyA/IGggOiByTm9kZS5jbGllbnRXaWR0aDtcbiAgICAgICAgICAgICAgICBpZiAoZGltZW5zaW9uID09PSAnaGVpZ2h0Jykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmhlaWdodENhY2hlW2luZGV4XSA9IG5ld1ZhbDtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmlneEZvck9mW2luZGV4XVtkaW1lbnNpb25dID0gbmV3VmFsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBjdXJyRGlmZiA9IG5ld1ZhbCAtIG9sZFZhbDtcbiAgICAgICAgICAgICAgICBkaWZmcy5wdXNoKGN1cnJEaWZmKTtcbiAgICAgICAgICAgICAgICB0b3RhbERpZmYgKz0gY3VyckRpZmY7XG4gICAgICAgICAgICAgICAgdGhpcy5zaXplc0NhY2hlW2luZGV4ICsgMV0gKz0gdG90YWxEaWZmO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIHVwZGF0ZSBjYWNoZVxuICAgICAgICBpZiAoTWF0aC5hYnModG90YWxEaWZmKSA+IDApIHtcbiAgICAgICAgICAgIGZvciAobGV0IGogPSB0aGlzLnN0YXRlLnN0YXJ0SW5kZXggKyB0aGlzLnN0YXRlLmNodW5rU2l6ZSArIDE7IGogPCB0aGlzLnNpemVzQ2FjaGUubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNpemVzQ2FjaGVbal0gKz0gdG90YWxEaWZmO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyB1cGRhdGUgc2NyQmFyIGhlaWdodHMvd2lkdGhzXG4gICAgICAgICAgICBpZiAodGhpcy5pZ3hGb3JTY3JvbGxPcmllbnRhdGlvbiA9PT0gJ2hvcml6b250YWwnKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdG90YWxXaWR0aCA9IHBhcnNlSW50KHRoaXMuaFNjcm9sbC5jaGlsZHJlblswXS5zdHlsZS53aWR0aCwgMTApICsgdG90YWxEaWZmO1xuICAgICAgICAgICAgICAgIHRoaXMuaFNjcm9sbC5jaGlsZHJlblswXS5zdHlsZS53aWR0aCA9IHRvdGFsV2lkdGggKyAncHgnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVkdWNlciA9IChhY2MsIHZhbCkgPT4gYWNjICsgdmFsO1xuICAgICAgICAgICAgaWYgKHRoaXMuaWd4Rm9yU2Nyb2xsT3JpZW50YXRpb24gPT09ICd2ZXJ0aWNhbCcpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBzY3JUb0JvdHRvbSA9IHRoaXMuX2lzU2Nyb2xsZWRUb0JvdHRvbSAmJiAhdGhpcy5kYy5pbnN0YW5jZS5ub3RWaXJ0dWFsO1xuICAgICAgICAgICAgICAgIGNvbnN0IGhTdW0gPSB0aGlzLmhlaWdodENhY2hlLnJlZHVjZShyZWR1Y2VyKTtcbiAgICAgICAgICAgICAgICBpZiAoaFN1bSA+IHRoaXMuX21heEhlaWdodCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl92aXJ0SGVpZ2h0UmF0aW8gPSBoU3VtIC8gdGhpcy5fbWF4SGVpZ2h0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLnZoLmluc3RhbmNlLmhlaWdodCA9IE1hdGgubWluKHRoaXMudmguaW5zdGFuY2UuaGVpZ2h0ICsgdG90YWxEaWZmLCB0aGlzLl9tYXhIZWlnaHQpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3ZpcnRIZWlnaHQgPSBoU3VtO1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy52aC5pbnN0YW5jZS5kZXN0cm95ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy52aC5pbnN0YW5jZS5jZHIuZGV0ZWN0Q2hhbmdlcygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoc2NyVG9Cb3R0b20gJiYgIXRoaXMuX2lzQXRCb3R0b21JbmRleCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjb250YWluZXJTaXplID0gcGFyc2VJbnQodGhpcy5pZ3hGb3JDb250YWluZXJTaXplLCAxMCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHNjcm9sbE9mZnNldCA9IHRoaXMuZml4ZWRVcGRhdGVBbGxFbGVtZW50cyh0aGlzLl92aXJ0SGVpZ2h0IC0gY29udGFpbmVyU2l6ZSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGMuaW5zdGFuY2UuX3ZpZXdDb250YWluZXIuZWxlbWVudC5uYXRpdmVFbGVtZW50LnN0eWxlLnRvcCA9IC0oc2Nyb2xsT2Zmc2V0KSArICdweCc7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2FkanVzdFRvSW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gaW4gY2FzZSBzY3JvbGxlZCB0byBzcGVjaWZpYyBpbmRleCB3aGVyZSBhZnRlciBzY3JvbGwgaGVpZ2h0cyBhcmUgY2hhbmdlZFxuICAgICAgICAgICAgICAgICAgICAvLyBuZWVkIHRvIGFkanVzdCB0aGUgb2Zmc2V0cyBzbyB0aGF0IGl0ZW0gaXMgbGFzdCBpbiB2aWV3LlxuICAgICAgICAgICAgICAgICAgICBjb25zdCB1cGRhdGVzVG9JbmRleCA9IHRoaXMuX2FkanVzdFRvSW5kZXggLSB0aGlzLnN0YXRlLnN0YXJ0SW5kZXggKyAxO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBzdW1EaWZmcyA9IGRpZmZzLnNsaWNlKDAsIHVwZGF0ZXNUb0luZGV4KS5yZWR1Y2UocmVkdWNlcik7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGN1cnJPZmZzZXQgPSBwYXJzZUludCh0aGlzLmRjLmluc3RhbmNlLl92aWV3Q29udGFpbmVyLmVsZW1lbnQubmF0aXZlRWxlbWVudC5zdHlsZS50b3AsIDEwKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kYy5pbnN0YW5jZS5fdmlld0NvbnRhaW5lci5lbGVtZW50Lm5hdGl2ZUVsZW1lbnQuc3R5bGUudG9wID0gKGN1cnJPZmZzZXQgLSBzdW1EaWZmcykgKyAncHgnO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9hZGp1c3RUb0luZGV4ID0gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHJvdGVjdGVkIGZpeGVkVXBkYXRlQWxsRWxlbWVudHMoaW5TY3JvbGxUb3A6IG51bWJlcik6IG51bWJlciB7XG4gICAgICAgIGNvbnN0IGNvdW50ID0gdGhpcy5pc1JlbW90ZSA/IHRoaXMudG90YWxJdGVtQ291bnQgOiB0aGlzLmlneEZvck9mLmxlbmd0aDtcbiAgICAgICAgbGV0IG5ld1N0YXJ0ID0gdGhpcy5nZXRJbmRleEF0KFxuICAgICAgICAgICAgaW5TY3JvbGxUb3AsXG4gICAgICAgICAgICB0aGlzLnNpemVzQ2FjaGUsXG4gICAgICAgICAgICAwXG4gICAgICAgICk7XG4gICAgICAgIGlmIChuZXdTdGFydCArIHRoaXMuc3RhdGUuY2h1bmtTaXplID4gY291bnQpIHtcbiAgICAgICAgICAgIG5ld1N0YXJ0ID0gY291bnQgLSB0aGlzLnN0YXRlLmNodW5rU2l6ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwcmV2U3RhcnQgPSB0aGlzLnN0YXRlLnN0YXJ0SW5kZXg7XG4gICAgICAgIGNvbnN0IGRpZmYgPSBuZXdTdGFydCAtIHRoaXMuc3RhdGUuc3RhcnRJbmRleDtcbiAgICAgICAgdGhpcy5zdGF0ZS5zdGFydEluZGV4ID0gbmV3U3RhcnQ7XG4gICAgICAgIGlmIChkaWZmKSB7XG4gICAgICAgICAgICB0aGlzLm9uQ2h1bmtQcmVsb2FkLmVtaXQodGhpcy5zdGF0ZSk7XG4gICAgICAgICAgICBpZiAoIXRoaXMuaXNSZW1vdGUpIHtcbiAgICAgICAgICAgICAgICAvKnJlY2FsY3VsYXRlIGFuZCBhcHBseSBwYWdlIHNpemUuKi9cbiAgICAgICAgICAgICAgICBpZiAoZGlmZiA+IDAgJiYgZGlmZiA8PSB0aGlzLk1BWF9QRVJGX1NDUk9MTF9ESUZGKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubW92ZUFwcGx5U2Nyb2xsTmV4dChwcmV2U3RhcnQpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZGlmZiA8IDAgJiYgTWF0aC5hYnMoZGlmZikgPD0gdGhpcy5NQVhfUEVSRl9TQ1JPTExfRElGRikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm1vdmVBcHBseVNjcm9sbFByZXYocHJldlN0YXJ0KTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmZpeGVkQXBwbHlTY3JvbGwoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGluU2Nyb2xsVG9wIC0gdGhpcy5zaXplc0NhY2hlW3RoaXMuc3RhdGUuc3RhcnRJbmRleF07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqIFRoZSBmdW5jdGlvbiBhcHBsaWVzIGFuIG9wdGltaXplZCBzdGF0ZSBjaGFuZ2UgZm9yIHNjcm9sbGluZyBkb3duL3JpZ2h0IGVtcGxveWluZyBjb250ZXh0IGNoYW5nZSB3aXRoIHZpZXcgcmVhcnJhbmdlbWVudFxuICAgICAqL1xuICAgIHByb3RlY3RlZCBtb3ZlQXBwbHlTY3JvbGxOZXh0KHByZXZJbmRleDogbnVtYmVyKTogdm9pZCB7XG4gICAgICAgIGNvbnN0IHN0YXJ0ID0gcHJldkluZGV4ICsgdGhpcy5zdGF0ZS5jaHVua1NpemU7XG4gICAgICAgIGZvciAobGV0IGkgPSBzdGFydDsgaSA8IHN0YXJ0ICsgdGhpcy5zdGF0ZS5zdGFydEluZGV4IC0gcHJldkluZGV4ICYmIHRoaXMuaWd4Rm9yT2ZbaV0gIT09IHVuZGVmaW5lZDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBpbnB1dCA9IHRoaXMuaWd4Rm9yT2ZbaV07XG4gICAgICAgICAgICBjb25zdCBlbWJWaWV3ID0gdGhpcy5fZW1iZWRkZWRWaWV3cy5zaGlmdCgpO1xuICAgICAgICAgICAgY29uc3QgY250eCA9IGVtYlZpZXcuY29udGV4dDtcbiAgICAgICAgICAgIGNudHguJGltcGxpY2l0ID0gaW5wdXQ7XG4gICAgICAgICAgICBjbnR4LmluZGV4ID0gdGhpcy5nZXRDb250ZXh0SW5kZXgoaW5wdXQpO1xuICAgICAgICAgICAgY29uc3QgdmlldzogVmlld1JlZiA9IHRoaXMuZGMuaW5zdGFuY2UuX3Zjci5kZXRhY2goMCk7XG4gICAgICAgICAgICB0aGlzLmRjLmluc3RhbmNlLl92Y3IuaW5zZXJ0KHZpZXcpO1xuICAgICAgICAgICAgdGhpcy5fZW1iZWRkZWRWaWV3cy5wdXNoKGVtYlZpZXcpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqIFRoZSBmdW5jdGlvbiBhcHBsaWVzIGFuIG9wdGltaXplZCBzdGF0ZSBjaGFuZ2UgZm9yIHNjcm9sbGluZyB1cC9sZWZ0IGVtcGxveWluZyBjb250ZXh0IGNoYW5nZSB3aXRoIHZpZXcgcmVhcnJhbmdlbWVudFxuICAgICAqL1xuICAgIHByb3RlY3RlZCBtb3ZlQXBwbHlTY3JvbGxQcmV2KHByZXZJbmRleDogbnVtYmVyKTogdm9pZCB7XG4gICAgICAgIGZvciAobGV0IGkgPSBwcmV2SW5kZXggLSAxOyBpID49IHRoaXMuc3RhdGUuc3RhcnRJbmRleCAgJiYgdGhpcy5pZ3hGb3JPZltpXSAhPT0gdW5kZWZpbmVkOyBpLS0pIHtcbiAgICAgICAgICAgIGNvbnN0IGlucHV0ID0gdGhpcy5pZ3hGb3JPZltpXTtcbiAgICAgICAgICAgIGNvbnN0IGVtYlZpZXcgPSB0aGlzLl9lbWJlZGRlZFZpZXdzLnBvcCgpO1xuICAgICAgICAgICAgY29uc3QgY250eCA9IGVtYlZpZXcuY29udGV4dDtcbiAgICAgICAgICAgIGNudHguJGltcGxpY2l0ID0gaW5wdXQ7XG4gICAgICAgICAgICBjbnR4LmluZGV4ID0gdGhpcy5nZXRDb250ZXh0SW5kZXgoaW5wdXQpO1xuICAgICAgICAgICAgY29uc3QgdmlldzogVmlld1JlZiA9IHRoaXMuZGMuaW5zdGFuY2UuX3Zjci5kZXRhY2godGhpcy5kYy5pbnN0YW5jZS5fdmNyLmxlbmd0aCAtIDEpO1xuICAgICAgICAgICAgdGhpcy5kYy5pbnN0YW5jZS5fdmNyLmluc2VydCh2aWV3LCAwKTtcbiAgICAgICAgICAgIHRoaXMuX2VtYmVkZGVkVmlld3MudW5zaGlmdChlbWJWaWV3KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAqL1xuICAgIHByb3RlY3RlZCBnZXRDb250ZXh0SW5kZXgoaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNSZW1vdGUgPyB0aGlzLnN0YXRlLnN0YXJ0SW5kZXggKyB0aGlzLmlneEZvck9mLmluZGV4T2YoaW5wdXQpIDogdGhpcy5pZ3hGb3JPZi5pbmRleE9mKGlucHV0KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICogVGhlIGZ1bmN0aW9uIGFwcGxpZXMgYW4gb3B0aW1pemVkIHN0YXRlIGNoYW5nZSB0aHJvdWdoIGNvbnRleHQgY2hhbmdlIGZvciBlYWNoIHZpZXdcbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgZml4ZWRBcHBseVNjcm9sbCgpOiB2b2lkIHtcbiAgICAgICAgbGV0IGogPSAwO1xuICAgICAgICBjb25zdCBlbmRJbmRleCA9IHRoaXMuc3RhdGUuc3RhcnRJbmRleCArIHRoaXMuc3RhdGUuY2h1bmtTaXplO1xuICAgICAgICBmb3IgKGxldCBpID0gdGhpcy5zdGF0ZS5zdGFydEluZGV4OyBpIDwgZW5kSW5kZXggJiYgdGhpcy5pZ3hGb3JPZltpXSAhPT0gdW5kZWZpbmVkOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGlucHV0ID0gdGhpcy5pZ3hGb3JPZltpXTtcbiAgICAgICAgICAgIGNvbnN0IGVtYlZpZXcgPSB0aGlzLl9lbWJlZGRlZFZpZXdzW2orK107XG4gICAgICAgICAgICBjb25zdCBjbnR4ID0gKGVtYlZpZXcgYXMgRW1iZWRkZWRWaWV3UmVmPGFueT4pLmNvbnRleHQ7XG4gICAgICAgICAgICBjbnR4LiRpbXBsaWNpdCA9IGlucHV0O1xuICAgICAgICAgICAgY250eC5pbmRleCA9IHRoaXMuZ2V0Q29udGV4dEluZGV4KGlucHV0KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKiBGdW5jdGlvbiB0aGF0IGlzIGNhbGxlZCB3aGVuIHNjcm9sbGluZyBob3Jpem9udGFsbHlcbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgb25IU2Nyb2xsKGV2ZW50KSB7XG4gICAgICAgIC8qIGluIGNlcnRhaW4gc2l0dWF0aW9ucyB0aGlzIG1heSBiZSBjYWxsZWQgd2hlbiBubyBzY3JvbGxiYXIgaXMgdmlzaWJsZSAqL1xuICAgICAgICBpZiAoIXBhcnNlSW50KHRoaXMuaFNjcm9sbC5jaGlsZHJlblswXS5zdHlsZS53aWR0aCwgMTApKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY3VyU2Nyb2xsTGVmdCA9IGV2ZW50LnRhcmdldC5zY3JvbGxMZWZ0O1xuICAgICAgICBjb25zdCBwcmV2U3RhcnRJbmRleCA9IHRoaXMuc3RhdGUuc3RhcnRJbmRleDtcbiAgICAgICAgLy8gVXBkYXRpbmcgaG9yaXpvbnRhbCBjaHVua3NcbiAgICAgICAgY29uc3Qgc2Nyb2xsT2Zmc2V0ID0gdGhpcy5maXhlZFVwZGF0ZUFsbEVsZW1lbnRzKGN1clNjcm9sbExlZnQpO1xuICAgICAgICB0aGlzLmRjLmluc3RhbmNlLl92aWV3Q29udGFpbmVyLmVsZW1lbnQubmF0aXZlRWxlbWVudC5zdHlsZS5sZWZ0ID0gLXNjcm9sbE9mZnNldCArICdweCc7XG5cbiAgICAgICAgdGhpcy5kYy5jaGFuZ2VEZXRlY3RvclJlZi5kZXRlY3RDaGFuZ2VzKCk7XG4gICAgICAgIGlmIChwcmV2U3RhcnRJbmRleCAhPT0gdGhpcy5zdGF0ZS5zdGFydEluZGV4KSB7XG4gICAgICAgICAgICB0aGlzLm9uQ2h1bmtMb2FkLmVtaXQodGhpcy5zdGF0ZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBmdW5jdGlvbiB1c2VkIHRvIHRyYWNrIGNoYW5nZXMgaW4gdGhlIGl0ZW1zIGNvbGxlY3Rpb24uXG4gICAgICogQnkgZGVmYXVsdCB0aGUgb2JqZWN0IHJlZmVyZW5jZXMgYXJlIGNvbXBhcmVkLiBIb3dldmVyIHRoaXMgY2FuIGJlIG9wdGltaXplZCBpZiB5b3UgaGF2ZSB1bmlxdWUgaWRlbnRpZmllclxuICAgICAqIHZhbHVlIHRoYXQgY2FuIGJlIHVzZWQgZm9yIHRoZSBjb21wYXJpc29uIGluc3RlYWQgb2YgdGhlIG9iamVjdCByZWYgb3IgaWYgeW91IGhhdmUgc29tZSBvdGhlciBwcm9wZXJ0eSB2YWx1ZXNcbiAgICAgKiBpbiB0aGUgaXRlbSBvYmplY3QgdGhhdCBzaG91bGQgYmUgdHJhY2tlZCBmb3IgY2hhbmdlcy5cbiAgICAgKiBUaGlzIG9wdGlvbiBpcyBzaW1pbGFyIHRvIG5nRm9yVHJhY2tCeS5cbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogY29uc3QgdHJhY2tGdW5jID0gdGhpcy5wYXJlbnRWaXJ0RGlyLmlneEZvclRyYWNrQnk7XG4gICAgICogYGBgXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBnZXQgaWd4Rm9yVHJhY2tCeSgpOiBUcmFja0J5RnVuY3Rpb248VD4geyByZXR1cm4gdGhpcy5fdHJhY2tCeUZuOyB9XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBmdW5jdGlvbiB1c2VkIHRvIHRyYWNrIGNoYW5nZXMgaW4gdGhlIGl0ZW1zIGNvbGxlY3Rpb24uXG4gICAgICogVGhpcyBmdW5jdGlvbiBjYW4gYmUgc2V0IGluIHNjZW5hcmlvcyB3aGVyZSB5b3Ugd2FudCB0byBvcHRpbWl6ZSBvclxuICAgICAqIGN1c3RvbWl6ZSB0aGUgdHJhY2tpbmcgb2YgY2hhbmdlcyBmb3IgdGhlIGl0ZW1zIGluIHRoZSBjb2xsZWN0aW9uLlxuICAgICAqIFRoZSBpZ3hGb3JUcmFja0J5IGZ1bmN0aW9uIHRha2VzIHRoZSBpbmRleCBhbmQgdGhlIGN1cnJlbnQgaXRlbSBhcyBhcmd1bWVudHMgYW5kIG5lZWRzIHRvIHJldHVybiB0aGUgdW5pcXVlIGlkZW50aWZpZXIgZm9yIHRoaXMgaXRlbS5cbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogdGhpcy5wYXJlbnRWaXJ0RGlyLmlneEZvclRyYWNrQnkgPSAoaW5kZXgsIGl0ZW0pID0+IHtcbiAgICAgKiAgICAgIHJldHVybiBpdGVtLmlkICsgaXRlbS53aWR0aDtcbiAgICAgKiB9O1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIHNldCBpZ3hGb3JUcmFja0J5KGZuOiBUcmFja0J5RnVuY3Rpb248VD4pIHsgdGhpcy5fdHJhY2tCeUZuID0gZm47IH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgX2FwcGx5Q2hhbmdlcygpIHtcbiAgICAgICAgY29uc3QgcHJldkNodW5rU2l6ZSA9IHRoaXMuc3RhdGUuY2h1bmtTaXplO1xuICAgICAgICB0aGlzLmFwcGx5Q2h1bmtTaXplQ2hhbmdlKCk7XG4gICAgICAgIHRoaXMuX3JlY2FsY1Njcm9sbEJhclNpemUoKTtcbiAgICAgICAgaWYgKHRoaXMuaWd4Rm9yT2YgJiYgdGhpcy5pZ3hGb3JPZi5sZW5ndGggJiYgdGhpcy5kYykge1xuICAgICAgICAgICAgY29uc3QgZW1iZWRkZWRWaWV3Q29weSA9IE9iamVjdC5hc3NpZ24oW10sIHRoaXMuX2VtYmVkZGVkVmlld3MpO1xuICAgICAgICAgICAgbGV0IHN0YXJ0SW5kZXggPSB0aGlzLnN0YXRlLnN0YXJ0SW5kZXg7XG4gICAgICAgICAgICBsZXQgZW5kSW5kZXggPSB0aGlzLnN0YXRlLmNodW5rU2l6ZSArIHRoaXMuc3RhdGUuc3RhcnRJbmRleDtcbiAgICAgICAgICAgIGlmICh0aGlzLmlzUmVtb3RlKSB7XG4gICAgICAgICAgICAgICAgc3RhcnRJbmRleCA9IDA7XG4gICAgICAgICAgICAgICAgZW5kSW5kZXggPSB0aGlzLmlneEZvck9mLmxlbmd0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAobGV0IGkgPSBzdGFydEluZGV4OyBpIDwgZW5kSW5kZXggJiYgdGhpcy5pZ3hGb3JPZltpXSAhPT0gdW5kZWZpbmVkOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCBpbnB1dCA9IHRoaXMuaWd4Rm9yT2ZbaV07XG4gICAgICAgICAgICAgICAgY29uc3QgZW1iVmlldyA9IGVtYmVkZGVkVmlld0NvcHkuc2hpZnQoKTtcbiAgICAgICAgICAgICAgICBjb25zdCBjbnR4ID0gKGVtYlZpZXcgYXMgRW1iZWRkZWRWaWV3UmVmPGFueT4pLmNvbnRleHQ7XG4gICAgICAgICAgICAgICAgY250eC4kaW1wbGljaXQgPSBpbnB1dDtcbiAgICAgICAgICAgICAgICBjbnR4LmluZGV4ID0gdGhpcy5nZXRDb250ZXh0SW5kZXgoaW5wdXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5kYy5jaGFuZ2VEZXRlY3RvclJlZi5kZXRlY3RDaGFuZ2VzKCk7XG4gICAgICAgICAgICBpZiAocHJldkNodW5rU2l6ZSAhPT0gdGhpcy5zdGF0ZS5jaHVua1NpemUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm9uQ2h1bmtMb2FkLmVtaXQodGhpcy5zdGF0ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5pZ3hGb3JTY3JvbGxPcmllbnRhdGlvbiA9PT0gJ3ZlcnRpY2FsJykge1xuICAgICAgICAgICAgICAgIHRoaXMucmVjYWxjVXBkYXRlU2l6ZXMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgX2NhbGNNYXhCcm93c2VySGVpZ2h0KCk6IG51bWJlciB7XG4gICAgICAgIGNvbnN0IGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICBjb25zdCBzdHlsZSA9IGRpdi5zdHlsZTtcbiAgICAgICAgc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuICAgICAgICBzdHlsZS50b3AgPSAnOTk5OTk5OTk5OTk5OTk5OXB4JztcbiAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChkaXYpO1xuICAgICAgICBjb25zdCBzaXplID0gTWF0aC5hYnMoZGl2LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpWyd0b3AnXSk7XG4gICAgICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQoZGl2KTtcbiAgICAgICAgcmV0dXJuIHNpemU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqIFJlY2FsY3VsYXRlcyB0aGUgY2h1bmtTaXplIGJhc2VkIG9uIGN1cnJlbnQgc3RhcnRJbmRleCBhbmQgcmV0dXJucyB0aGUgbmV3IHNpemUuXG4gICAgICogVGhpcyBzaG91bGQgYmUgY2FsbGVkIGFmdGVyIHRoaXMuc3RhdGUuc3RhcnRJbmRleCBpcyB1cGRhdGVkLCBub3QgYmVmb3JlLlxuICAgICAqL1xuICAgIHByb3RlY3RlZCBfY2FsY3VsYXRlQ2h1bmtTaXplKCk6IG51bWJlciB7XG4gICAgICAgIGxldCBjaHVua1NpemUgPSAwO1xuICAgICAgICBpZiAodGhpcy5pZ3hGb3JDb250YWluZXJTaXplICE9PSBudWxsICYmIHRoaXMuaWd4Rm9yQ29udGFpbmVyU2l6ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuc2l6ZXNDYWNoZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuaW5pdFNpemVzQ2FjaGUodGhpcy5pZ3hGb3JPZik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjaHVua1NpemUgPSB0aGlzLl9jYWxjTWF4Q2h1bmtTaXplKCk7XG4gICAgICAgICAgICBpZiAodGhpcy5pZ3hGb3JPZiAmJiBjaHVua1NpemUgPiB0aGlzLmlneEZvck9mLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGNodW5rU2l6ZSA9IHRoaXMuaWd4Rm9yT2YubGVuZ3RoO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKHRoaXMuaWd4Rm9yT2YpIHtcbiAgICAgICAgICAgICAgICBjaHVua1NpemUgPSB0aGlzLmlneEZvck9mLmxlbmd0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2h1bmtTaXplO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgZ2V0RWxlbWVudCh2aWV3cmVmLCBub2RlTmFtZSkge1xuICAgICAgICBjb25zdCBlbGVtID0gdmlld3JlZi5lbGVtZW50Lm5hdGl2ZUVsZW1lbnQucGFyZW50Tm9kZS5nZXRFbGVtZW50c0J5VGFnTmFtZShub2RlTmFtZSk7XG4gICAgICAgIHJldHVybiBlbGVtLmxlbmd0aCA+IDAgPyBlbGVtWzBdIDogbnVsbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHJvdGVjdGVkIGluaXRTaXplc0NhY2hlKGl0ZW1zOiBhbnlbXSk6IG51bWJlciB7XG4gICAgICAgIGxldCB0b3RhbFNpemUgPSAwO1xuICAgICAgICBsZXQgc2l6ZSA9IDA7XG4gICAgICAgIGNvbnN0IGRpbWVuc2lvbiA9IHRoaXMuaWd4Rm9yU2Nyb2xsT3JpZW50YXRpb24gPT09ICdob3Jpem9udGFsJyA/XG4gICAgICAgICAgICB0aGlzLmlneEZvclNpemVQcm9wTmFtZSA6ICdoZWlnaHQnO1xuICAgICAgICBsZXQgaSA9IDA7XG4gICAgICAgIHRoaXMuc2l6ZXNDYWNoZSA9IFtdO1xuICAgICAgICB0aGlzLmhlaWdodENhY2hlID0gW107XG4gICAgICAgIHRoaXMuc2l6ZXNDYWNoZS5wdXNoKDApO1xuICAgICAgICBjb25zdCBjb3VudCA9IHRoaXMuaXNSZW1vdGUgPyB0aGlzLnRvdGFsSXRlbUNvdW50IDogaXRlbXMubGVuZ3RoO1xuICAgICAgICBmb3IgKGk7IGkgPCBjb3VudDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoZGltZW5zaW9uID09PSAnaGVpZ2h0Jykge1xuICAgICAgICAgICAgICAgIC8vIGNvbHNbaV1bZGltZW5zaW9uXSA9IHBhcnNlSW50KHRoaXMuaWd4Rm9ySXRlbVNpemUsIDEwKSB8fCAwO1xuICAgICAgICAgICAgICAgIHNpemUgPSBwYXJzZUludCh0aGlzLmlneEZvckl0ZW1TaXplLCAxMCkgfHwgMDtcbiAgICAgICAgICAgICAgICB0aGlzLmhlaWdodENhY2hlLnB1c2goc2l6ZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHNpemUgPSB0aGlzLl9nZXRJdGVtU2l6ZShpdGVtc1tpXSwgZGltZW5zaW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRvdGFsU2l6ZSArPSBzaXplO1xuICAgICAgICAgICAgdGhpcy5zaXplc0NhY2hlLnB1c2godG90YWxTaXplKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdG90YWxTaXplO1xuICAgIH1cblxuICAgIHByb3RlY3RlZCBfdXBkYXRlU2l6ZUNhY2hlKCkge1xuICAgICAgICBpZiAodGhpcy5pZ3hGb3JTY3JvbGxPcmllbnRhdGlvbiA9PT0gJ2hvcml6b250YWwnKSB7XG4gICAgICAgICAgICB0aGlzLmluaXRTaXplc0NhY2hlKHRoaXMuaWd4Rm9yT2YpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNjciA9IHRoaXMudmguaW5zdGFuY2UuZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50O1xuXG4gICAgICAgIGNvbnN0IG9sZEhlaWdodCA9IHRoaXMuaGVpZ2h0Q2FjaGUubGVuZ3RoID4gMCA/IHRoaXMuaGVpZ2h0Q2FjaGUucmVkdWNlKChhY2MsIHZhbCkgPT4gYWNjICsgdmFsKSA6IDA7XG4gICAgICAgIGNvbnN0IG5ld0hlaWdodCA9ICB0aGlzLmluaXRTaXplc0NhY2hlKHRoaXMuaWd4Rm9yT2YpO1xuXG4gICAgICAgIGNvbnN0IGRpZmYgPSBvbGRIZWlnaHQgLSBuZXdIZWlnaHQ7XG5cbiAgICAgICAgLy8gaWYgZGF0YSBoYXMgYmVlbiBjaGFuZ2VkIHdoaWxlIGNvbnRhaW5lciBpcyBzY3JvbGxlZFxuICAgICAgICAvLyBzaG91bGQgdXBkYXRlIHNjcm9sbCB0b3AvbGVmdCBhY2NvcmRpbmcgdG8gY2hhbmdlIHNvIHRoYXQgc2FtZSBzdGFydEluZGV4IGlzIGluIHZpZXdcbiAgICAgICAgaWYgKE1hdGguYWJzKGRpZmYpID4gMCAmJiBzY3Iuc2Nyb2xsVG9wID4gMCkge1xuICAgICAgICAgICAgdGhpcy5yZWNhbGNVcGRhdGVTaXplcygpO1xuICAgICAgICAgICAgY29uc3Qgb2Zmc2V0ID0gcGFyc2VJbnQodGhpcy5kYy5pbnN0YW5jZS5fdmlld0NvbnRhaW5lci5lbGVtZW50Lm5hdGl2ZUVsZW1lbnQuc3R5bGUudG9wLCAxMCk7XG4gICAgICAgICAgICBzY3Iuc2Nyb2xsVG9wID0gdGhpcy5zaXplc0NhY2hlW3RoaXMuc3RhdGUuc3RhcnRJbmRleF0gLSBvZmZzZXQ7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHJvdGVjdGVkIF9jYWxjTWF4Q2h1bmtTaXplKCk6IG51bWJlciB7XG4gICAgICAgIGxldCBpID0gMDtcbiAgICAgICAgbGV0IGxlbmd0aCA9IDA7XG4gICAgICAgIGxldCBtYXhMZW5ndGggPSAwO1xuICAgICAgICBjb25zdCBhcnIgPSBbXTtcbiAgICAgICAgbGV0IHN1bSA9IDA7XG4gICAgICAgIGNvbnN0IGF2YWlsYWJsZVNpemUgPSBwYXJzZUludCh0aGlzLmlneEZvckNvbnRhaW5lclNpemUsIDEwKTtcbiAgICAgICAgaWYgKCFhdmFpbGFibGVTaXplKSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBkaW1lbnNpb24gPSB0aGlzLmlneEZvclNjcm9sbE9yaWVudGF0aW9uID09PSAnaG9yaXpvbnRhbCcgP1xuICAgICAgICB0aGlzLmlneEZvclNpemVQcm9wTmFtZSA6ICdoZWlnaHQnO1xuICAgICAgICBjb25zdCByZWR1Y2VyID0gKGFjY3VtdWxhdG9yLCBjdXJyZW50SXRlbSkgPT4gYWNjdW11bGF0b3IgKyB0aGlzLl9nZXRJdGVtU2l6ZShjdXJyZW50SXRlbSwgZGltZW5zaW9uKTtcbiAgICAgICAgZm9yIChpOyBpIDwgdGhpcy5pZ3hGb3JPZi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IGl0ZW0gPSB0aGlzLmlneEZvck9mW2ldO1xuICAgICAgICAgICAgaWYgKGRpbWVuc2lvbiA9PT0gJ2hlaWdodCcpIHtcbiAgICAgICAgICAgICAgICBpdGVtID0geyB2YWx1ZTogdGhpcy5pZ3hGb3JPZltpXSwgaGVpZ2h0OiB0aGlzLmhlaWdodENhY2hlW2ldIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBzaXplID0gZGltZW5zaW9uID09PSAnaGVpZ2h0JyA/XG4gICAgICAgICAgICAgICAgdGhpcy5oZWlnaHRDYWNoZVtpXSA6XG4gICAgICAgICAgICAgICAgdGhpcy5fZ2V0SXRlbVNpemUoaXRlbSwgZGltZW5zaW9uKTtcbiAgICAgICAgICAgIHN1bSA9IGFyci5yZWR1Y2UocmVkdWNlciwgc2l6ZSk7XG4gICAgICAgICAgICBpZiAoc3VtIDwgYXZhaWxhYmxlU2l6ZSkge1xuICAgICAgICAgICAgICAgIGFyci5wdXNoKGl0ZW0pO1xuICAgICAgICAgICAgICAgIGxlbmd0aCA9IGFyci5sZW5ndGg7XG4gICAgICAgICAgICAgICAgaWYgKGkgPT09IHRoaXMuaWd4Rm9yT2YubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgICAgICAgICAvLyByZWFjaGVkIGVuZCB3aXRob3V0IGV4Y2VlZGluZ1xuICAgICAgICAgICAgICAgICAgICAvLyBpbmNsdWRlIHByZXYgaXRlbXMgdW50aWwgc2l6ZSBpcyBmaWxsZWQgb3IgZmlyc3QgaXRlbSBpcyByZWFjaGVkLlxuICAgICAgICAgICAgICAgICAgICBsZXQgY3VySXRlbSA9IGRpbWVuc2lvbiA9PT0gJ2hlaWdodCcgPyBhcnJbMF0udmFsdWUgOiBhcnJbMF07XG4gICAgICAgICAgICAgICAgICAgIGxldCBwcmV2SW5kZXggPSB0aGlzLmlneEZvck9mLmluZGV4T2YoY3VySXRlbSkgLSAxO1xuICAgICAgICAgICAgICAgICAgICB3aGlsZSAocHJldkluZGV4ID49IDAgJiYgc3VtIDw9IGF2YWlsYWJsZVNpemUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1ckl0ZW0gPSBkaW1lbnNpb24gPT09ICdoZWlnaHQnID8gYXJyWzBdLnZhbHVlIDogYXJyWzBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJldkluZGV4ID0gdGhpcy5pZ3hGb3JPZi5pbmRleE9mKGN1ckl0ZW0pIC0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHByZXZJdGVtID0gdGhpcy5pZ3hGb3JPZltwcmV2SW5kZXhdO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcHJldlNpemUgPSBkaW1lbnNpb24gPT09ICdoZWlnaHQnID9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmhlaWdodENhY2hlW3ByZXZJbmRleF0gOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlSW50KHByZXZJdGVtW2RpbWVuc2lvbl0sIDEwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN1bSA9IGFyci5yZWR1Y2UocmVkdWNlciwgcHJldlNpemUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYXJyLnVuc2hpZnQocHJldkl0ZW0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGVuZ3RoID0gYXJyLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgYXJyLnB1c2goaXRlbSk7XG4gICAgICAgICAgICAgICAgbGVuZ3RoID0gYXJyLmxlbmd0aCArIDE7XG4gICAgICAgICAgICAgICAgYXJyLnNoaWZ0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobGVuZ3RoID4gbWF4TGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgbWF4TGVuZ3RoID0gbGVuZ3RoO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtYXhMZW5ndGg7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHByb3RlY3RlZCBnZXRJbmRleEF0KGxlZnQsIHNldCwgaW5kZXgpIHtcbiAgICAgICAgbGV0IHN0YXJ0ID0gMDtcbiAgICAgICAgbGV0IGVuZCA9IHNldC5sZW5ndGggLSAxO1xuICAgICAgICBpZiAobGVmdCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUgKHN0YXJ0IDw9IGVuZCkge1xuICAgICAgICAgICAgY29uc3QgbWlkSWR4ID0gTWF0aC5mbG9vcigoc3RhcnQgKyBlbmQpIC8gMik7XG4gICAgICAgICAgICBjb25zdCBtaWRMZWZ0ID0gc2V0W21pZElkeF07XG4gICAgICAgICAgICBjb25zdCBjbXAgPSBsZWZ0IC0gbWlkTGVmdDtcbiAgICAgICAgICAgIGlmIChjbXAgPiAwKSB7XG4gICAgICAgICAgICAgICAgc3RhcnQgPSBtaWRJZHggKyAxO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChjbXAgPCAwKSB7XG4gICAgICAgICAgICAgICAgZW5kID0gbWlkSWR4IC0gMTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1pZElkeDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZW5kO1xuICAgIH1cblxuICAgIHByb3RlY3RlZCBfcmVjYWxjU2Nyb2xsQmFyU2l6ZSgpIHtcbiAgICAgICAgY29uc3QgY291bnQgPSB0aGlzLmlzUmVtb3RlID8gdGhpcy50b3RhbEl0ZW1Db3VudCA6ICh0aGlzLmlneEZvck9mID8gdGhpcy5pZ3hGb3JPZi5sZW5ndGggOiAwKTtcbiAgICAgICAgdGhpcy5kYy5pbnN0YW5jZS5ub3RWaXJ0dWFsID0gISh0aGlzLmlneEZvckNvbnRhaW5lclNpemUgJiYgdGhpcy5kYyAmJiB0aGlzLnN0YXRlLmNodW5rU2l6ZSA8IGNvdW50KTtcbiAgICAgICAgaWYgKHRoaXMuaWd4Rm9yU2Nyb2xsT3JpZW50YXRpb24gPT09ICdob3Jpem9udGFsJykge1xuICAgICAgICAgICAgY29uc3QgdG90YWxXaWR0aCA9IHRoaXMuaWd4Rm9yQ29udGFpbmVyU2l6ZSA/IHRoaXMuaW5pdFNpemVzQ2FjaGUodGhpcy5pZ3hGb3JPZikgOiAwO1xuICAgICAgICAgICAgdGhpcy5oU2Nyb2xsLnN0eWxlLndpZHRoID0gdGhpcy5pZ3hGb3JDb250YWluZXJTaXplICsgJ3B4JztcbiAgICAgICAgICAgIHRoaXMuaFNjcm9sbC5jaGlsZHJlblswXS5zdHlsZS53aWR0aCA9IHRvdGFsV2lkdGggKyAncHgnO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmlneEZvclNjcm9sbE9yaWVudGF0aW9uID09PSAndmVydGljYWwnKSB7XG4gICAgICAgICAgICB0aGlzLnZoLmluc3RhbmNlLmVsZW1lbnRSZWYubmF0aXZlRWxlbWVudC5zdHlsZS5oZWlnaHQgPSBwYXJzZUludCh0aGlzLmlneEZvckNvbnRhaW5lclNpemUsIDEwKSArICdweCc7XG4gICAgICAgICAgICB0aGlzLnZoLmluc3RhbmNlLmhlaWdodCA9IHRoaXMuX2NhbGNIZWlnaHQoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHByb3RlY3RlZCBfY2FsY0hlaWdodCgpOiBudW1iZXIge1xuICAgICAgICBsZXQgaGVpZ2h0O1xuICAgICAgICBpZiAodGhpcy5oZWlnaHRDYWNoZSkge1xuICAgICAgICAgICAgaGVpZ2h0ID0gdGhpcy5oZWlnaHRDYWNoZS5yZWR1Y2UoKGFjYywgdmFsKSA9PiBhY2MgKyB2YWwsIDApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaGVpZ2h0ID0gdGhpcy5pbml0U2l6ZXNDYWNoZSh0aGlzLmlneEZvck9mKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl92aXJ0SGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgICBpZiAoaGVpZ2h0ID4gdGhpcy5fbWF4SGVpZ2h0KSB7XG4gICAgICAgICAgICB0aGlzLl92aXJ0SGVpZ2h0UmF0aW8gPSBoZWlnaHQgLyB0aGlzLl9tYXhIZWlnaHQ7XG4gICAgICAgICAgICBoZWlnaHQgPSB0aGlzLl9tYXhIZWlnaHQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGhlaWdodDtcbiAgICB9XG5cbiAgICBwcm90ZWN0ZWQgX3JlY2FsY09uQ29udGFpbmVyQ2hhbmdlKGNoYW5nZXM6IFNpbXBsZUNoYW5nZXMpIHtcbiAgICAgICAgdGhpcy5kYy5pbnN0YW5jZS5fdmlld0NvbnRhaW5lci5lbGVtZW50Lm5hdGl2ZUVsZW1lbnQuc3R5bGUudG9wID0gJzBweCc7XG4gICAgICAgIHRoaXMuZGMuaW5zdGFuY2UuX3ZpZXdDb250YWluZXIuZWxlbWVudC5uYXRpdmVFbGVtZW50LnN0eWxlLmxlZnQgPSAnMHB4JztcbiAgICAgICAgY29uc3QgcHJldkNodW5rU2l6ZSA9IHRoaXMuc3RhdGUuY2h1bmtTaXplO1xuICAgICAgICB0aGlzLmFwcGx5Q2h1bmtTaXplQ2hhbmdlKCk7XG4gICAgICAgIHRoaXMuX3JlY2FsY1Njcm9sbEJhclNpemUoKTtcbiAgICAgICAgaWYgKHByZXZDaHVua1NpemUgIT09IHRoaXMuc3RhdGUuY2h1bmtTaXplKSB7XG4gICAgICAgICAgICB0aGlzLm9uQ2h1bmtMb2FkLmVtaXQodGhpcy5zdGF0ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuc2l6ZXNDYWNoZSAmJiB0aGlzLmhTY3JvbGwgJiYgdGhpcy5oU2Nyb2xsLnNjcm9sbExlZnQgIT09IDApIHtcbiAgICAgICAgICAgIC8vIFVwZGF0aW5nIGhvcml6b250YWwgY2h1bmtzIGFuZCBvZmZzZXRzIGJhc2VkIG9uIHRoZSBuZXcgc2Nyb2xsTGVmdFxuICAgICAgICAgICAgY29uc3Qgc2Nyb2xsT2Zmc2V0ID0gdGhpcy5maXhlZFVwZGF0ZUFsbEVsZW1lbnRzKHRoaXMuaFNjcm9sbC5zY3JvbGxMZWZ0KTtcbiAgICAgICAgICAgIHRoaXMuZGMuaW5zdGFuY2UuX3ZpZXdDb250YWluZXIuZWxlbWVudC5uYXRpdmVFbGVtZW50LnN0eWxlLmxlZnQgPSAtc2Nyb2xsT2Zmc2V0ICsgJ3B4JztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKiBSZW1vdmVzIGFuIGVsZW1lbmV0IGZyb20gdGhlIGVtYmVkZGVkIHZpZXdzIGFuZCB1cGRhdGVzIGNodW5rU2l6ZS5cbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgcmVtb3ZlTGFzdEVsZW0oKSB7XG4gICAgICAgIGNvbnN0IG9sZEVsZW0gPSB0aGlzLl9lbWJlZGRlZFZpZXdzLnBvcCgpO1xuICAgICAgICB0aGlzLm9uQmVmb3JlVmlld0Rlc3Ryb3llZC5lbWl0KG9sZEVsZW0pO1xuICAgICAgICBvbGRFbGVtLmRlc3Ryb3koKTtcblxuICAgICAgICB0aGlzLnN0YXRlLmNodW5rU2l6ZS0tO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKiBJZiB0aGVyZSBleGlzdHMgYW4gZWxlbWVudCB0aGF0IHdlIGNhbiBjcmVhdGUgZW1iZWRkZWQgdmlldyBmb3IgY3JlYXRlcyBpdCwgYXBwZW5kcyBpdCBhbmQgdXBkYXRlcyBjaHVua1NpemVcbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgYWRkTGFzdEVsZW0oKSB7XG4gICAgICAgIGxldCBlbGVtSW5kZXggPSB0aGlzLnN0YXRlLnN0YXJ0SW5kZXggKyB0aGlzLnN0YXRlLmNodW5rU2l6ZTtcbiAgICAgICAgaWYgKCF0aGlzLmlzUmVtb3RlICYmICF0aGlzLmlneEZvck9mKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZWxlbUluZGV4ID49IHRoaXMuaWd4Rm9yT2YubGVuZ3RoKSB7XG4gICAgICAgICAgICBlbGVtSW5kZXggPSB0aGlzLmlneEZvck9mLmxlbmd0aCAtIHRoaXMuc3RhdGUuY2h1bmtTaXplO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGlucHV0ID0gdGhpcy5pZ3hGb3JPZltlbGVtSW5kZXhdO1xuICAgICAgICBjb25zdCBlbWJlZGRlZFZpZXcgPSB0aGlzLmRjLmluc3RhbmNlLl92Y3IuY3JlYXRlRW1iZWRkZWRWaWV3KFxuICAgICAgICAgICAgdGhpcy5fdGVtcGxhdGUsXG4gICAgICAgICAgICB7ICRpbXBsaWNpdDogaW5wdXQsIGluZGV4OiBlbGVtSW5kZXggfVxuICAgICAgICApO1xuXG4gICAgICAgIHRoaXMuX2VtYmVkZGVkVmlld3MucHVzaChlbWJlZGRlZFZpZXcpO1xuICAgICAgICB0aGlzLnN0YXRlLmNodW5rU2l6ZSsrO1xuXG4gICAgICAgIHRoaXMuX3pvbmUucnVuKCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuY2RyLm1hcmtGb3JDaGVjaygpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZWNhbGN1bGF0ZXMgY2h1bmtTaXplIGFuZCBhZGRzL3JlbW92ZXMgZWxlbWVudHMgaWYgbmVlZCBkdWUgdG8gdGhlIGNoYW5nZS5cbiAgICAgKiB0aGlzLnN0YXRlLmNodW5rU2l6ZSBpcyB1cGRhdGVkIGluIEBhZGRMYXN0RWxlbSgpIG9yIEByZW1vdmVMYXN0RWxlbSgpXG4gICAgICovXG4gICAgcHJvdGVjdGVkIGFwcGx5Q2h1bmtTaXplQ2hhbmdlKCkge1xuICAgICAgICBjb25zdCBjaHVua1NpemUgPSB0aGlzLmlzUmVtb3RlID8gKHRoaXMuaWd4Rm9yT2YgPyB0aGlzLmlneEZvck9mLmxlbmd0aCA6IDApIDogdGhpcy5fY2FsY3VsYXRlQ2h1bmtTaXplKCk7XG4gICAgICAgIGlmIChjaHVua1NpemUgPiB0aGlzLnN0YXRlLmNodW5rU2l6ZSkge1xuICAgICAgICAgICAgY29uc3QgZGlmZiA9IGNodW5rU2l6ZSAtIHRoaXMuc3RhdGUuY2h1bmtTaXplO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkaWZmOyBpKyspIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFkZExhc3RFbGVtKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoY2h1bmtTaXplIDwgdGhpcy5zdGF0ZS5jaHVua1NpemUpIHtcbiAgICAgICAgICAgIGNvbnN0IGRpZmYgPSB0aGlzLnN0YXRlLmNodW5rU2l6ZSAtIGNodW5rU2l6ZTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGlmZjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZW1vdmVMYXN0RWxlbSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHJvdGVjdGVkIF91cGRhdGVTY3JvbGxPZmZzZXQoKSB7XG4gICAgICAgIGlmICh0aGlzLmlneEZvclNjcm9sbE9yaWVudGF0aW9uID09PSAnaG9yaXpvbnRhbCcpIHtcbiAgICAgICAgICAgIHRoaXMuX3VwZGF0ZUhTY3JvbGxPZmZzZXQoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX3VwZGF0ZVZTY3JvbGxPZmZzZXQoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBwcml2YXRlIF91cGRhdGVWU2Nyb2xsT2Zmc2V0KCkge1xuICAgICAgICBsZXQgc2Nyb2xsT2Zmc2V0ID0gMDtcbiAgICAgICAgY29uc3QgdlNjcm9sbCA9IHRoaXMudmguaW5zdGFuY2UuZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50O1xuICAgICAgICBzY3JvbGxPZmZzZXQgPSB2U2Nyb2xsICYmIHBhcnNlSW50KHZTY3JvbGwuc3R5bGUuaGVpZ2h0LCAxMCkgP1xuICAgICAgICAgICAgdlNjcm9sbC5zY3JvbGxUb3AgLSB0aGlzLnNpemVzQ2FjaGVbdGhpcy5zdGF0ZS5zdGFydEluZGV4XSA6IDA7XG4gICAgICAgIHRoaXMuZGMuaW5zdGFuY2UuX3ZpZXdDb250YWluZXIuZWxlbWVudC5uYXRpdmVFbGVtZW50LnN0eWxlLnRvcCA9IC0oc2Nyb2xsT2Zmc2V0KSArICdweCc7XG4gICAgfVxuICAgIHByaXZhdGUgX3VwZGF0ZUhTY3JvbGxPZmZzZXQoKSB7XG4gICAgICAgIGxldCBzY3JvbGxPZmZzZXQgPSAwO1xuICAgICAgICBzY3JvbGxPZmZzZXQgPSB0aGlzLmhTY3JvbGwgJiYgcGFyc2VJbnQodGhpcy5oU2Nyb2xsLmNoaWxkcmVuWzBdLnN0eWxlLndpZHRoLCAxMCkgP1xuICAgICAgICAgICAgdGhpcy5oU2Nyb2xsLnNjcm9sbExlZnQgLSB0aGlzLnNpemVzQ2FjaGVbdGhpcy5zdGF0ZS5zdGFydEluZGV4XSA6IDA7XG4gICAgICAgIHRoaXMuZGMuaW5zdGFuY2UuX3ZpZXdDb250YWluZXIuZWxlbWVudC5uYXRpdmVFbGVtZW50LnN0eWxlLmxlZnQgPSAtc2Nyb2xsT2Zmc2V0ICsgJ3B4JztcbiAgICB9XG5cbiAgICBwcml2YXRlIF9nZXRJdGVtU2l6ZShpdGVtLCBkaW1lbnNpb246IHN0cmluZyk6IG51bWJlciB7XG4gICAgICAgIGNvbnN0IGRpbSA9IGl0ZW1bZGltZW5zaW9uXTtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBkaW0gPT09ICdudW1iZXInID8gZGltIDogdGhpcy5pZ3hGb3JJdGVtU2l6ZTtcbiAgICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRUeXBlTmFtZUZvckRlYnVnZ2luZyh0eXBlOiBhbnkpOiBzdHJpbmcge1xuICAgIGNvbnN0IG5hbWUgPSAnbmFtZSc7XG4gICAgcmV0dXJuIHR5cGVbbmFtZV0gfHwgdHlwZW9mIHR5cGU7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgSUZvck9mU3RhdGUge1xuICAgIHN0YXJ0SW5kZXg/OiBudW1iZXI7XG4gICAgY2h1bmtTaXplPzogbnVtYmVyO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIElGb3JPZkRhdGFDaGFuZ2luZ0V2ZW50QXJncyB7XG4gICAgY29udGFpbmVyU2l6ZTogbnVtYmVyO1xufVxuXG5ARGlyZWN0aXZlKHtcbiAgICBzZWxlY3RvcjogJ1tpZ3hHcmlkRm9yXVtpZ3hHcmlkRm9yT2ZdJ1xufSlcbmV4cG9ydCBjbGFzcyBJZ3hHcmlkRm9yT2ZEaXJlY3RpdmU8VD4gZXh0ZW5kcyBJZ3hGb3JPZkRpcmVjdGl2ZTxUPiBpbXBsZW1lbnRzIE9uSW5pdCwgT25DaGFuZ2VzLCBEb0NoZWNrIHtcblxuICAgIGNvbnN0cnVjdG9yKFxuICAgICAgICBfdmlld0NvbnRhaW5lcjogVmlld0NvbnRhaW5lclJlZixcbiAgICAgICAgX3RlbXBsYXRlOiBUZW1wbGF0ZVJlZjxOZ0Zvck9mQ29udGV4dDxUPj4sXG4gICAgICAgIF9kaWZmZXJzOiBJdGVyYWJsZURpZmZlcnMsXG4gICAgICAgIHJlc29sdmVyOiBDb21wb25lbnRGYWN0b3J5UmVzb2x2ZXIsXG4gICAgICAgIGNkcjogQ2hhbmdlRGV0ZWN0b3JSZWYsXG4gICAgICAgIF96b25lOiBOZ1pvbmUsXG4gICAgICAgIHByb3RlY3RlZCBzeW5jU2VydmljZTogSWd4Rm9yT2ZTeW5jU2VydmljZSkge1xuICAgICAgICAgICAgc3VwZXIoX3ZpZXdDb250YWluZXIsIF90ZW1wbGF0ZSwgX2RpZmZlcnMsIHJlc29sdmVyLCBjZHIsIF96b25lKTtcbiAgICAgICAgfVxuXG4gICAgQElucHV0KClcbiAgICBzZXQgaWd4R3JpZEZvck9mKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuaWd4Rm9yT2YgPSB2YWx1ZTtcbiAgICB9XG5cbiAgICBnZXQgaWd4R3JpZEZvck9mKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pZ3hGb3JPZjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuIEBpbnRlcm5hbFxuICAgICAqIEFuIGV2ZW50IHRoYXQgaXMgZW1pdHRlZCBhZnRlciBkYXRhIGhhcyBiZWVuIGNoYW5nZWQgYnV0IGJlZm9yZSB0aGUgdmlldyBpcyByZWZyZXNoZWRcbiAgICAgKi9cbiAgICBAT3V0cHV0KClcbiAgICBwdWJsaWMgb25EYXRhQ2hhbmdpbmcgPSBuZXcgRXZlbnRFbWl0dGVyPElGb3JPZkRhdGFDaGFuZ2luZ0V2ZW50QXJncz4oKTtcblxuICAgIG5nT25Jbml0KCkge1xuICAgICAgICB0aGlzLnN5bmNTZXJ2aWNlLnNldE1hc3Rlcih0aGlzKTtcbiAgICAgICAgc3VwZXIubmdPbkluaXQoKTtcbiAgICAgICAgdGhpcy5yZW1vdmVTY3JvbGxFdmVudExpc3RlbmVycygpO1xuICAgIH1cblxuICAgIG5nT25DaGFuZ2VzKGNoYW5nZXM6IFNpbXBsZUNoYW5nZXMpIHtcbiAgICAgICAgY29uc3QgZm9yT2YgPSAnaWd4R3JpZEZvck9mJztcbiAgICAgICAgdGhpcy5zeW5jU2VydmljZS5zZXRNYXN0ZXIodGhpcyk7XG4gICAgICAgIGlmIChmb3JPZiBpbiBjaGFuZ2VzKSB7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IGNoYW5nZXNbZm9yT2ZdLmN1cnJlbnRWYWx1ZTtcbiAgICAgICAgICAgIGlmICghdGhpcy5fZGlmZmVyICYmIHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZGlmZmVyID0gdGhpcy5fZGlmZmVycy5maW5kKHZhbHVlKS5jcmVhdGUodGhpcy5pZ3hGb3JUcmFja0J5KTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgICAgICAgICAgICAgIGBDYW5ub3QgZmluZCBhIGRpZmZlciBzdXBwb3J0aW5nIG9iamVjdCBcIiR7dmFsdWV9XCIgb2YgdHlwZSBcIiR7Z2V0VHlwZU5hbWVGb3JEZWJ1Z2dpbmcodmFsdWUpfVwiLlxuICAgICAgICAgICAgICAgICAgICAgTmdGb3Igb25seSBzdXBwb3J0cyBiaW5kaW5nIHRvIEl0ZXJhYmxlcyBzdWNoIGFzIEFycmF5cy5gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZGVmYXVsdEl0ZW1TaXplID0gJ2lneEZvckl0ZW1TaXplJztcbiAgICAgICAgaWYgKGRlZmF1bHRJdGVtU2l6ZSBpbiBjaGFuZ2VzICYmICFjaGFuZ2VzW2RlZmF1bHRJdGVtU2l6ZV0uZmlyc3RDaGFuZ2UgJiYgdGhpcy5pZ3hGb3JTY3JvbGxPcmllbnRhdGlvbiA9PT0gJ3ZlcnRpY2FsJykge1xuICAgICAgICAgICAgLy8gaGFuZGxlIGRlZmF1bHQgaXRlbSBzaXplIGNoYW5nZWQuXG4gICAgICAgICAgICB0aGlzLmluaXRTaXplc0NhY2hlKHRoaXMuaWd4Rm9yT2YpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNvbnRhaW5lclNpemUgPSAnaWd4Rm9yQ29udGFpbmVyU2l6ZSc7XG4gICAgICAgIGlmIChjb250YWluZXJTaXplIGluIGNoYW5nZXMgJiYgIWNoYW5nZXNbY29udGFpbmVyU2l6ZV0uZmlyc3RDaGFuZ2UgJiYgdGhpcy5pZ3hGb3JPZikge1xuICAgICAgICAgICAgdGhpcy5fcmVjYWxjT25Db250YWluZXJDaGFuZ2UoY2hhbmdlcyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgcHVibGljIGdldCBzaXplc0NhY2hlKCk6IG51bWJlcltdIHtcbiAgICAgICAgaWYgKHRoaXMuc3luY1NlcnZpY2UuaXNNYXN0ZXIodGhpcykpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9zaXplc0NhY2hlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnN5bmNTZXJ2aWNlLnNpemVzQ2FjaGUodGhpcy5pZ3hGb3JTY3JvbGxPcmllbnRhdGlvbik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBwdWJsaWMgc2V0IHNpemVzQ2FjaGUodmFsdWU6IG51bWJlcltdKSB7XG4gICAgICAgIHRoaXMuX3NpemVzQ2FjaGUgPSB2YWx1ZTtcbiAgICB9XG5cbiAgICBwcm90ZWN0ZWQgZ2V0IGl0ZW1zRGltZW5zaW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pZ3hGb3JTY3JvbGxPcmllbnRhdGlvbiA9PT0gJ2hvcml6b250YWwnID8gdGhpcy5pZ3hGb3JTaXplUHJvcE5hbWUgOiAnaGVpZ2h0JztcbiAgICB9XG5cbiAgICBwcm90ZWN0ZWQgZ2V0SXRlbVNpemUoaXRlbSkge1xuICAgICAgICBsZXQgc2l6ZSA9IDA7XG4gICAgICAgIGNvbnN0IGRpbWVuc2lvbiA9IHRoaXMuaWd4Rm9yU2Nyb2xsT3JpZW50YXRpb24gPT09ICdob3Jpem9udGFsJyA/XG4gICAgICAgICAgICB0aGlzLmlneEZvclNpemVQcm9wTmFtZSA6ICdoZWlnaHQnO1xuICAgICAgICBpZiAoZGltZW5zaW9uID09PSAnaGVpZ2h0Jykge1xuICAgICAgICAgICAgc2l6ZSA9IHBhcnNlSW50KHRoaXMuaWd4Rm9ySXRlbVNpemUsIDEwKSB8fCAwO1xuICAgICAgICAgICAgaWYgKGl0ZW0gJiYgaXRlbS5zdW1tYXJpZXMpIHtcbiAgICAgICAgICAgICAgICBzaXplID0gaXRlbS5tYXg7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGl0ZW0gJiYgaXRlbS5ncm91cHMgJiYgaXRlbS5oZWlnaHQpIHtcbiAgICAgICAgICAgICAgICBzaXplID0gaXRlbS5oZWlnaHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzaXplID0gcGFyc2VJbnQoaXRlbVtkaW1lbnNpb25dLCAxMCkgfHwgMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2l6ZTtcbiAgICB9XG5cbiAgICBwcm90ZWN0ZWQgaW5pdFNpemVzQ2FjaGUoaXRlbXM6IGFueVtdKTogbnVtYmVyIHtcbiAgICAgICAgaWYgKCF0aGlzLnN5bmNTZXJ2aWNlLmlzTWFzdGVyKHRoaXMpKSB7XG4gICAgICAgICAgICBjb25zdCBtYXN0ZXJTaXplc0NhY2hlID0gdGhpcy5zeW5jU2VydmljZS5zaXplc0NhY2hlKHRoaXMuaWd4Rm9yU2Nyb2xsT3JpZW50YXRpb24pO1xuICAgICAgICAgICAgcmV0dXJuIG1hc3RlclNpemVzQ2FjaGVbbWFzdGVyU2l6ZXNDYWNoZS5sZW5ndGggLSAxXTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgdG90YWxTaXplID0gMDtcbiAgICAgICAgbGV0IHNpemUgPSAwO1xuICAgICAgICBsZXQgaSA9IDA7XG4gICAgICAgIHRoaXMuc2l6ZXNDYWNoZSA9IFtdO1xuICAgICAgICB0aGlzLmhlaWdodENhY2hlID0gW107XG4gICAgICAgIHRoaXMuc2l6ZXNDYWNoZS5wdXNoKDApO1xuICAgICAgICBjb25zdCBjb3VudCA9IHRoaXMuaXNSZW1vdGUgPyB0aGlzLnRvdGFsSXRlbUNvdW50IDogaXRlbXMubGVuZ3RoO1xuICAgICAgICBmb3IgKGk7IGkgPCBjb3VudDsgaSsrKSB7XG4gICAgICAgICAgICBzaXplID0gdGhpcy5nZXRJdGVtU2l6ZShpdGVtc1tpXSk7XG4gICAgICAgICAgICBpZiAodGhpcy5pdGVtc0RpbWVuc2lvbiA9PT0gJ2hlaWdodCcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmhlaWdodENhY2hlLnB1c2goc2l6ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0b3RhbFNpemUgKz0gc2l6ZTtcbiAgICAgICAgICAgIHRoaXMuc2l6ZXNDYWNoZS5wdXNoKHRvdGFsU2l6ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRvdGFsU2l6ZTtcbiAgICB9XG5cbiAgICBwcm90ZWN0ZWQgX3VwZGF0ZVNpemVDYWNoZShjaGFuZ2VzOiBJdGVyYWJsZUNoYW5nZXM8VD4gPSBudWxsKSB7XG4gICAgICAgIGlmICh0aGlzLmlneEZvclNjcm9sbE9yaWVudGF0aW9uID09PSAnaG9yaXpvbnRhbCcpIHtcbiAgICAgICAgICAgIHRoaXMuaW5pdFNpemVzQ2FjaGUodGhpcy5pZ3hGb3JPZik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc2NyID0gdGhpcy52aC5pbnN0YW5jZS5lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQ7XG5cbiAgICAgICAgY29uc3Qgb2xkSGVpZ2h0ID0gdGhpcy5oZWlnaHRDYWNoZS5sZW5ndGggPiAwID8gdGhpcy5oZWlnaHRDYWNoZS5yZWR1Y2UoKGFjYywgdmFsKSA9PiBhY2MgKyB2YWwpIDogMDtcbiAgICAgICAgbGV0IG5ld0hlaWdodCA9IG9sZEhlaWdodDtcbiAgICAgICAgaWYgKGNoYW5nZXMgJiYgIXRoaXMuaXNSZW1vdGUpIHtcbiAgICAgICAgICAgIG5ld0hlaWdodCA9IHRoaXMuaGFuZGxlQ2FjaGVDaGFuZ2VzKGNoYW5nZXMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbmV3SGVpZ2h0ID0gdGhpcy5pbml0U2l6ZXNDYWNoZSh0aGlzLmlneEZvck9mKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGRpZmYgPSBvbGRIZWlnaHQgLSBuZXdIZWlnaHQ7XG5cbiAgICAgICAgLy8gaWYgZGF0YSBoYXMgYmVlbiBjaGFuZ2VkIHdoaWxlIGNvbnRhaW5lciBpcyBzY3JvbGxlZFxuICAgICAgICAvLyBzaG91bGQgdXBkYXRlIHNjcm9sbCB0b3AvbGVmdCBhY2NvcmRpbmcgdG8gY2hhbmdlIHNvIHRoYXQgc2FtZSBzdGFydEluZGV4IGlzIGluIHZpZXdcbiAgICAgICAgaWYgKE1hdGguYWJzKGRpZmYpID4gMCkge1xuICAgICAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlY2FsY1VwZGF0ZVNpemVzKCk7XG4gICAgICAgICAgICAgICAgY29uc3Qgb2Zmc2V0ID0gcGFyc2VJbnQodGhpcy5kYy5pbnN0YW5jZS5fdmlld0NvbnRhaW5lci5lbGVtZW50Lm5hdGl2ZUVsZW1lbnQuc3R5bGUudG9wLCAxMCk7XG4gICAgICAgICAgICAgICAgaWYgKHNjci5zY3JvbGxUb3AgIT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgc2NyLnNjcm9sbFRvcCA9IHRoaXMuc2l6ZXNDYWNoZVt0aGlzLnN0YXRlLnN0YXJ0SW5kZXhdIC0gb2Zmc2V0O1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3VwZGF0ZVNjcm9sbE9mZnNldCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHJvdGVjdGVkIGhhbmRsZUNhY2hlQ2hhbmdlcyhjaGFuZ2VzOiBJdGVyYWJsZUNoYW5nZXM8VD4pIHtcbiAgICAgICAgY29uc3QgaWRlbnRpdHlDaGFuZ2VzID0gW107XG4gICAgICAgIGNvbnN0IG5ld0hlaWdodENhY2hlID0gW107XG4gICAgICAgIGNvbnN0IG5ld1NpemVzQ2FjaGUgPSBbXTtcbiAgICAgICAgbmV3U2l6ZXNDYWNoZS5wdXNoKDApO1xuICAgICAgICBsZXQgbmV3SGVpZ2h0ID0gMDtcblxuICAgICAgICAvLyBXaGVuIHRoZXJlIGFyZSBtb3JlIHRoYW4gb25lIHJlbW92ZWQgaXRlbXMgdGhlIGNoYW5nZXMgYXJlIG5vdCByZWxpYWJsZSBzbyB0aG9zZSB3aXRoIGlkZW50aXR5IGNoYW5nZSBzaG91bGQgYmUgZGVmYXVsdCBzaXplLlxuICAgICAgICBsZXQgbnVtUmVtb3ZlZEl0ZW1zID0gMDtcbiAgICAgICAgY2hhbmdlcy5mb3JFYWNoUmVtb3ZlZEl0ZW0oKCkgPT4gbnVtUmVtb3ZlZEl0ZW1zKyspO1xuXG4gICAgICAgIC8vIEdldCB0aGUgaWRlbnRpdHkgY2hhbmdlcyB0byBkZXRlcm1pbmUgbGF0ZXIgaWYgdGhvc2UgdGhhdCBoYXZlIGNoYW5nZWQgdGhlaXIgaW5kZXhlcyBzaG91bGQgYmUgYXNzaWduZWQgZGVmYXVsdCBpdGVtIHNpemUuXG4gICAgICAgIGNoYW5nZXMuZm9yRWFjaElkZW50aXR5Q2hhbmdlKChpdGVtKSA9PiB7XG4gICAgICAgICAgICBpZiAoaXRlbS5jdXJyZW50SW5kZXggIT09IGl0ZW0ucHJldmlvdXNJbmRleCkge1xuICAgICAgICAgICAgICAgIC8vIEZpbHRlciBvdXQgb25lcyB0aGF0IGhhdmUgbm90IGNoYW5nZWQgdGhlaXIgaW5kZXguXG4gICAgICAgICAgICAgICAgaWRlbnRpdHlDaGFuZ2VzW2l0ZW0uY3VycmVudEluZGV4XSA9IGl0ZW07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIFByb2Nlc3NpbmcgZWFjaCBpdGVtIHRoYXQgaXMgcGFzc2VkIHRvIHRoZSBpZ3hGb3JPZiBzbyBmYXIgc2VlbSB0byBiZSBtb3N0IHJlbGlhYmxlLiBXZSBwYXJzZSB0aGUgdXBkYXRlZCBsaXN0IG9mIGl0ZW1zLlxuICAgICAgICBjaGFuZ2VzLmZvckVhY2hJdGVtKChpdGVtKSA9PiB7XG4gICAgICAgICAgICBpZiAoaXRlbS5wcmV2aW91c0luZGV4ICE9PSBudWxsICYmXG4gICAgICAgICAgICAgICAgKG51bVJlbW92ZWRJdGVtcyA8IDIgfHwgIWlkZW50aXR5Q2hhbmdlcy5sZW5ndGggfHwgaWRlbnRpdHlDaGFuZ2VzW2l0ZW0uY3VycmVudEluZGV4XSkpIHtcbiAgICAgICAgICAgICAgICAvLyBSZXVzZSBjYWNoZSBvbiB0aG9zZSB3aG8gaGF2ZSBwcmV2aW91c0luZGV4LlxuICAgICAgICAgICAgICAgIC8vIFdoZW4gdGhlcmUgYXJlIG1vcmUgdGhhbiBvbmUgcmVtb3ZlZCBpdGVtcyBjdXJyZW50bHkgdGhlIGNoYW5nZXMgYXJlIG5vdCByZWFkYWJsZSBzbyBvbmVzIHdpdGggaWRlbnRpdHkgY2hhbmdlXG4gICAgICAgICAgICAgICAgLy8gc2hvdWxkIGJlIHJhY2FsY3VsYXRlZC5cbiAgICAgICAgICAgICAgICBuZXdIZWlnaHRDYWNoZVtpdGVtLmN1cnJlbnRJbmRleF0gPSB0aGlzLmhlaWdodENhY2hlW2l0ZW0ucHJldmlvdXNJbmRleF07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIEFzc2lnbiBkZWZhdWx0IGl0ZW0gc2l6ZS5cbiAgICAgICAgICAgICAgICBuZXdIZWlnaHRDYWNoZVtpdGVtLmN1cnJlbnRJbmRleF0gPSB0aGlzLmdldEl0ZW1TaXplKGl0ZW0uaXRlbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBuZXdTaXplc0NhY2hlW2l0ZW0uY3VycmVudEluZGV4ICsgMV0gPSBuZXdTaXplc0NhY2hlW2l0ZW0uY3VycmVudEluZGV4XSArIG5ld0hlaWdodENhY2hlW2l0ZW0uY3VycmVudEluZGV4XTtcbiAgICAgICAgICAgIG5ld0hlaWdodCArPSBuZXdIZWlnaHRDYWNoZVtpdGVtLmN1cnJlbnRJbmRleF07XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmhlaWdodENhY2hlID0gbmV3SGVpZ2h0Q2FjaGU7XG4gICAgICAgIHRoaXMuc2l6ZXNDYWNoZSA9IG5ld1NpemVzQ2FjaGU7XG4gICAgICAgIHJldHVybiBuZXdIZWlnaHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIHB1YmxpYyBhc3N1bWVNYXN0ZXIoKTogdm9pZCB7XG4gICAgICAgIHRoaXMuX3NpemVzQ2FjaGUgPSB0aGlzLnN5bmNTZXJ2aWNlLnNpemVzQ2FjaGUodGhpcy5pZ3hGb3JTY3JvbGxPcmllbnRhdGlvbik7XG4gICAgICAgIHRoaXMuc3luY1NlcnZpY2Uuc2V0TWFzdGVyKHRoaXMsIHRydWUpO1xuICAgIH1cblxuICAgIG5nRG9DaGVjaygpIHtcbiAgICAgICAgaWYgKHRoaXMuX2RpZmZlcikge1xuICAgICAgICAgICAgY29uc3QgY2hhbmdlcyA9IHRoaXMuX2RpZmZlci5kaWZmKHRoaXMuaWd4Rm9yT2YpO1xuICAgICAgICAgICAgaWYgKGNoYW5nZXMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBhcmdzOiBJRm9yT2ZEYXRhQ2hhbmdpbmdFdmVudEFyZ3MgPSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRhaW5lclNpemU6IHRoaXMuaWd4Rm9yQ29udGFpbmVyU2l6ZVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgdGhpcy5vbkRhdGFDaGFuZ2luZy5lbWl0KGFyZ3MpO1xuICAgICAgICAgICAgICAgIC8vICByZS1pbml0IGNhY2hlLlxuICAgICAgICAgICAgICAgIGlmICghdGhpcy5pZ3hGb3JPZikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8qIHdlIG5lZWQgdG8gcmVzZXQgdGhlIG1hc3RlciBkaXIgaWYgYWxsIHJvd3MgYXJlIHJlbW92ZWRcbiAgICAgICAgICAgICAgICAoZS5nLiBiZWNhdXNlIG9mIGZpbHRlcmluZyk7IGlmIGFsbCBjb2x1bW5zIGFyZSBoaWRkZW4sIHJvd3MgYXJlXG4gICAgICAgICAgICAgICAgc3RpbGwgcmVuZGVyZWQgZW1wdHksIHNvIHdlIHNob3VsZCBub3QgcmVzZXQgbWFzdGVyICovXG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLmlneEZvck9mLmxlbmd0aCAmJlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmlneEZvclNjcm9sbE9yaWVudGF0aW9uID09PSAndmVydGljYWwnKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3luY1NlcnZpY2UucmVzZXRNYXN0ZXIoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5zeW5jU2VydmljZS5zZXRNYXN0ZXIodGhpcyk7XG4gICAgICAgICAgICAgICAgdGhpcy5pZ3hGb3JDb250YWluZXJTaXplID0gYXJncy5jb250YWluZXJTaXplO1xuICAgICAgICAgICAgICAgIHRoaXMuX3VwZGF0ZVNpemVDYWNoZShjaGFuZ2VzKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9hcHBseUNoYW5nZXMoKTtcbiAgICAgICAgICAgICAgICB0aGlzLl91cGRhdGVTY3JvbGxPZmZzZXQoKTtcbiAgICAgICAgICAgICAgICB0aGlzLm9uRGF0YUNoYW5nZWQuZW1pdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgb25TY3JvbGwoZXZlbnQpIHtcbiAgICAgICAgaWYgKCFwYXJzZUludCh0aGlzLnZoLmluc3RhbmNlLmVsZW1lbnRSZWYubmF0aXZlRWxlbWVudC5zdHlsZS5oZWlnaHQsIDEwKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgY29udGFpbmVyU2l6ZSA9IHBhcnNlSW50KHRoaXMuaWd4Rm9yQ29udGFpbmVyU2l6ZSwgMTApO1xuICAgICAgICBjb25zdCBtYXhSZWFsU2Nyb2xsVG9wID0gZXZlbnQudGFyZ2V0LmNoaWxkcmVuWzBdLnNjcm9sbEhlaWdodCAtIGNvbnRhaW5lclNpemU7XG4gICAgICAgIGNvbnN0IHJlYWxQZXJjZW50U2Nyb2xsZWQgPSBldmVudC50YXJnZXQuc2Nyb2xsVG9wIC8gbWF4UmVhbFNjcm9sbFRvcDtcbiAgICAgICAgaWYgKCF0aGlzLl9iU2Nyb2xsSW50ZXJuYWwpIHtcbiAgICAgICAgICAgIGNvbnN0IG1heFZpcnRTY3JvbGxUb3AgPSB0aGlzLl92aXJ0SGVpZ2h0IC0gY29udGFpbmVyU2l6ZTtcbiAgICAgICAgICAgIHRoaXMuX3ZpcnRTY3JvbGxUb3AgPSByZWFsUGVyY2VudFNjcm9sbGVkICogbWF4VmlydFNjcm9sbFRvcDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX2JTY3JvbGxJbnRlcm5hbCA9IGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3Qgc2Nyb2xsT2Zmc2V0ID0gdGhpcy5maXhlZFVwZGF0ZUFsbEVsZW1lbnRzKHRoaXMuX3ZpcnRTY3JvbGxUb3ApO1xuXG4gICAgICAgIHRoaXMuZGMuaW5zdGFuY2UuX3ZpZXdDb250YWluZXIuZWxlbWVudC5uYXRpdmVFbGVtZW50LnN0eWxlLnRvcCA9IC0oc2Nyb2xsT2Zmc2V0KSArICdweCc7XG4gICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnJlY2FsY1VwZGF0ZVNpemVzKCk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIG9uSFNjcm9sbChzY3JvbGxBbW91bnQpIHtcbiAgICAgICAgLyogaW4gY2VydGFpbiBzaXR1YXRpb25zIHRoaXMgbWF5IGJlIGNhbGxlZCB3aGVuIG5vIHNjcm9sbGJhciBpcyB2aXNpYmxlICovXG4gICAgICAgIGlmICghdGhpcy5oU2Nyb2xsIHx8ICFwYXJzZUludCh0aGlzLmhTY3JvbGwuY2hpbGRyZW5bMF0uc3R5bGUud2lkdGgsIDEwKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVXBkYXRpbmcgaG9yaXpvbnRhbCBjaHVua3NcbiAgICAgICAgY29uc3Qgc2Nyb2xsT2Zmc2V0ID0gdGhpcy5maXhlZFVwZGF0ZUFsbEVsZW1lbnRzKHNjcm9sbEFtb3VudCk7XG4gICAgICAgIHRoaXMuZGMuaW5zdGFuY2UuX3ZpZXdDb250YWluZXIuZWxlbWVudC5uYXRpdmVFbGVtZW50LnN0eWxlLmxlZnQgPSAtc2Nyb2xsT2Zmc2V0ICsgJ3B4JztcbiAgICB9XG5cbiAgICBwcm90ZWN0ZWQgYWRkTGFzdEVsZW0oKSB7XG4gICAgICAgIGxldCBlbGVtSW5kZXggPSB0aGlzLnN0YXRlLnN0YXJ0SW5kZXggKyB0aGlzLnN0YXRlLmNodW5rU2l6ZTtcbiAgICAgICAgaWYgKCF0aGlzLmlzUmVtb3RlICYmICF0aGlzLmlneEZvck9mKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZWxlbUluZGV4ID49IHRoaXMuaWd4Rm9yT2YubGVuZ3RoKSB7XG4gICAgICAgICAgICBlbGVtSW5kZXggPSB0aGlzLmlneEZvck9mLmxlbmd0aCAtIHRoaXMuc3RhdGUuY2h1bmtTaXplO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGlucHV0ID0gdGhpcy5pZ3hGb3JPZltlbGVtSW5kZXhdO1xuICAgICAgICBjb25zdCBlbWJlZGRlZFZpZXcgPSB0aGlzLmRjLmluc3RhbmNlLl92Y3IuY3JlYXRlRW1iZWRkZWRWaWV3KFxuICAgICAgICAgICAgdGhpcy5fdGVtcGxhdGUsXG4gICAgICAgICAgICB7ICRpbXBsaWNpdDogaW5wdXQsIGluZGV4OiBlbGVtSW5kZXggfVxuICAgICAgICApO1xuXG4gICAgICAgIHRoaXMuX2VtYmVkZGVkVmlld3MucHVzaChlbWJlZGRlZFZpZXcpO1xuICAgICAgICB0aGlzLnN0YXRlLmNodW5rU2l6ZSsrO1xuICAgIH1cblxuICAgIHByb3RlY3RlZCBfdXBkYXRlVmlld3MocHJldkNodW5rU2l6ZSkge1xuICAgICAgICBpZiAodGhpcy5pZ3hGb3JPZiAmJiB0aGlzLmlneEZvck9mLmxlbmd0aCAmJiB0aGlzLmRjKSB7XG4gICAgICAgICAgICBjb25zdCBlbWJlZGRlZFZpZXdDb3B5ID0gT2JqZWN0LmFzc2lnbihbXSwgdGhpcy5fZW1iZWRkZWRWaWV3cyk7XG4gICAgICAgICAgICBsZXQgc3RhcnRJbmRleDtcbiAgICAgICAgICAgIGxldCBlbmRJbmRleDtcbiAgICAgICAgICAgIGlmICh0aGlzLmlzUmVtb3RlKSB7XG4gICAgICAgICAgICAgICAgc3RhcnRJbmRleCA9IDA7XG4gICAgICAgICAgICAgICAgZW5kSW5kZXggPSB0aGlzLmlneEZvck9mLmxlbmd0aDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaW5TY3JvbGxUb3AgPSB0aGlzLmlneEZvclNjcm9sbE9yaWVudGF0aW9uID09PSAnaG9yaXpvbnRhbCcgP1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmhTY3JvbGwuc2Nyb2xsTGVmdCA6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudmguaW5zdGFuY2UuZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LnNjcm9sbFRvcDtcbiAgICAgICAgICAgICAgICBzdGFydEluZGV4ID0gdGhpcy5nZXRJbmRleEF0KFxuICAgICAgICAgICAgICAgICAgICBpblNjcm9sbFRvcCxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zaXplc0NhY2hlLFxuICAgICAgICAgICAgICAgICAgICAwXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICBpZiAoc3RhcnRJbmRleCArIHRoaXMuc3RhdGUuY2h1bmtTaXplID4gdGhpcy5pZ3hGb3JPZi5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhcnRJbmRleCA9IHRoaXMuaWd4Rm9yT2YubGVuZ3RoIC0gdGhpcy5zdGF0ZS5jaHVua1NpemU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUuc3RhcnRJbmRleCA9IHN0YXJ0SW5kZXg7XG4gICAgICAgICAgICAgICAgZW5kSW5kZXggPSB0aGlzLnN0YXRlLmNodW5rU2l6ZSArIHRoaXMuc3RhdGUuc3RhcnRJbmRleDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IHN0YXJ0SW5kZXg7IGkgPCBlbmRJbmRleCAmJiB0aGlzLmlneEZvck9mW2ldICE9PSB1bmRlZmluZWQ7IGkrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGlucHV0ID0gdGhpcy5pZ3hGb3JPZltpXTtcbiAgICAgICAgICAgICAgICBjb25zdCBlbWJWaWV3ID0gZW1iZWRkZWRWaWV3Q29weS5zaGlmdCgpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGNudHggPSAoZW1iVmlldyBhcyBFbWJlZGRlZFZpZXdSZWY8YW55PikuY29udGV4dDtcbiAgICAgICAgICAgICAgICBjbnR4LiRpbXBsaWNpdCA9IGlucHV0O1xuICAgICAgICAgICAgICAgIGNudHguaW5kZXggPSB0aGlzLmdldENvbnRleHRJbmRleChpbnB1dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocHJldkNodW5rU2l6ZSAhPT0gdGhpcy5zdGF0ZS5jaHVua1NpemUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm9uQ2h1bmtMb2FkLmVtaXQodGhpcy5zdGF0ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5pZ3hGb3JTY3JvbGxPcmllbnRhdGlvbiA9PT0gJ3ZlcnRpY2FsJykge1xuICAgICAgICAgICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVjYWxjVXBkYXRlU2l6ZXMoKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBwcm90ZWN0ZWQgX2FwcGx5Q2hhbmdlcygpIHtcbiAgICAgICAgY29uc3QgcHJldkNodW5rU2l6ZSA9IHRoaXMuc3RhdGUuY2h1bmtTaXplO1xuICAgICAgICB0aGlzLmFwcGx5Q2h1bmtTaXplQ2hhbmdlKCk7XG4gICAgICAgIHRoaXMuX3JlY2FsY1Njcm9sbEJhclNpemUoKTtcbiAgICAgICAgdGhpcy5fdXBkYXRlVmlld3MocHJldkNodW5rU2l6ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHByb3RlY3RlZCBfY2FsY01heENodW5rU2l6ZSgpOiBudW1iZXIge1xuICAgICAgICBpZiAodGhpcy5zeW5jU2VydmljZS5pc01hc3Rlcih0aGlzKSkge1xuICAgICAgICAgICAgcmV0dXJuIHN1cGVyLl9jYWxjTWF4Q2h1bmtTaXplKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuc3luY1NlcnZpY2UuY2h1bmtTaXplKHRoaXMuaWd4Rm9yU2Nyb2xsT3JpZW50YXRpb24pO1xuICAgIH1cbn1cblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbkBOZ01vZHVsZSh7XG4gICAgZGVjbGFyYXRpb25zOiBbSWd4Rm9yT2ZEaXJlY3RpdmUsIElneEdyaWRGb3JPZkRpcmVjdGl2ZSwgRGlzcGxheUNvbnRhaW5lckNvbXBvbmVudCwgVmlydHVhbEhlbHBlckNvbXBvbmVudCwgSFZpcnR1YWxIZWxwZXJDb21wb25lbnRdLFxuICAgIGVudHJ5Q29tcG9uZW50czogW0Rpc3BsYXlDb250YWluZXJDb21wb25lbnQsIFZpcnR1YWxIZWxwZXJDb21wb25lbnQsIEhWaXJ0dWFsSGVscGVyQ29tcG9uZW50XSxcbiAgICBleHBvcnRzOiBbSWd4Rm9yT2ZEaXJlY3RpdmUsIElneEdyaWRGb3JPZkRpcmVjdGl2ZV0sXG4gICAgaW1wb3J0czogW0lneFNjcm9sbEluZXJ0aWFNb2R1bGUsIENvbW1vbk1vZHVsZV1cbn0pXG5cbmV4cG9ydCBjbGFzcyBJZ3hGb3JPZk1vZHVsZSB7XG59XG4iXX0=