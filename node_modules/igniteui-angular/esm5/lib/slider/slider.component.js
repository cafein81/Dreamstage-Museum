/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import * as tslib_1 from "tslib";
import { CommonModule } from '@angular/common';
import { Component, ElementRef, EventEmitter, HostBinding, Input, NgModule, Output, Renderer2, ViewChild, TemplateRef, ContentChild, HostListener, ViewChildren, QueryList } from '@angular/core';
import { NG_VALUE_ACCESSOR } from '@angular/forms';
import { DeprecateProperty } from '../core/deprecateDecorators';
import { IgxSliderThumbComponent } from './thumb/thumb-slider.component';
import { Subject, merge } from 'rxjs';
import { takeUntil } from 'rxjs/operators';
import { SliderHandle, IgxThumbFromTemplateDirective, IgxThumbToTemplateDirective, SliderType } from './slider.common';
/** @type {?} */
var noop = function () {
};
var Éµ0 = noop;
/** @type {?} */
var NEXT_ID = 0;
/**
 * **Ignite UI for Angular Slider** -
 * [Documentation](https://www.infragistics.com/products/ignite-ui-angular/angular/components/slider.html)
 *
 * The Ignite UI Slider allows selection in a given range by moving the thumb along the track. The track
 * can be defined as continuous or stepped, and you can choose between single and range slider types.
 *
 * Example:
 * ```html
 * <igx-slider id="slider"
 *            [minValue]="0" [maxValue]="100"
 *            [continuous]=true [(ngModel)]="volume">
 * </igx-slider>
 * ```
 */
var IgxSliderComponent = /** @class */ (function () {
    function IgxSliderComponent(renderer, _el) {
        this.renderer = renderer;
        this._el = _el;
        // Limit handle travel zone
        this._pMin = 0;
        this._pMax = 1;
        // From/upperValue in percent values
        this._hasViewInit = false;
        this._minValue = 0;
        this._maxValue = 100;
        this._countinuous = false;
        this._disabled = false;
        this._step = 1;
        this._labels = new Array();
        this._type = SliderType.SLIDER;
        this._destroy$ = new Subject();
        this._onChangeCallback = noop;
        this._onTouchedCallback = noop;
        /**
         * @hidden
         */
        this.thumbs = new QueryList();
        /**
         * @hidden
         */
        this.stepDistance = this._step;
        /**
         * @hidden
         */
        this.onPan = new Subject();
        /**
         * @hidden
         */
        this.role = 'slider';
        /**
         * @hidden
         */
        this.slierClass = true;
        /**
         * An \@Input property that sets the value of the `id` attribute.
         * If not provided it will be automatically generated.
         * ```html
         * <igx-slider [id]="'igx-slider-32'" [(ngModel)]="task.percentCompleted" [step]="5" [lowerBound]="20">
         * ```
         */
        this.id = "igx-slider-" + NEXT_ID++;
        /**
         * An \@Input property that sets the duration visibility of thumbs labels. The default value is 750 milliseconds.
         * ```html
         * <igx-slider #slider [thumbLabelVisibilityDuration]="3000" [(ngModel)]="task.percentCompleted" [step]="5">
         * ```
         */
        this.thumbLabelVisibilityDuration = 750;
        /**
         * This event is emitted when user has stopped interacting the thumb and value is changed.
         * ```typescript
         * public change(event){
         *    alert("The value has been changed!");
         * }
         * ```
         * ```html
         * <igx-slider (onValueChange)="change($event)" #slider [(ngModel)]="task.percentCompleted" [step]="5">
         * ```
         */
        this.onValueChange = new EventEmitter();
    }
    Object.defineProperty(IgxSliderComponent.prototype, "thumbFrom", {
        get: /**
         * @private
         * @return {?}
         */
        function () {
            return this.thumbs.find(function (thumb) { return thumb.type === SliderHandle.FROM; });
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxSliderComponent.prototype, "thumbTo", {
        get: /**
         * @private
         * @return {?}
         */
        function () {
            return this.thumbs.find(function (thumb) { return thumb.type === SliderHandle.TO; });
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxSliderComponent.prototype, "valuemin", {
        /**
         * @hidden
         */
        get: /**
         * @hidden
         * @return {?}
         */
        function () {
            return this.minValue;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxSliderComponent.prototype, "valuemax", {
        /**
         * @hidden
         */
        get: /**
         * @hidden
         * @return {?}
         */
        function () {
            return this.maxValue;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxSliderComponent.prototype, "readonly", {
        /**
         * @hidden
         */
        get: /**
         * @hidden
         * @return {?}
         */
        function () {
            return this.disabled;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxSliderComponent.prototype, "disabledClass", {
        /**
         * @hidden
         */
        get: /**
         * @hidden
         * @return {?}
         */
        function () {
            return this.disabled;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxSliderComponent.prototype, "type", {
        /**
         * An @Input property that gets the type of the `IgxSliderComponent`. The slider can be SliderType.SLIDER(default) or SliderType.RANGE.
         * ```typescript
         * @ViewChild("slider2")
         * public slider: IgxSliderComponent;
         * ngAfterViewInit(){
         *     let type = this.slider.type;
         * }
         */
        get: /**
         * An \@Input property that gets the type of the `IgxSliderComponent`. The slider can be SliderType.SLIDER(default) or SliderType.RANGE.
         * ```typescript
         * \@ViewChild("slider2")
         * public slider: IgxSliderComponent;
         * ngAfterViewInit(){
         *     let type = this.slider.type;
         * }
         * @return {?}
         */
        function () {
            return this._type;
        },
        /**
         * An @Input property that sets the type of the `IgxSliderComponent`. The slider can be SliderType.SLIDER(default) or SliderType.RANGE.
         * ```typescript
         * sliderType: SliderType = SliderType.RANGE;
         * ```
         * ```html
         * <igx-slider #slider2 [type]="sliderType" [(ngModel)]="rangeValue" [minValue]="0" [maxValue]="100">
         * ```
         */
        set: /**
         * An \@Input property that sets the type of the `IgxSliderComponent`. The slider can be SliderType.SLIDER(default) or SliderType.RANGE.
         * ```typescript
         * sliderType: SliderType = SliderType.RANGE;
         * ```
         * ```html
         * <igx-slider #slider2 [type]="sliderType" [(ngModel)]="rangeValue" [minValue]="0" [maxValue]="100">
         * ```
         * @param {?} type
         * @return {?}
         */
        function (type) {
            this._type = type;
            if (type === SliderType.SLIDER) {
                this.lowerValue = 0;
            }
            if (this.labelsViewEnabled && this.upperValue > this.maxValue) {
                this.upperValue = this.labels.length - 1;
            }
            if (this._hasViewInit) {
                this.updateTrack();
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxSliderComponent.prototype, "labels", {
        /**
         * Enables `labelView`, by accepting a collection of primitive values with more than one element.
         * Each element will be equally spread over the slider and it will serve as a thumb label.
         * Once the property is set, it will precendence over {@link maxValue}, {@link minValue}, {@link step}.
         * This means that the manipulation for those properties won't be allowed.
         */
        get: /**
         * Enables `labelView`, by accepting a collection of primitive values with more than one element.
         * Each element will be equally spread over the slider and it will serve as a thumb label.
         * Once the property is set, it will precendence over {\@link maxValue}, {\@link minValue}, {\@link step}.
         * This means that the manipulation for those properties won't be allowed.
         * @return {?}
         */
        function () {
            return this._labels;
        },
        set: /**
         * @param {?} labels
         * @return {?}
         */
        function (labels) {
            this._labels = labels;
            this._pMax = 1;
            if (this._hasViewInit) {
                this.stepDistance = this.calculateStepDistance();
                this.positionHandlesAndUpdateTrack();
                this.setTickInterval(labels);
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxSliderComponent.prototype, "context", {
        /**
         * Returns the template context corresponding
         * to {@link IgxThumbFromTemplateDirective} and {@link IgxThumbToTemplateDirective} templates.
         *
         * return {
         *  $implicit: {@link value},
         *  labels: {@link labels}
         * }
         * ```
         */
        get: /**
         * Returns the template context corresponding
         * to {\@link IgxThumbFromTemplateDirective} and {\@link IgxThumbToTemplateDirective} templates.
         *
         * return {
         *  $implicit: {\@link value},
         *  labels: {\@link labels}
         * }
         * ```
         * @return {?}
         */
        function () {
            return {
                $implicit: this.value,
                labels: this.labels
            };
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxSliderComponent.prototype, "step", {
        /**
         * Returns the incremental/decremental dragging step of the {@link IgxSliderComponent}.
         * ```typescript
         * @ViewChild("slider2")
         * public slider: IgxSliderComponent;
         * ngAfterViewInit(){
         *     let step = this.slider.step;
         * }
         * ```
         */
        get: /**
         * Returns the incremental/decremental dragging step of the {\@link IgxSliderComponent}.
         * ```typescript
         * \@ViewChild("slider2")
         * public slider: IgxSliderComponent;
         * ngAfterViewInit(){
         *     let step = this.slider.step;
         * }
         * ```
         * @return {?}
         */
        function () {
            return this.labelsViewEnabled ? 1 : this._step;
        },
        /**
         * An @Input property that sets the incremental/decremental step of the value when dragging the thumb.
         * The default step is 1, and step should not be less or equal than 0.
         * ```html
         * <igx-slider #slider [(ngModel)]="task.percentCompleted" [step]="5">
         * ```
         */
        set: /**
         * An \@Input property that sets the incremental/decremental step of the value when dragging the thumb.
         * The default step is 1, and step should not be less or equal than 0.
         * ```html
         * <igx-slider #slider [(ngModel)]="task.percentCompleted" [step]="5">
         * ```
         * @param {?} step
         * @return {?}
         */
        function (step) {
            this._step = step;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxSliderComponent.prototype, "disabled", {
        /**
         * Returns if the {@link IgxSliderComponent} is disabled.
         * ```typescript
         * @ViewChild("slider2")
         * public slider: IgxSliderComponent;
         * ngAfterViewInit(){
         *     let isDisabled = this.slider.disabled;
         * }
         * ```
         */
        get: /**
         * Returns if the {\@link IgxSliderComponent} is disabled.
         * ```typescript
         * \@ViewChild("slider2")
         * public slider: IgxSliderComponent;
         * ngAfterViewInit(){
         *     let isDisabled = this.slider.disabled;
         * }
         * ```
         * @return {?}
         */
        function () {
            return this._disabled;
        },
        /**
         *An @Input property that disables or enables UI interaction.
         *```html
         *<igx-slider #slider [disabled]="'true'" [(ngModel)]="task.percentCompleted" [step]="5" [lowerBound]="20">
         *```
         */
        set: /**
         * An \@Input property that disables or enables UI interaction.
         * ```html
         * <igx-slider #slider [disabled]="'true'" [(ngModel)]="task.percentCompleted" [step]="5" [lowerBound]="20">
         * ```
         * @param {?} disable
         * @return {?}
         */
        function (disable) {
            this._disabled = disable;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxSliderComponent.prototype, "continuous", {
        /**
         * Returns if the {@link IgxSliderComponent} is set as continuous.
         * ```typescript
         * @ViewChild("slider2")
         * public slider: IgxSliderComponent;
         * ngAfterViewInit(){
         *     let continuous = this.slider.continuous;
         * }
         * ```
         */
        get: /**
         * Returns if the {\@link IgxSliderComponent} is set as continuous.
         * ```typescript
         * \@ViewChild("slider2")
         * public slider: IgxSliderComponent;
         * ngAfterViewInit(){
         *     let continuous = this.slider.continuous;
         * }
         * ```
         * @return {?}
         */
        function () {
            return this._countinuous;
        },
        /**
         * An @Input property that marks the {@link IgxSliderComponent} as continuous.
         * By default is considered that the {@link IgxSliderComponent} is discrete.
         * Discrete {@link IgxSliderComponent} does not have ticks and does not shows bubble labels for values.
         * ```html
         * <igx-slider #slider [continuous]="'true'" [(ngModel)]="task.percentCompleted" [step]="5" [lowerBound]="20">
         * ```
         */
        set: /**
         * An \@Input property that marks the {\@link IgxSliderComponent} as continuous.
         * By default is considered that the {\@link IgxSliderComponent} is discrete.
         * Discrete {\@link IgxSliderComponent} does not have ticks and does not shows bubble labels for values.
         * ```html
         * <igx-slider #slider [continuous]="'true'" [(ngModel)]="task.percentCompleted" [step]="5" [lowerBound]="20">
         * ```
         * @param {?} continuous
         * @return {?}
         */
        function (continuous) {
            if (this.labelsViewEnabled) {
                return;
            }
            this._countinuous = continuous;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxSliderComponent.prototype, "isContinuous", {
        /**
         * Returns if the {@link IgxSliderComponent} is set as continuous.
         * ```typescript
         * @ViewChild("slider2")
         * public slider: IgxSliderComponent;
         * ngAfterViewInit(){
         *     let continuous = this.slider.continuous;
         * }
         * ```
         */
        get: /**
         * Returns if the {\@link IgxSliderComponent} is set as continuous.
         * ```typescript
         * \@ViewChild("slider2")
         * public slider: IgxSliderComponent;
         * ngAfterViewInit(){
         *     let continuous = this.slider.continuous;
         * }
         * ```
         * @return {?}
         */
        function () {
            return this.continuous;
        },
        /**
         * @hidden
         * @internal
         */
        set: /**
         * @hidden
         * \@internal
         * @param {?} continuous
         * @return {?}
         */
        function (continuous) {
            this.continuous = continuous;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxSliderComponent.prototype, "maxValue", {
        /**
         * Returns the maximum value for the {@link IgxSliderComponent}.
         * ```typescript
         *@ViewChild("slider")
         *public slider: IgxSliderComponent;
         *ngAfterViewInit(){
         *    let sliderMax = this.slider.maxValue;
         *}
         * ```
         */
        get: /**
         * Returns the maximum value for the {\@link IgxSliderComponent}.
         * ```typescript
         * \@ViewChild("slider")
         * public slider: IgxSliderComponent;
         * ngAfterViewInit(){
         *    let sliderMax = this.slider.maxValue;
         * }
         * ```
         * @return {?}
         */
        function () {
            return this.labelsViewEnabled ?
                this.labels.length - 1 :
                this._maxValue;
        },
        /**
         * Sets the maximal value for the `IgxSliderComponent`.
         * The default maximum value is 100.
         * ```html
         * <igx-slider [type]="sliderType" [minValue]="56" [maxValue]="256">
         * ```
         */
        set: /**
         * Sets the maximal value for the `IgxSliderComponent`.
         * The default maximum value is 100.
         * ```html
         * <igx-slider [type]="sliderType" [minValue]="56" [maxValue]="256">
         * ```
         * @param {?} value
         * @return {?}
         */
        function (value) {
            if (value <= this._minValue) {
                this._maxValue = this._minValue + 1;
            }
            else {
                this._maxValue = value;
            }
            if (value < this.lowerBound) {
                this.updateLowerBoundAndMinTravelZone();
                this.upperBound = value;
            }
            // refresh max travel zone limits.
            this._pMax = 1;
            // recalculate step distance.
            this.stepDistance = this.calculateStepDistance();
            this.positionHandlesAndUpdateTrack();
            this.setTickInterval(null);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxSliderComponent.prototype, "minValue", {
        /**
         *Returns the minimal value of the `IgxSliderComponent`.
         *```typescript
         *@ViewChild("slider2")
         *public slider: IgxSliderComponent;
         *ngAfterViewInit(){
         *    let sliderMin = this.slider.minValue;
         *}
         *```
         */
        get: /**
         * Returns the minimal value of the `IgxSliderComponent`.
         * ```typescript
         * \@ViewChild("slider2")
         * public slider: IgxSliderComponent;
         * ngAfterViewInit(){
         *    let sliderMin = this.slider.minValue;
         * }
         * ```
         * @return {?}
         */
        function () {
            if (this.labelsViewEnabled) {
                return 0;
            }
            return this._minValue;
        },
        /**
         * Sets the minimal value for the `IgxSliderComponent`.
         * The default minimal value is 0.
         * ```html
         * <igx-slider [type]="sliderType" [minValue]="56" [maxValue]="100">
         * ```
         */
        set: /**
         * Sets the minimal value for the `IgxSliderComponent`.
         * The default minimal value is 0.
         * ```html
         * <igx-slider [type]="sliderType" [minValue]="56" [maxValue]="100">
         * ```
         * @param {?} value
         * @return {?}
         */
        function (value) {
            if (value >= this.maxValue) {
                this._minValue = this.maxValue - 1;
            }
            else {
                this._minValue = value;
            }
            if (value > this.upperBound) {
                this.updateUpperBoundAndMaxTravelZone();
                this.lowerBound = value;
            }
            // Refresh min travel zone limit.
            this._pMin = 0;
            // Recalculate step distance.
            this.stepDistance = this.calculateStepDistance();
            this.positionHandlesAndUpdateTrack();
            this.setTickInterval(null);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxSliderComponent.prototype, "lowerBound", {
        /**
         * Returns the lower boundary of the `IgxSliderComponent`.
         *```typescript
         *@ViewChild("slider")
         *public slider: IgxSliderComponent;
         *ngAfterViewInit(){
         *    let sliderLowBound = this.slider.lowerBound;
         *}
         *```
         */
        get: /**
         * Returns the lower boundary of the `IgxSliderComponent`.
         * ```typescript
         * \@ViewChild("slider")
         * public slider: IgxSliderComponent;
         * ngAfterViewInit(){
         *    let sliderLowBound = this.slider.lowerBound;
         * }
         * ```
         * @return {?}
         */
        function () {
            if (!Number.isNaN(this._lowerBound) && this._lowerBound !== undefined) {
                return this.valueInRange(this._lowerBound, this.minValue, this.maxValue);
            }
            return this.minValue;
        },
        /**
         * Sets the lower boundary of the `IgxSliderComponent`.
         * If not set is the same as min value.
         * ```html
         * <igx-slider [step]="5" [lowerBound]="20">
         * ```
         */
        set: /**
         * Sets the lower boundary of the `IgxSliderComponent`.
         * If not set is the same as min value.
         * ```html
         * <igx-slider [step]="5" [lowerBound]="20">
         * ```
         * @param {?} value
         * @return {?}
         */
        function (value) {
            if (value >= this.upperBound || (this.labelsViewEnabled && value < 0)) {
                return;
            }
            this._lowerBound = this.valueInRange(value, this.minValue, this.maxValue);
            // Refresh time travel zone.
            this._pMin = this.valueToFraction(this._lowerBound) || 0;
            this.positionHandlesAndUpdateTrack();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxSliderComponent.prototype, "upperBound", {
        /**
         * Returns the upper boundary of the `IgxSliderComponent`.
         * ```typescript
         *@ViewChild("slider")
         *public slider: IgxSliderComponent;
         *ngAfterViewInit(){
         *    let sliderUpBound = this.slider.upperBound;
         *}
         * ```
         */
        get: /**
         * Returns the upper boundary of the `IgxSliderComponent`.
         * ```typescript
         * \@ViewChild("slider")
         * public slider: IgxSliderComponent;
         * ngAfterViewInit(){
         *    let sliderUpBound = this.slider.upperBound;
         * }
         * ```
         * @return {?}
         */
        function () {
            if (!Number.isNaN(this._upperBound) && this._upperBound !== undefined) {
                return this.valueInRange(this._upperBound, this.minValue, this.maxValue);
            }
            return this.maxValue;
        },
        /**
         * Sets the upper boundary of the `IgxSliderComponent`.
         * If not set is the same as max value.
         * ```html
         * <igx-slider [step]="5" [upperBound]="20">
         * ```
         */
        set: /**
         * Sets the upper boundary of the `IgxSliderComponent`.
         * If not set is the same as max value.
         * ```html
         * <igx-slider [step]="5" [upperBound]="20">
         * ```
         * @param {?} value
         * @return {?}
         */
        function (value) {
            if (value <= this.lowerBound || (this.labelsViewEnabled && value > this.labels.length - 1)) {
                return;
            }
            this._upperBound = this.valueInRange(value, this.minValue, this.maxValue);
            // Refresh time travel zone.
            this._pMax = this.valueToFraction(this._upperBound) || 1;
            this.positionHandlesAndUpdateTrack();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxSliderComponent.prototype, "value", {
        /**
         * Returns the slider value. If the slider is of type {@link SliderType.SLIDER} the returned value is number.
         * If the slider type is {@link SliderType.RANGE} the returned value represents an object of {@link lowerValue} and {@link upperValue}.
         *```typescript
         *@ViewChild("slider2")
         *public slider: IgxSliderComponent;
         *public sliderValue(event){
         *    let sliderVal = this.slider.value;
         *}
         *```
         */
        get: /**
         * Returns the slider value. If the slider is of type {\@link SliderType.SLIDER} the returned value is number.
         * If the slider type is {\@link SliderType.RANGE} the returned value represents an object of {\@link lowerValue} and {\@link upperValue}.
         * ```typescript
         * \@ViewChild("slider2")
         * public slider: IgxSliderComponent;
         * public sliderValue(event){
         *    let sliderVal = this.slider.value;
         * }
         * ```
         * @return {?}
         */
        function () {
            if (this.isRange) {
                return {
                    lower: this.valueInRange(this.lowerValue, this.lowerBound, this.upperBound),
                    upper: this.valueInRange(this.upperValue, this.lowerBound, this.upperBound)
                };
            }
            else {
                return this.valueInRange(this.upperValue, this.lowerBound, this.upperBound);
            }
        },
        /**
         * Sets the slider value.
         * If the slider is of type {@link SliderType.SLIDER} the argument is number. By default the {@link value} gets the {@link lowerBound}.
         * If the slider type is {@link SliderType.RANGE} the argument
         * represents an object of {@link lowerValue} and {@link upperValue} properties.
         * By default the object is associated with the {@link lowerBound} and {@link upperBound} property values.
         * ```typescript
         *rangeValue = {
         *   lower: 30,
         *   upper: 60
         *};
         * ```
         * ```html
         * <igx-slider [type]="sliderType" [(ngModel)]="rangeValue" [minValue]="56" [maxValue]="256">
         * ```
         */
        set: /**
         * Sets the slider value.
         * If the slider is of type {\@link SliderType.SLIDER} the argument is number. By default the {\@link value} gets the {\@link lowerBound}.
         * If the slider type is {\@link SliderType.RANGE} the argument
         * represents an object of {\@link lowerValue} and {\@link upperValue} properties.
         * By default the object is associated with the {\@link lowerBound} and {\@link upperBound} property values.
         * ```typescript
         * rangeValue = {
         *   lower: 30,
         *   upper: 60
         * };
         * ```
         * ```html
         * <igx-slider [type]="sliderType" [(ngModel)]="rangeValue" [minValue]="56" [maxValue]="256">
         * ```
         * @param {?} value
         * @return {?}
         */
        function (value) {
            if (!this.isRange) {
                this.upperValue = (/** @type {?} */ (value));
            }
            else {
                value = this.validateInitialValue((/** @type {?} */ (value)));
                this.upperValue = ((/** @type {?} */ (value))).upper;
                this.lowerValue = ((/** @type {?} */ (value))).lower;
            }
            this._onChangeCallback(this.value);
            if (this._hasViewInit) {
                this.positionHandlesAndUpdateTrack();
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @hidden
     */
    /**
     * @hidden
     * @param {?} $event
     * @return {?}
     */
    IgxSliderComponent.prototype.onPointerDown = /**
     * @hidden
     * @param {?} $event
     * @return {?}
     */
    function ($event) {
        this.findClosestThumb($event);
        if (!this.thumbTo.isActive && this.thumbFrom === undefined) {
            return;
        }
        this.showThumbLabels();
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @return {?}
     */
    IgxSliderComponent.prototype.onPointerUp = /**
     * @hidden
     * @return {?}
     */
    function () {
        if (!this.thumbTo.isActive && this.thumbFrom === undefined) {
            return;
        }
        this.hideThumbLabels();
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @return {?}
     */
    IgxSliderComponent.prototype.onFocus = /**
     * @hidden
     * @return {?}
     */
    function () {
        this.toggleThumbLabels();
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @return {?}
     */
    IgxSliderComponent.prototype.onBlur = /**
     * @hidden
     * @return {?}
     */
    function () {
        this.hideThumbLabels();
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @param {?} $event
     * @return {?}
     */
    IgxSliderComponent.prototype.onPanListener = /**
     * @hidden
     * @param {?} $event
     * @return {?}
     */
    function ($event) {
        this.update($event.srcEvent.clientX);
    };
    /**
     * @return {?}
     */
    IgxSliderComponent.prototype.onPanStart = /**
     * @return {?}
     */
    function () {
        this.showThumbLabels();
    };
    /**
     * @return {?}
     */
    IgxSliderComponent.prototype.onPanEnd = /**
     * @return {?}
     */
    function () {
        this.hideThumbLabels();
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @param {?} $event
     * @return {?}
     */
    IgxSliderComponent.prototype.onTapListener = /**
     * @hidden
     * @param {?} $event
     * @return {?}
     */
    function ($event) {
        this.onTap($event);
    };
    Object.defineProperty(IgxSliderComponent.prototype, "isRange", {
        /**
         *Returns whether the `IgxSliderComponent` type is RANGE.
         *```typescript
         *@ViewChild("slider")
         *public slider: IgxSliderComponent;
         *ngAfterViewInit(){
         *    let sliderRange = this.slider.isRange;
         *}
         * ```
         */
        get: /**
         * Returns whether the `IgxSliderComponent` type is RANGE.
         * ```typescript
         * \@ViewChild("slider")
         * public slider: IgxSliderComponent;
         * ngAfterViewInit(){
         *    let sliderRange = this.slider.isRange;
         * }
         * ```
         * @return {?}
         */
        function () {
            return this.type === SliderType.RANGE;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxSliderComponent.prototype, "lowerValue", {
        /**
         * Returns the lower value of the `IgxSliderComponent`.
         * ```typescript
         * @ViewChild("slider")
         * public slider: IgxSliderComponent;
         * public lowValue(event){
         *    let sliderLowValue = this.slider.lowerValue;
         *}
         *```
         */
        get: /**
         * Returns the lower value of the `IgxSliderComponent`.
         * ```typescript
         * \@ViewChild("slider")
         * public slider: IgxSliderComponent;
         * public lowValue(event){
         *    let sliderLowValue = this.slider.lowerValue;
         * }
         * ```
         * @return {?}
         */
        function () {
            if (!Number.isNaN(this._lowerValue) && this._lowerValue !== undefined && this._lowerValue >= this.lowerBound) {
                return this._lowerValue;
            }
            return this.lowerBound;
        },
        /**
         *Sets the lower value of the `IgxSliderComponent`.
         *```typescript
         *@ViewChild("slider2")
         *public slider: IgxSliderComponent;
         *public lowValue(event){
         *    this.slider.lowerValue = 120;
         *}
         *```
         */
        set: /**
         * Sets the lower value of the `IgxSliderComponent`.
         * ```typescript
         * \@ViewChild("slider2")
         * public slider: IgxSliderComponent;
         * public lowValue(event){
         *    this.slider.lowerValue = 120;
         * }
         * ```
         * @param {?} value
         * @return {?}
         */
        function (value) {
            value = this.valueInRange(value, this.lowerBound, this.upperBound);
            this._lowerValue = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxSliderComponent.prototype, "upperValue", {
        /**
         *Returns the upper value of the `IgxSliderComponent`.
         *```typescript
         *@ViewChild("slider2")
         *public slider: IgxSliderComponent;
         *public upperValue(event){
         *    let upperValue = this.slider.upperValue;
         *}
         *```
         */
        get: /**
         * Returns the upper value of the `IgxSliderComponent`.
         * ```typescript
         * \@ViewChild("slider2")
         * public slider: IgxSliderComponent;
         * public upperValue(event){
         *    let upperValue = this.slider.upperValue;
         * }
         * ```
         * @return {?}
         */
        function () {
            if (!Number.isNaN(this._upperValue) && this._upperValue !== undefined && this._upperValue <= this.upperBound) {
                return this._upperValue;
            }
            return this.upperBound;
        },
        /**
         *Sets the upper value of the `IgxSliderComponent`.
         *```typescript
         *@ViewChild("slider2")
         *public slider: IgxSliderComponent;
         *public upperValue(event){
         *    this.slider.upperValue = 120;
         *}
         *```
         */
        set: /**
         * Sets the upper value of the `IgxSliderComponent`.
         * ```typescript
         * \@ViewChild("slider2")
         * public slider: IgxSliderComponent;
         * public upperValue(event){
         *    this.slider.upperValue = 120;
         * }
         * ```
         * @param {?} value
         * @return {?}
         */
        function (value) {
            value = this.valueInRange(value, this.lowerBound, this.upperBound);
            this._upperValue = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxSliderComponent.prototype, "lowerLabel", {
        /**
         * Returns the value corresponding the lower label.
         *```typescript
         * @ViewChild("slider")
         * public slider: IgxSliderComponent;
         * let label = this.slider.lowerLabel;
         *```
         */
        get: /**
         * Returns the value corresponding the lower label.
         * ```typescript
         * \@ViewChild("slider")
         * public slider: IgxSliderComponent;
         * let label = this.slider.lowerLabel;
         * ```
         * @return {?}
         */
        function () {
            return this.labelsViewEnabled ?
                this.labels[this.lowerValue] :
                this.lowerValue;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxSliderComponent.prototype, "upperLabel", {
        /**
         * Returns the value corresponding the upper label.
         *```typescript
         * @ViewChild("slider")
         * public slider: IgxSliderComponent;
         * let label = this.slider.upperLabel;
         *```
         */
        get: /**
         * Returns the value corresponding the upper label.
         * ```typescript
         * \@ViewChild("slider")
         * public slider: IgxSliderComponent;
         * let label = this.slider.upperLabel;
         * ```
         * @return {?}
         */
        function () {
            return this.labelsViewEnabled ?
                this.labels[this.upperValue] :
                this.upperValue;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxSliderComponent.prototype, "labelsViewEnabled", {
        /**
         * Returns if label view is enabled.
         * If the {@link labels} is set, the view is automatically activated.
         *```typescript
         * @ViewChild("slider")
         * public slider: IgxSliderComponent;
         * let labelView = this.slider.labelsViewEnabled;
         *```
         */
        get: /**
         * Returns if label view is enabled.
         * If the {\@link labels} is set, the view is automatically activated.
         * ```typescript
         * \@ViewChild("slider")
         * public slider: IgxSliderComponent;
         * let labelView = this.slider.labelsViewEnabled;
         * ```
         * @return {?}
         */
        function () {
            return !!(this.labels && this.labels.length > 1);
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @hidden
     */
    /**
     * @hidden
     * @return {?}
     */
    IgxSliderComponent.prototype.ngOnInit = /**
     * @hidden
     * @return {?}
     */
    function () {
        this.sliderSetup();
        // Set track travel zone
        this._pMin = this.valueToFraction(this.lowerBound) || 0;
        this._pMax = this.valueToFraction(this.upperBound) || 1;
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @return {?}
     */
    IgxSliderComponent.prototype.ngAfterViewInit = /**
     * @hidden
     * @return {?}
     */
    function () {
        var _this = this;
        this._hasViewInit = true;
        this.positionHandlesAndUpdateTrack();
        this.setTickInterval(this.labels);
        this.subscribeTo(this.thumbFrom, this.thumbChanged.bind(this));
        this.subscribeTo(this.thumbTo, this.thumbChanged.bind(this));
        this.thumbs.changes.pipe(takeUntil(this._destroy$)).subscribe(function (change) {
            /** @type {?} */
            var t = change.find(function (thumb) { return thumb.type === SliderHandle.FROM; });
            _this.positionHandle(t, _this.lowerValue);
            _this.subscribeTo(t, _this.thumbChanged.bind(_this));
        });
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @return {?}
     */
    IgxSliderComponent.prototype.ngAfterContentInit = /**
     * @hidden
     * @return {?}
     */
    function () {
        // Calculates the distance between every step in pixels.
        this.stepDistance = this.calculateStepDistance();
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @return {?}
     */
    IgxSliderComponent.prototype.ngOnDestroy = /**
     * @hidden
     * @return {?}
     */
    function () {
        this._destroy$.next(true);
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @param {?} value
     * @return {?}
     */
    IgxSliderComponent.prototype.writeValue = /**
     * @hidden
     * @param {?} value
     * @return {?}
     */
    function (value) {
        if (!value) {
            return;
        }
        this.value = value;
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @param {?} fn
     * @return {?}
     */
    IgxSliderComponent.prototype.registerOnChange = /**
     * @hidden
     * @param {?} fn
     * @return {?}
     */
    function (fn) {
        this._onChangeCallback = fn;
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @param {?} fn
     * @return {?}
     */
    IgxSliderComponent.prototype.registerOnTouched = /**
     * @hidden
     * @param {?} fn
     * @return {?}
     */
    function (fn) {
        this._onTouchedCallback = fn;
    };
    /** @hidden */
    /**
     * @hidden
     * @return {?}
     */
    IgxSliderComponent.prototype.getEditElement = /**
     * @hidden
     * @return {?}
     */
    function () {
        return this.isRange ? this.thumbFrom.nativeElement : this.thumbTo.nativeElement;
    };
    /**
     *
     * @hidden
     */
    /**
     *
     * @hidden
     * @param {?} $event
     * @return {?}
     */
    IgxSliderComponent.prototype.onTap = /**
     *
     * @hidden
     * @param {?} $event
     * @return {?}
     */
    function ($event) {
        this.update($event.srcEvent.clientX);
    };
    /**
     *
     * @hidden
     */
    /**
     *
     * @hidden
     * @param {?} mouseX
     * @return {?}
     */
    IgxSliderComponent.prototype.update = /**
     *
     * @hidden
     * @param {?} mouseX
     * @return {?}
     */
    function (mouseX) {
        if (this.disabled) {
            return;
        }
        // Update To/From Values
        this.onPan.next(mouseX);
        // Finally do positionHandlesAndUpdateTrack the DOM
        // based on data values
        this.positionHandlesAndUpdateTrack();
        this._onTouchedCallback();
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @param {?} value
     * @param {?} thumbType
     * @return {?}
     */
    IgxSliderComponent.prototype.thumbChanged = /**
     * @hidden
     * @param {?} value
     * @param {?} thumbType
     * @return {?}
     */
    function (value, thumbType) {
        /** @type {?} */
        var oldValue = this.value;
        /** @type {?} */
        var newVal;
        if (this.isRange) {
            if (thumbType === SliderHandle.FROM) {
                newVal = {
                    lower: ((/** @type {?} */ (this.value))).lower + value,
                    upper: ((/** @type {?} */ (this.value))).upper
                };
            }
            else {
                newVal = {
                    lower: ((/** @type {?} */ (this.value))).lower,
                    upper: ((/** @type {?} */ (this.value))).upper + value
                };
            }
            // Swap the thumbs if a collision appears.
            if (newVal.lower >= newVal.upper) {
                this.value = this.swapThumb(newVal);
            }
            else {
                this.value = newVal;
            }
        }
        else {
            this.value = (/** @type {?} */ (this.value)) + value;
        }
        if (this.hasValueChanged(oldValue)) {
            this.emitValueChanged(oldValue);
        }
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @return {?}
     */
    IgxSliderComponent.prototype.onThumbChange = /**
     * @hidden
     * @return {?}
     */
    function () {
        this.toggleThumbLabels();
    };
    /**
     * @private
     * @param {?} value
     * @return {?}
     */
    IgxSliderComponent.prototype.swapThumb = /**
     * @private
     * @param {?} value
     * @return {?}
     */
    function (value) {
        if (this.thumbFrom.isActive) {
            value.upper = this.upperValue;
            value.lower = this.upperValue;
        }
        else {
            value.upper = this.lowerValue;
            value.lower = this.lowerValue;
        }
        this.toggleThumb();
        return value;
    };
    /**
     * @private
     * @param {?} event
     * @return {?}
     */
    IgxSliderComponent.prototype.findClosestThumb = /**
     * @private
     * @param {?} event
     * @return {?}
     */
    function (event) {
        if (this.isRange) {
            this.closestHandle(event.clientX);
        }
        else {
            this.thumbTo.nativeElement.focus();
        }
        this.update(event.clientX);
        event.preventDefault();
    };
    /**
     * @private
     * @return {?}
     */
    IgxSliderComponent.prototype.updateLowerBoundAndMinTravelZone = /**
     * @private
     * @return {?}
     */
    function () {
        this.lowerBound = this.minValue;
        this._pMin = 0;
    };
    /**
     * @private
     * @return {?}
     */
    IgxSliderComponent.prototype.updateUpperBoundAndMaxTravelZone = /**
     * @private
     * @return {?}
     */
    function () {
        this.upperBound = this.maxValue;
        this._pMax = 1;
    };
    /**
     * @private
     * @return {?}
     */
    IgxSliderComponent.prototype.sliderSetup = /**
     * @private
     * @return {?}
     */
    function () {
        /**
         * if {@link SliderType.SLIDER} than the initial value shold be the lowest one.
         */
        if (!this.isRange && this.value === this.upperBound) {
            this.value = this.lowerBound;
        }
    };
    /**
     * @private
     * @return {?}
     */
    IgxSliderComponent.prototype.calculateStepDistance = /**
     * @private
     * @return {?}
     */
    function () {
        return this._el.nativeElement.getBoundingClientRect().width / (this.maxValue - this.minValue) * this.step;
    };
    /**
     * @private
     * @return {?}
     */
    IgxSliderComponent.prototype.toggleThumb = /**
     * @private
     * @return {?}
     */
    function () {
        return this.thumbFrom.isActive ?
            this.thumbTo.nativeElement.focus() :
            this.thumbFrom.nativeElement.focus();
    };
    /**
     * @private
     * @param {?} value
     * @param {?=} min
     * @param {?=} max
     * @return {?}
     */
    IgxSliderComponent.prototype.valueInRange = /**
     * @private
     * @param {?} value
     * @param {?=} min
     * @param {?=} max
     * @return {?}
     */
    function (value, min, max) {
        if (min === void 0) { min = 0; }
        if (max === void 0) { max = 100; }
        return Math.max(Math.min(value, max), min);
    };
    /**
     * @private
     * @param {?} color
     * @param {?} interval
     * @return {?}
     */
    IgxSliderComponent.prototype.generateTickMarks = /**
     * @private
     * @param {?} color
     * @param {?} interval
     * @return {?}
     */
    function (color, interval) {
        return interval !== null ? "repeating-linear-gradient(\n            " + 'to left' + ",\n            " + color + ",\n            " + color + " 1.5px,\n            transparent 1.5px,\n            transparent " + interval + "%\n        ), repeating-linear-gradient(\n            " + 'to right' + ",\n            " + color + ",\n            " + color + " 1.5px,\n            transparent 1.5px,\n            transparent " + interval + "%\n        )" : interval;
    };
    /**
     * @private
     * @param {?} handle
     * @param {?} position
     * @return {?}
     */
    IgxSliderComponent.prototype.positionHandle = /**
     * @private
     * @param {?} handle
     * @param {?} position
     * @return {?}
     */
    function (handle, position) {
        if (!handle) {
            return;
        }
        handle.nativeElement.style.left = this.valueToFraction(position) * 100 + "%";
    };
    /**
     * @private
     * @return {?}
     */
    IgxSliderComponent.prototype.positionHandlesAndUpdateTrack = /**
     * @private
     * @return {?}
     */
    function () {
        if (!this.isRange) {
            this.positionHandle(this.thumbTo, (/** @type {?} */ (this.value)));
        }
        else {
            this.positionHandle(this.thumbTo, ((/** @type {?} */ (this.value))).upper);
            this.positionHandle(this.thumbFrom, ((/** @type {?} */ (this.value))).lower);
        }
        this.updateTrack();
    };
    /**
     * @private
     * @param {?} mouseX
     * @return {?}
     */
    IgxSliderComponent.prototype.closestHandle = /**
     * @private
     * @param {?} mouseX
     * @return {?}
     */
    function (mouseX) {
        /** @type {?} */
        var fromOffset = this.thumbFrom.nativeElement.offsetLeft + this.thumbFrom.nativeElement.offsetWidth / 2;
        /** @type {?} */
        var toOffset = this.thumbTo.nativeElement.offsetLeft + this.thumbTo.nativeElement.offsetWidth / 2;
        /** @type {?} */
        var xPointer = mouseX - this._el.nativeElement.getBoundingClientRect().left;
        /** @type {?} */
        var match = this.closestTo(xPointer, [fromOffset, toOffset]);
        if (match === fromOffset) {
            this.thumbFrom.nativeElement.focus();
        }
        else if (match === toOffset) {
            this.thumbTo.nativeElement.focus();
        }
    };
    /**
     * @private
     * @param {?} labels
     * @return {?}
     */
    IgxSliderComponent.prototype.setTickInterval = /**
     * @private
     * @param {?} labels
     * @return {?}
     */
    function (labels) {
        if (this.continuous) {
            return;
        }
        /** @type {?} */
        var interval;
        /** @type {?} */
        var trackProgress = 100;
        if (this.labelsViewEnabled) {
            // Calc ticks depending on the labels length;
            interval = ((trackProgress / (this.labels.length - 1) * 10)) / 10;
        }
        else {
            /** @type {?} */
            var trackRange = this.maxValue - this.minValue;
            interval = this.step > 1 ?
                (trackProgress / ((trackRange / this.step)) * 10) / 10
                : null;
        }
        this.renderer.setStyle(this.ticks.nativeElement, 'background', this.generateTickMarks('white', interval));
    };
    /**
     * @private
     * @return {?}
     */
    IgxSliderComponent.prototype.showThumbLabels = /**
     * @private
     * @return {?}
     */
    function () {
        if (this.disabled) {
            return;
        }
        this.thumbTo.showThumbLabel();
        if (this.thumbFrom) {
            this.thumbFrom.showThumbLabel();
        }
    };
    /**
     * @private
     * @return {?}
     */
    IgxSliderComponent.prototype.hideThumbLabels = /**
     * @private
     * @return {?}
     */
    function () {
        if (this.disabled) {
            return;
        }
        this.thumbTo.hideThumbLabel();
        if (this.thumbFrom) {
            this.thumbFrom.hideThumbLabel();
        }
    };
    /**
     * @private
     * @return {?}
     */
    IgxSliderComponent.prototype.toggleThumbLabels = /**
     * @private
     * @return {?}
     */
    function () {
        this.showThumbLabels();
        this.hideThumbLabels();
    };
    /**
     * @private
     * @param {?} goal
     * @param {?} positions
     * @return {?}
     */
    IgxSliderComponent.prototype.closestTo = /**
     * @private
     * @param {?} goal
     * @param {?} positions
     * @return {?}
     */
    function (goal, positions) {
        return positions.reduce(function (previous, current) {
            return (Math.abs(goal - current) < Math.abs(goal - previous) ? current : previous);
        });
    };
    /**
     * @private
     * @param {?} value
     * @param {?=} pMin
     * @param {?=} pMax
     * @return {?}
     */
    IgxSliderComponent.prototype.valueToFraction = /**
     * @private
     * @param {?} value
     * @param {?=} pMin
     * @param {?=} pMax
     * @return {?}
     */
    function (value, pMin, pMax) {
        if (pMin === void 0) { pMin = this._pMin; }
        if (pMax === void 0) { pMax = this._pMax; }
        return this.valueInRange((value - this.minValue) / (this.maxValue - this.minValue), pMin, pMax);
    };
    /**
     * @private
     * @return {?}
     */
    IgxSliderComponent.prototype.updateTrack = /**
     * @private
     * @return {?}
     */
    function () {
        /** @type {?} */
        var fromPosition = this.valueToFraction(this.lowerValue);
        /** @type {?} */
        var toPosition = this.valueToFraction(this.upperValue);
        /** @type {?} */
        var positionGap = toPosition - fromPosition;
        /** @type {?} */
        var trackLeftIndention = fromPosition;
        if (this.isRange) {
            if (positionGap) {
                trackLeftIndention = Math.round((1 / positionGap * fromPosition) * 100);
            }
            this.renderer.setStyle(this.track.nativeElement, 'transform', "scaleX(" + positionGap + ") translateX(" + trackLeftIndention + "%)");
        }
        else {
            this.renderer.setStyle(this.track.nativeElement, 'transform', "scaleX(" + toPosition + ")");
        }
    };
    /**
     * @private
     * @param {?} value
     * @return {?}
     */
    IgxSliderComponent.prototype.validateInitialValue = /**
     * @private
     * @param {?} value
     * @return {?}
     */
    function (value) {
        if (value.lower < this.lowerBound && value.upper < this.lowerBound) {
            value.upper = this.lowerBound;
            value.lower = this.lowerBound;
        }
        if (value.lower > this.upperBound && value.upper > this.upperBound) {
            value.upper = this.upperBound;
            value.lower = this.upperBound;
        }
        if (value.upper < value.lower) {
            value.upper = this.upperValue;
            value.lower = this.lowerValue;
        }
        return value;
    };
    /**
     * @private
     * @param {?} thumb
     * @param {?} callback
     * @return {?}
     */
    IgxSliderComponent.prototype.subscribeTo = /**
     * @private
     * @param {?} thumb
     * @param {?} callback
     * @return {?}
     */
    function (thumb, callback) {
        if (!thumb) {
            return;
        }
        thumb.onThumbValueChange
            .pipe(takeUntil(this.unsubscriber(thumb)))
            .subscribe(function (value) { return callback(value, thumb.type); });
    };
    /**
     * @private
     * @param {?} thumb
     * @return {?}
     */
    IgxSliderComponent.prototype.unsubscriber = /**
     * @private
     * @param {?} thumb
     * @return {?}
     */
    function (thumb) {
        return merge(this._destroy$, thumb.destroy);
    };
    /**
     * @private
     * @param {?} oldValue
     * @return {?}
     */
    IgxSliderComponent.prototype.hasValueChanged = /**
     * @private
     * @param {?} oldValue
     * @return {?}
     */
    function (oldValue) {
        /** @type {?} */
        var isSliderWithDifferentValue = !this.isRange && oldValue !== this.value;
        /** @type {?} */
        var isRangeWithOneDifferentValue = this.isRange &&
            (((/** @type {?} */ (oldValue))).lower !== ((/** @type {?} */ (this.value))).lower ||
                ((/** @type {?} */ (oldValue))).upper !== ((/** @type {?} */ (this.value))).upper);
        return isSliderWithDifferentValue || isRangeWithOneDifferentValue;
    };
    /**
     * @private
     * @param {?} oldValue
     * @return {?}
     */
    IgxSliderComponent.prototype.emitValueChanged = /**
     * @private
     * @param {?} oldValue
     * @return {?}
     */
    function (oldValue) {
        this.onValueChange.emit({ oldValue: oldValue, value: this.value });
    };
    IgxSliderComponent.decorators = [
        { type: Component, args: [{
                    providers: [{ provide: NG_VALUE_ACCESSOR, useExisting: IgxSliderComponent, multi: true }],
                    selector: 'igx-slider',
                    template: "<div class=\"igx-slider__track\">\n    <div #track class=\"igx-slider__track-fill\"></div>\n    <div #ticks class=\"igx-slider__track-ticks\"></div>\n</div>\n<div class=\"igx-slider__thumbs\">\n    <igx-thumb *ngIf=\"isRange\"\n        #thumbFrom\n        [type]=\"0\"\n        [value]=\"lowerLabel\"\n        [disabled]=\"disabled\"\n        [continuous]=\"continuous\"\n        [onPan]=\"onPan\"\n        [stepDistance]=\"stepDistance\"\n        [step]=\"step\"\n        [fromHandler]=\"true\"\n        [templateRef]=\"thumbFromTemplateRef\"\n        [context]=\"context\"\n        (onChange)=\"onThumbChange()\"\n        [thumbLabelVisibilityDuration]=\"thumbLabelVisibilityDuration\"></igx-thumb>\n    <igx-thumb\n        #thumbTo\n        [type]=\"1\"\n        [value]=\"upperLabel\"\n        [disabled]=\"disabled\"\n        [continuous]=\"continuous\"\n        [onPan]=\"onPan\"\n        [stepDistance]=\"stepDistance\"\n        [step]=\"step\"\n        [templateRef]=\"thumbToTemplateRef\"\n        [context]=\"context\"\n        (onChange)=\"onThumbChange()\"\n        [thumbLabelVisibilityDuration]=\"thumbLabelVisibilityDuration\"></igx-thumb>\n</div>\n",
                    styles: ["\n        :host {\n            display: block;\n        }\n    "]
                }] }
    ];
    /** @nocollapse */
    IgxSliderComponent.ctorParameters = function () { return [
        { type: Renderer2 },
        { type: ElementRef }
    ]; };
    IgxSliderComponent.propDecorators = {
        track: [{ type: ViewChild, args: ['track',] }],
        ticks: [{ type: ViewChild, args: ['ticks',] }],
        thumbs: [{ type: ViewChildren, args: [IgxSliderThumbComponent,] }],
        thumbFromTemplateRef: [{ type: ContentChild, args: [IgxThumbFromTemplateDirective, { read: TemplateRef },] }],
        thumbToTemplateRef: [{ type: ContentChild, args: [IgxThumbToTemplateDirective, { read: TemplateRef },] }],
        role: [{ type: HostBinding, args: ["attr.role",] }],
        valuemin: [{ type: HostBinding, args: ["attr.aria-valuemin",] }],
        valuemax: [{ type: HostBinding, args: ["attr.aria-valuemax",] }],
        readonly: [{ type: HostBinding, args: ["attr.aria-readonly",] }],
        slierClass: [{ type: HostBinding, args: ['class.igx-slider',] }],
        disabledClass: [{ type: HostBinding, args: ['class.igx-slider--disabled',] }],
        id: [{ type: HostBinding, args: ['attr.id',] }, { type: Input }],
        type: [{ type: Input }],
        thumbLabelVisibilityDuration: [{ type: Input }],
        labels: [{ type: Input }],
        step: [{ type: Input }],
        disabled: [{ type: Input }],
        continuous: [{ type: Input }],
        isContinuous: [{ type: Input }],
        maxValue: [{ type: Input }],
        minValue: [{ type: Input }],
        lowerBound: [{ type: Input }],
        upperBound: [{ type: Input }],
        value: [{ type: Input }],
        onValueChange: [{ type: Output }],
        onPointerDown: [{ type: HostListener, args: ['pointerdown', ['$event'],] }],
        onPointerUp: [{ type: HostListener, args: ['pointerup',] }],
        onFocus: [{ type: HostListener, args: ['focus',] }],
        onBlur: [{ type: HostListener, args: ['blur',] }],
        onPanListener: [{ type: HostListener, args: ['pan', ['$event'],] }],
        onPanStart: [{ type: HostListener, args: ['panstart',] }],
        onPanEnd: [{ type: HostListener, args: ['panend',] }],
        onTapListener: [{ type: HostListener, args: ['tap', ['$event'],] }]
    };
    tslib_1.__decorate([
        DeprecateProperty("IgxSliderComponent `isContinuous` property is deprecated.\nUse `continuous` instead."),
        tslib_1.__metadata("design:type", Boolean),
        tslib_1.__metadata("design:paramtypes", [Boolean])
    ], IgxSliderComponent.prototype, "isContinuous", null);
    return IgxSliderComponent;
}());
export { IgxSliderComponent };
if (false) {
    /**
     * @type {?}
     * @private
     */
    IgxSliderComponent.prototype._pMin;
    /**
     * @type {?}
     * @private
     */
    IgxSliderComponent.prototype._pMax;
    /**
     * @type {?}
     * @private
     */
    IgxSliderComponent.prototype._hasViewInit;
    /**
     * @type {?}
     * @private
     */
    IgxSliderComponent.prototype._minValue;
    /**
     * @type {?}
     * @private
     */
    IgxSliderComponent.prototype._maxValue;
    /**
     * @type {?}
     * @private
     */
    IgxSliderComponent.prototype._lowerBound;
    /**
     * @type {?}
     * @private
     */
    IgxSliderComponent.prototype._upperBound;
    /**
     * @type {?}
     * @private
     */
    IgxSliderComponent.prototype._lowerValue;
    /**
     * @type {?}
     * @private
     */
    IgxSliderComponent.prototype._upperValue;
    /**
     * @type {?}
     * @private
     */
    IgxSliderComponent.prototype._countinuous;
    /**
     * @type {?}
     * @private
     */
    IgxSliderComponent.prototype._disabled;
    /**
     * @type {?}
     * @private
     */
    IgxSliderComponent.prototype._step;
    /**
     * @type {?}
     * @private
     */
    IgxSliderComponent.prototype._labels;
    /**
     * @type {?}
     * @private
     */
    IgxSliderComponent.prototype._type;
    /**
     * @type {?}
     * @private
     */
    IgxSliderComponent.prototype._destroy$;
    /**
     * @type {?}
     * @private
     */
    IgxSliderComponent.prototype._onChangeCallback;
    /**
     * @type {?}
     * @private
     */
    IgxSliderComponent.prototype._onTouchedCallback;
    /**
     * @hidden
     * @type {?}
     * @private
     */
    IgxSliderComponent.prototype.track;
    /**
     * @hidden
     * @type {?}
     * @private
     */
    IgxSliderComponent.prototype.ticks;
    /**
     * @hidden
     * @type {?}
     * @private
     */
    IgxSliderComponent.prototype.thumbs;
    /**
     * @hidden
     * @type {?}
     */
    IgxSliderComponent.prototype.stepDistance;
    /**
     * @hidden
     * @type {?}
     */
    IgxSliderComponent.prototype.onPan;
    /**
     * @hidden
     * @type {?}
     */
    IgxSliderComponent.prototype.thumbFromTemplateRef;
    /**
     * @hidden
     * @type {?}
     */
    IgxSliderComponent.prototype.thumbToTemplateRef;
    /**
     * @hidden
     * @type {?}
     */
    IgxSliderComponent.prototype.role;
    /**
     * @hidden
     * @type {?}
     */
    IgxSliderComponent.prototype.slierClass;
    /**
     * An \@Input property that sets the value of the `id` attribute.
     * If not provided it will be automatically generated.
     * ```html
     * <igx-slider [id]="'igx-slider-32'" [(ngModel)]="task.percentCompleted" [step]="5" [lowerBound]="20">
     * ```
     * @type {?}
     */
    IgxSliderComponent.prototype.id;
    /**
     * An \@Input property that sets the duration visibility of thumbs labels. The default value is 750 milliseconds.
     * ```html
     * <igx-slider #slider [thumbLabelVisibilityDuration]="3000" [(ngModel)]="task.percentCompleted" [step]="5">
     * ```
     * @type {?}
     */
    IgxSliderComponent.prototype.thumbLabelVisibilityDuration;
    /**
     * This event is emitted when user has stopped interacting the thumb and value is changed.
     * ```typescript
     * public change(event){
     *    alert("The value has been changed!");
     * }
     * ```
     * ```html
     * <igx-slider (onValueChange)="change($event)" #slider [(ngModel)]="task.percentCompleted" [step]="5">
     * ```
     * @type {?}
     */
    IgxSliderComponent.prototype.onValueChange;
    /**
     * @type {?}
     * @private
     */
    IgxSliderComponent.prototype.renderer;
    /**
     * @type {?}
     * @private
     */
    IgxSliderComponent.prototype._el;
}
/**
 * @hidden
 */
var IgxSliderModule = /** @class */ (function () {
    function IgxSliderModule() {
    }
    IgxSliderModule.decorators = [
        { type: NgModule, args: [{
                    declarations: [IgxSliderComponent, IgxThumbFromTemplateDirective, IgxThumbToTemplateDirective, IgxSliderThumbComponent],
                    exports: [IgxSliderComponent, IgxThumbFromTemplateDirective, IgxThumbToTemplateDirective, IgxSliderThumbComponent],
                    imports: [CommonModule]
                },] }
    ];
    return IgxSliderModule;
}());
export { IgxSliderModule };
export { Éµ0 };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2xpZGVyLmNvbXBvbmVudC5qcyIsInNvdXJjZVJvb3QiOiJuZzovL2lnbml0ZXVpLWFuZ3VsYXIvIiwic291cmNlcyI6WyJsaWIvc2xpZGVyL3NsaWRlci5jb21wb25lbnQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQSxPQUFPLEVBQUUsWUFBWSxFQUFFLE1BQU0saUJBQWlCLENBQUM7QUFDL0MsT0FBTyxFQUNZLFNBQVMsRUFBRSxVQUFVLEVBQUUsWUFBWSxFQUNsRCxXQUFXLEVBQUUsS0FBSyxFQUFFLFFBQVEsRUFBVSxNQUFNLEVBQUUsU0FBUyxFQUN2RCxTQUFTLEVBQ1QsV0FBVyxFQUNYLFlBQVksRUFHWixZQUFZLEVBQ1osWUFBWSxFQUNaLFNBQVMsRUFDWixNQUFNLGVBQWUsQ0FBQztBQUN2QixPQUFPLEVBQXdCLGlCQUFpQixFQUFFLE1BQU0sZ0JBQWdCLENBQUM7QUFFekUsT0FBTyxFQUFFLGlCQUFpQixFQUFFLE1BQU0sNkJBQTZCLENBQUM7QUFDaEUsT0FBTyxFQUFFLHVCQUF1QixFQUFFLE1BQU0sZ0NBQWdDLENBQUM7QUFDekUsT0FBTyxFQUFFLE9BQU8sRUFBRSxLQUFLLEVBQUUsTUFBTSxNQUFNLENBQUM7QUFDdEMsT0FBTyxFQUFFLFNBQVMsRUFBRSxNQUFNLGdCQUFnQixDQUFDO0FBQzNDLE9BQU8sRUFBRSxZQUFZLEVBQ2pCLDZCQUE2QixFQUM3QiwyQkFBMkIsRUFFM0IsVUFBVSxFQUViLE1BQU0saUJBQWlCLENBQUM7O0lBR25CLElBQUksR0FBRztBQUNiLENBQUM7OztJQUVHLE9BQU8sR0FBRyxDQUFDOzs7Ozs7Ozs7Ozs7Ozs7O0FBaUJmO0lBK2pCSSw0QkFBb0IsUUFBbUIsRUFBVSxHQUFlO1FBQTVDLGFBQVEsR0FBUixRQUFRLENBQVc7UUFBVSxRQUFHLEdBQUgsR0FBRyxDQUFZOztRQTVpQnhELFVBQUssR0FBRyxDQUFDLENBQUM7UUFDVixVQUFLLEdBQUcsQ0FBQyxDQUFDOztRQUdWLGlCQUFZLEdBQUcs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Ozs7OztJQTRYMUMsMkNBQ3VFOzs7OztJQUczRCxzQ0FBMkI7Ozs7O0lBQUUsaUNBQXVCOzs7OztBQXFqQnBFO0lBQUE7SUFNQSxDQUFDOztnQkFOQSxRQUFRLFNBQUM7b0JBQ04sWUFBWSxFQUFFLENBQUMsa0JBQWtCLEVBQUUsNkJBQTZCLEVBQUUsMkJBQTJCLEVBQUUsdUJBQXVCLENBQUM7b0JBQ3ZILE9BQU8sRUFBRSxDQUFDLGtCQUFrQixFQUFFLDZCQUE2QixFQUFFLDJCQUEyQixFQUFFLHVCQUF1QixDQUFDO29CQUNsSCxPQUFPLEVBQUUsQ0FBQyxZQUFZLENBQUM7aUJBQzFCOztJQUVELHNCQUFDO0NBQUEsQUFORCxJQU1DO1NBRFksZUFBZSIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IENvbW1vbk1vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5pbXBvcnQge1xuICAgIEFmdGVyVmlld0luaXQsIENvbXBvbmVudCwgRWxlbWVudFJlZiwgRXZlbnRFbWl0dGVyLFxuICAgIEhvc3RCaW5kaW5nLCBJbnB1dCwgTmdNb2R1bGUsIE9uSW5pdCwgT3V0cHV0LCBSZW5kZXJlcjIsXG4gICAgVmlld0NoaWxkLFxuICAgIFRlbXBsYXRlUmVmLFxuICAgIENvbnRlbnRDaGlsZCxcbiAgICBBZnRlckNvbnRlbnRJbml0LFxuICAgIE9uRGVzdHJveSxcbiAgICBIb3N0TGlzdGVuZXIsXG4gICAgVmlld0NoaWxkcmVuLFxuICAgIFF1ZXJ5TGlzdFxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IENvbnRyb2xWYWx1ZUFjY2Vzc29yLCBOR19WQUxVRV9BQ0NFU1NPUiB9IGZyb20gJ0Bhbmd1bGFyL2Zvcm1zJztcbmltcG9ydCB7IEVkaXRvclByb3ZpZGVyIH0gZnJvbSAnLi4vY29yZS9lZGl0LXByb3ZpZGVyJztcbmltcG9ydCB7IERlcHJlY2F0ZVByb3BlcnR5IH0gZnJvbSAnLi4vY29yZS9kZXByZWNhdGVEZWNvcmF0b3JzJztcbmltcG9ydCB7IElneFNsaWRlclRodW1iQ29tcG9uZW50IH0gZnJvbSAnLi90aHVtYi90aHVtYi1zbGlkZXIuY29tcG9uZW50JztcbmltcG9ydCB7IFN1YmplY3QsIG1lcmdlIH0gZnJvbSAncnhqcyc7XG5pbXBvcnQgeyB0YWtlVW50aWwgfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XG5pbXBvcnQgeyBTbGlkZXJIYW5kbGUsXG4gICAgSWd4VGh1bWJGcm9tVGVtcGxhdGVEaXJlY3RpdmUsXG4gICAgSWd4VGh1bWJUb1RlbXBsYXRlRGlyZWN0aXZlLFxuICAgIElSYW5nZVNsaWRlclZhbHVlLFxuICAgIFNsaWRlclR5cGUsXG4gICAgSVNsaWRlclZhbHVlQ2hhbmdlRXZlbnRBcmdzXG59IGZyb20gJy4vc2xpZGVyLmNvbW1vbic7XG5cblxuY29uc3Qgbm9vcCA9ICgpID0+IHtcbn07XG5cbmxldCBORVhUX0lEID0gMDtcblxuLyoqXG4gKiAqKklnbml0ZSBVSSBmb3IgQW5ndWxhciBTbGlkZXIqKiAtXG4gKiBbRG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly93d3cuaW5mcmFnaXN0aWNzLmNvbS9wcm9kdWN0cy9pZ25pdGUtdWktYW5ndWxhci9hbmd1bGFyL2NvbXBvbmVudHMvc2xpZGVyLmh0bWwpXG4gKlxuICogVGhlIElnbml0ZSBVSSBTbGlkZXIgYWxsb3dzIHNlbGVjdGlvbiBpbiBhIGdpdmVuIHJhbmdlIGJ5IG1vdmluZyB0aGUgdGh1bWIgYWxvbmcgdGhlIHRyYWNrLiBUaGUgdHJhY2tcbiAqIGNhbiBiZSBkZWZpbmVkIGFzIGNvbnRpbnVvdXMgb3Igc3RlcHBlZCwgYW5kIHlvdSBjYW4gY2hvb3NlIGJldHdlZW4gc2luZ2xlIGFuZCByYW5nZSBzbGlkZXIgdHlwZXMuXG4gKlxuICogRXhhbXBsZTpcbiAqIGBgYGh0bWxcbiAqIDxpZ3gtc2xpZGVyIGlkPVwic2xpZGVyXCJcbiAqICAgICAgICAgICAgW21pblZhbHVlXT1cIjBcIiBbbWF4VmFsdWVdPVwiMTAwXCJcbiAqICAgICAgICAgICAgW2NvbnRpbnVvdXNdPXRydWUgWyhuZ01vZGVsKV09XCJ2b2x1bWVcIj5cbiAqIDwvaWd4LXNsaWRlcj5cbiAqIGBgYFxuICovXG5AQ29tcG9uZW50KHtcbiAgICBwcm92aWRlcnM6IFt7IHByb3ZpZGU6IE5HX1ZBTFVFX0FDQ0VTU09SLCB1c2VFeGlzdGluZzogSWd4U2xpZGVyQ29tcG9uZW50LCBtdWx0aTogdHJ1ZSB9XSxcbiAgICBzZWxlY3RvcjogJ2lneC1zbGlkZXInLFxuICAgIHRlbXBsYXRlVXJsOiAnc2xpZGVyLmNvbXBvbmVudC5odG1sJyxcbiAgICBzdHlsZXM6IFtgXG4gICAgICAgIDpob3N0IHtcbiAgICAgICAgICAgIGRpc3BsYXk6IGJsb2NrO1xuICAgICAgICB9XG4gICAgYF1cbn0pXG5leHBvcnQgY2xhc3MgSWd4U2xpZGVyQ29tcG9uZW50IGltcGxlbWVudHNcbiAgICBDb250cm9sVmFsdWVBY2Nlc3NvcixcbiAgICBFZGl0b3JQcm92aWRlcixcbiAgICBPbkluaXQsXG4gICAgQWZ0ZXJWaWV3SW5pdCxcbiAgICBBZnRlckNvbnRlbnRJbml0LFxuICAgIE9uRGVzdHJveSB7XG5cbiAgICAvLyBMaW1pdCBoYW5kbGUgdHJhdmVsIHpvbmVcbiAgICBwcml2YXRlIF9wTWluID0gMDtcbiAgICBwcml2YXRlIF9wTWF4ID0gMTtcblxuICAgIC8vIEZyb20vdXBwZXJWYWx1ZSBpbiBwZXJjZW50IHZhbHVlc1xuICAgIHByaXZhdGUgX2hhc1ZpZXdJbml0ID0gZmFsc2U7XG4gICAgcHJpdmF0ZSBfbWluVmFsdWUgPSAwO1xuICAgIHByaXZhdGUgX21heFZhbHVlID0gMTAwO1xuICAgIHByaXZhdGUgX2xvd2VyQm91bmQ/OiBudW1iZXI7XG4gICAgcHJpdmF0ZSBfdXBwZXJCb3VuZD86IG51bWJlcjtcbiAgICBwcml2YXRlIF9sb3dlclZhbHVlPzogbnVtYmVyO1xuICAgIHByaXZhdGUgX3VwcGVyVmFsdWU/OiBudW1iZXI7XG4gICAgcHJpdmF0ZSBfY291bnRpbnVvdXMgPSBmYWxzZTtcbiAgICBwcml2YXRlIF9kaXNhYmxlZCA9IGZhbHNlO1xuICAgIHByaXZhdGUgX3N0ZXAgPSAxO1xuXG4gICAgcHJpdmF0ZSBfbGFiZWxzID0gbmV3IEFycmF5PG51bWJlcnxzdHJpbmd8Ym9vbGVhbnxudWxsfHVuZGVmaW5lZD4oKTtcbiAgICBwcml2YXRlIF90eXBlID0gU2xpZGVyVHlwZS5TTElERVI7XG5cbiAgICBwcml2YXRlIF9kZXN0cm95JCA9IG5ldyBTdWJqZWN0PGJvb2xlYW4+KCk7XG5cbiAgICBwcml2YXRlIF9vbkNoYW5nZUNhbGxiYWNrOiAoXzogYW55KSA9PiB2b2lkID0gbm9vcDtcbiAgICBwcml2YXRlIF9vblRvdWNoZWRDYWxsYmFjazogKCkgPT4gdm9pZCA9IG5vb3A7XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgQFZpZXdDaGlsZCgndHJhY2snKVxuICAgIHByaXZhdGUgdHJhY2s6IEVsZW1lbnRSZWY7XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgQFZpZXdDaGlsZCgndGlja3MnKVxuICAgIHByaXZhdGUgdGlja3M6IEVsZW1lbnRSZWY7XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgQFZpZXdDaGlsZHJlbihJZ3hTbGlkZXJUaHVtYkNvbXBvbmVudClcbiAgICBwcml2YXRlIHRodW1iczogUXVlcnlMaXN0PElneFNsaWRlclRodW1iQ29tcG9uZW50PiA9IG5ldyBRdWVyeUxpc3Q8SWd4U2xpZGVyVGh1bWJDb21wb25lbnQ+KCk7XG5cbiAgICBwcml2YXRlIGdldCB0aHVtYkZyb20oKTogSWd4U2xpZGVyVGh1bWJDb21wb25lbnQge1xuICAgICAgICByZXR1cm4gdGhpcy50aHVtYnMuZmluZCh0aHVtYiA9PiB0aHVtYi50eXBlID09PSBTbGlkZXJIYW5kbGUuRlJPTSk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBnZXQgdGh1bWJUbygpOiBJZ3hTbGlkZXJUaHVtYkNvbXBvbmVudCB7XG4gICAgICAgIHJldHVybiB0aGlzLnRodW1icy5maW5kKHRodW1iID0+IHRodW1iLnR5cGUgPT09IFNsaWRlckhhbmRsZS5UTyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHB1YmxpYyBzdGVwRGlzdGFuY2UgPSB0aGlzLl9zdGVwO1xuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHB1YmxpYyBvblBhbjogU3ViamVjdDxudW1iZXI+ID0gbmV3IFN1YmplY3Q8bnVtYmVyPigpO1xuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIEBDb250ZW50Q2hpbGQoSWd4VGh1bWJGcm9tVGVtcGxhdGVEaXJlY3RpdmUsIHsgcmVhZDogVGVtcGxhdGVSZWYgfSlcbiAgICBwdWJsaWMgdGh1bWJGcm9tVGVtcGxhdGVSZWY6IFRlbXBsYXRlUmVmPGFueT47XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgQENvbnRlbnRDaGlsZChJZ3hUaHVtYlRvVGVtcGxhdGVEaXJlY3RpdmUsIHsgcmVhZDogVGVtcGxhdGVSZWYgfSlcbiAgICBwdWJsaWMgdGh1bWJUb1RlbXBsYXRlUmVmOiBUZW1wbGF0ZVJlZjxhbnk+O1xuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIEBIb3N0QmluZGluZyhgYXR0ci5yb2xlYClcbiAgICBwdWJsaWMgcm9sZSA9ICdzbGlkZXInO1xuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIEBIb3N0QmluZGluZyhgYXR0ci5hcmlhLXZhbHVlbWluYClcbiAgICBwdWJsaWMgZ2V0IHZhbHVlbWluKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5taW5WYWx1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgQEhvc3RCaW5kaW5nKGBhdHRyLmFyaWEtdmFsdWVtYXhgKVxuICAgIHB1YmxpYyBnZXQgdmFsdWVtYXgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1heFZhbHVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBASG9zdEJpbmRpbmcoYGF0dHIuYXJpYS1yZWFkb25seWApXG4gICAgcHVibGljIGdldCByZWFkb25seSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGlzYWJsZWQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIEBIb3N0QmluZGluZygnY2xhc3MuaWd4LXNsaWRlcicpXG4gICAgcHVibGljIHNsaWVyQ2xhc3MgPSB0cnVlO1xuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIEBIb3N0QmluZGluZygnY2xhc3MuaWd4LXNsaWRlci0tZGlzYWJsZWQnKVxuICAgIHB1YmxpYyBnZXQgZGlzYWJsZWRDbGFzcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGlzYWJsZWQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQW4gQElucHV0IHByb3BlcnR5IHRoYXQgc2V0cyB0aGUgdmFsdWUgb2YgdGhlIGBpZGAgYXR0cmlidXRlLlxuICAgICAqIElmIG5vdCBwcm92aWRlZCBpdCB3aWxsIGJlIGF1dG9tYXRpY2FsbHkgZ2VuZXJhdGVkLlxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8aWd4LXNsaWRlciBbaWRdPVwiJ2lneC1zbGlkZXItMzInXCIgWyhuZ01vZGVsKV09XCJ0YXNrLnBlcmNlbnRDb21wbGV0ZWRcIiBbc3RlcF09XCI1XCIgW2xvd2VyQm91bmRdPVwiMjBcIj5cbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBASG9zdEJpbmRpbmcoJ2F0dHIuaWQnKVxuICAgIEBJbnB1dCgpXG4gICAgcHVibGljIGlkID0gYGlneC1zbGlkZXItJHtORVhUX0lEKyt9YDtcblxuICAgIC8qKlxuICAgICAqIEFuIEBJbnB1dCBwcm9wZXJ0eSB0aGF0IGdldHMgdGhlIHR5cGUgb2YgdGhlIGBJZ3hTbGlkZXJDb21wb25lbnRgLiBUaGUgc2xpZGVyIGNhbiBiZSBTbGlkZXJUeXBlLlNMSURFUihkZWZhdWx0KSBvciBTbGlkZXJUeXBlLlJBTkdFLlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBAVmlld0NoaWxkKFwic2xpZGVyMlwiKVxuICAgICAqIHB1YmxpYyBzbGlkZXI6IElneFNsaWRlckNvbXBvbmVudDtcbiAgICAgKiBuZ0FmdGVyVmlld0luaXQoKXtcbiAgICAgKiAgICAgbGV0IHR5cGUgPSB0aGlzLnNsaWRlci50eXBlO1xuICAgICAqIH1cbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHB1YmxpYyBnZXQgdHlwZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3R5cGU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQW4gQElucHV0IHByb3BlcnR5IHRoYXQgc2V0cyB0aGUgdHlwZSBvZiB0aGUgYElneFNsaWRlckNvbXBvbmVudGAuIFRoZSBzbGlkZXIgY2FuIGJlIFNsaWRlclR5cGUuU0xJREVSKGRlZmF1bHQpIG9yIFNsaWRlclR5cGUuUkFOR0UuXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIHNsaWRlclR5cGU6IFNsaWRlclR5cGUgPSBTbGlkZXJUeXBlLlJBTkdFO1xuICAgICAqIGBgYFxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8aWd4LXNsaWRlciAjc2xpZGVyMiBbdHlwZV09XCJzbGlkZXJUeXBlXCIgWyhuZ01vZGVsKV09XCJyYW5nZVZhbHVlXCIgW21pblZhbHVlXT1cIjBcIiBbbWF4VmFsdWVdPVwiMTAwXCI+XG4gICAgICogYGBgXG4gICAgICovXG4gICAgcHVibGljIHNldCB0eXBlKHR5cGU6IFNsaWRlclR5cGUpIHtcbiAgICAgICAgdGhpcy5fdHlwZSA9IHR5cGU7XG5cbiAgICAgICAgaWYgKHR5cGUgPT09IFNsaWRlclR5cGUuU0xJREVSKSB7XG4gICAgICAgICAgICB0aGlzLmxvd2VyVmFsdWUgPSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMubGFiZWxzVmlld0VuYWJsZWQgJiYgdGhpcy51cHBlclZhbHVlID4gdGhpcy5tYXhWYWx1ZSkge1xuICAgICAgICAgICAgdGhpcy51cHBlclZhbHVlID0gdGhpcy5sYWJlbHMubGVuZ3RoIC0gMTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLl9oYXNWaWV3SW5pdCkge1xuICAgICAgICAgICAgdGhpcy51cGRhdGVUcmFjaygpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpBbiBASW5wdXQgcHJvcGVydHkgdGhhdCBzZXRzIHRoZSBkdXJhdGlvbiB2aXNpYmlsaXR5IG9mIHRodW1icyBsYWJlbHMuIFRoZSBkZWZhdWx0IHZhbHVlIGlzIDc1MCBtaWxsaXNlY29uZHMuXG4gICAgICpgYGBodG1sXG4gICAgICo8aWd4LXNsaWRlciAjc2xpZGVyIFt0aHVtYkxhYmVsVmlzaWJpbGl0eUR1cmF0aW9uXT1cIjMwMDBcIiBbKG5nTW9kZWwpXT1cInRhc2sucGVyY2VudENvbXBsZXRlZFwiIFtzdGVwXT1cIjVcIj5cbiAgICAgKmBgYFxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgcHVibGljIHRodW1iTGFiZWxWaXNpYmlsaXR5RHVyYXRpb24gPSA3NTA7XG5cblxuICAgIC8qKlxuICAgICAqIEVuYWJsZXMgYGxhYmVsVmlld2AsIGJ5IGFjY2VwdGluZyBhIGNvbGxlY3Rpb24gb2YgcHJpbWl0aXZlIHZhbHVlcyB3aXRoIG1vcmUgdGhhbiBvbmUgZWxlbWVudC5cbiAgICAgKiBFYWNoIGVsZW1lbnQgd2lsbCBiZSBlcXVhbGx5IHNwcmVhZCBvdmVyIHRoZSBzbGlkZXIgYW5kIGl0IHdpbGwgc2VydmUgYXMgYSB0aHVtYiBsYWJlbC5cbiAgICAgKiBPbmNlIHRoZSBwcm9wZXJ0eSBpcyBzZXQsIGl0IHdpbGwgcHJlY2VuZGVuY2Ugb3ZlciB7QGxpbmsgbWF4VmFsdWV9LCB7QGxpbmsgbWluVmFsdWV9LCB7QGxpbmsgc3RlcH0uXG4gICAgICogVGhpcyBtZWFucyB0aGF0IHRoZSBtYW5pcHVsYXRpb24gZm9yIHRob3NlIHByb3BlcnRpZXMgd29uJ3QgYmUgYWxsb3dlZC5cbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHB1YmxpYyBnZXQgbGFiZWxzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbGFiZWxzO1xuICAgIH1cblxuICAgIHB1YmxpYyBzZXQgbGFiZWxzKGxhYmVsczogQXJyYXk8bnVtYmVyfHN0cmluZ3xib29sZWFufG51bGx8dW5kZWZpbmVkPikge1xuICAgICAgICB0aGlzLl9sYWJlbHMgPSBsYWJlbHM7XG5cbiAgICAgICAgdGhpcy5fcE1heCA9IDE7XG5cbiAgICAgICAgaWYgKHRoaXMuX2hhc1ZpZXdJbml0KSB7XG4gICAgICAgICAgICB0aGlzLnN0ZXBEaXN0YW5jZSA9IHRoaXMuY2FsY3VsYXRlU3RlcERpc3RhbmNlKCk7XG4gICAgICAgICAgICB0aGlzLnBvc2l0aW9uSGFuZGxlc0FuZFVwZGF0ZVRyYWNrKCk7XG4gICAgICAgICAgICB0aGlzLnNldFRpY2tJbnRlcnZhbChsYWJlbHMpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgdGVtcGxhdGUgY29udGV4dCBjb3JyZXNwb25kaW5nXG4gICAgICogdG8ge0BsaW5rIElneFRodW1iRnJvbVRlbXBsYXRlRGlyZWN0aXZlfSBhbmQge0BsaW5rIElneFRodW1iVG9UZW1wbGF0ZURpcmVjdGl2ZX0gdGVtcGxhdGVzLlxuICAgICAqXG4gICAgICogcmV0dXJuIHtcbiAgICAgKiAgJGltcGxpY2l0OiB7QGxpbmsgdmFsdWV9LFxuICAgICAqICBsYWJlbHM6IHtAbGluayBsYWJlbHN9XG4gICAgICogfVxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIHB1YmxpYyBnZXQgY29udGV4dCgpOiBhbnkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJGltcGxpY2l0OiB0aGlzLnZhbHVlLFxuICAgICAgICAgICAgbGFiZWxzOiB0aGlzLmxhYmVsc1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFuIEBJbnB1dCBwcm9wZXJ0eSB0aGF0IHNldHMgdGhlIGluY3JlbWVudGFsL2RlY3JlbWVudGFsIHN0ZXAgb2YgdGhlIHZhbHVlIHdoZW4gZHJhZ2dpbmcgdGhlIHRodW1iLlxuICAgICAqIFRoZSBkZWZhdWx0IHN0ZXAgaXMgMSwgYW5kIHN0ZXAgc2hvdWxkIG5vdCBiZSBsZXNzIG9yIGVxdWFsIHRoYW4gMC5cbiAgICAgKiBgYGBodG1sXG4gICAgICogPGlneC1zbGlkZXIgI3NsaWRlciBbKG5nTW9kZWwpXT1cInRhc2sucGVyY2VudENvbXBsZXRlZFwiIFtzdGVwXT1cIjVcIj5cbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHB1YmxpYyBzZXQgc3RlcChzdGVwOiBudW1iZXIpIHtcbiAgICAgICAgdGhpcy5fc3RlcCA9IHN0ZXA7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgaW5jcmVtZW50YWwvZGVjcmVtZW50YWwgZHJhZ2dpbmcgc3RlcCBvZiB0aGUge0BsaW5rIElneFNsaWRlckNvbXBvbmVudH0uXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIEBWaWV3Q2hpbGQoXCJzbGlkZXIyXCIpXG4gICAgICogcHVibGljIHNsaWRlcjogSWd4U2xpZGVyQ29tcG9uZW50O1xuICAgICAqIG5nQWZ0ZXJWaWV3SW5pdCgpe1xuICAgICAqICAgICBsZXQgc3RlcCA9IHRoaXMuc2xpZGVyLnN0ZXA7XG4gICAgICogfVxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIHB1YmxpYyBnZXQgc3RlcCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubGFiZWxzVmlld0VuYWJsZWQgPyAxIDogdGhpcy5fc3RlcDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGlmIHRoZSB7QGxpbmsgSWd4U2xpZGVyQ29tcG9uZW50fSBpcyBkaXNhYmxlZC5cbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogQFZpZXdDaGlsZChcInNsaWRlcjJcIilcbiAgICAgKiBwdWJsaWMgc2xpZGVyOiBJZ3hTbGlkZXJDb21wb25lbnQ7XG4gICAgICogbmdBZnRlclZpZXdJbml0KCl7XG4gICAgICogICAgIGxldCBpc0Rpc2FibGVkID0gdGhpcy5zbGlkZXIuZGlzYWJsZWQ7XG4gICAgICogfVxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgcHVibGljIGdldCBkaXNhYmxlZCgpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2Rpc2FibGVkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqQW4gQElucHV0IHByb3BlcnR5IHRoYXQgZGlzYWJsZXMgb3IgZW5hYmxlcyBVSSBpbnRlcmFjdGlvbi5cbiAgICAgKmBgYGh0bWxcbiAgICAgKjxpZ3gtc2xpZGVyICNzbGlkZXIgW2Rpc2FibGVkXT1cIid0cnVlJ1wiIFsobmdNb2RlbCldPVwidGFzay5wZXJjZW50Q29tcGxldGVkXCIgW3N0ZXBdPVwiNVwiIFtsb3dlckJvdW5kXT1cIjIwXCI+XG4gICAgICpgYGBcbiAgICAgKi9cbiAgICBwdWJsaWMgc2V0IGRpc2FibGVkKGRpc2FibGU6IGJvb2xlYW4pIHtcbiAgICAgICAgdGhpcy5fZGlzYWJsZWQgPSBkaXNhYmxlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgaWYgdGhlIHtAbGluayBJZ3hTbGlkZXJDb21wb25lbnR9IGlzIHNldCBhcyBjb250aW51b3VzLlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBAVmlld0NoaWxkKFwic2xpZGVyMlwiKVxuICAgICAqIHB1YmxpYyBzbGlkZXI6IElneFNsaWRlckNvbXBvbmVudDtcbiAgICAgKiBuZ0FmdGVyVmlld0luaXQoKXtcbiAgICAgKiAgICAgbGV0IGNvbnRpbnVvdXMgPSB0aGlzLnNsaWRlci5jb250aW51b3VzO1xuICAgICAqIH1cbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHB1YmxpYyBnZXQgY29udGludW91cygpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NvdW50aW51b3VzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFuIEBJbnB1dCBwcm9wZXJ0eSB0aGF0IG1hcmtzIHRoZSB7QGxpbmsgSWd4U2xpZGVyQ29tcG9uZW50fSBhcyBjb250aW51b3VzLlxuICAgICAqIEJ5IGRlZmF1bHQgaXMgY29uc2lkZXJlZCB0aGF0IHRoZSB7QGxpbmsgSWd4U2xpZGVyQ29tcG9uZW50fSBpcyBkaXNjcmV0ZS5cbiAgICAgKiBEaXNjcmV0ZSB7QGxpbmsgSWd4U2xpZGVyQ29tcG9uZW50fSBkb2VzIG5vdCBoYXZlIHRpY2tzIGFuZCBkb2VzIG5vdCBzaG93cyBidWJibGUgbGFiZWxzIGZvciB2YWx1ZXMuXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxpZ3gtc2xpZGVyICNzbGlkZXIgW2NvbnRpbnVvdXNdPVwiJ3RydWUnXCIgWyhuZ01vZGVsKV09XCJ0YXNrLnBlcmNlbnRDb21wbGV0ZWRcIiBbc3RlcF09XCI1XCIgW2xvd2VyQm91bmRdPVwiMjBcIj5cbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBwdWJsaWMgc2V0IGNvbnRpbnVvdXMoY29udGludW91czogYm9vbGVhbikge1xuICAgICAgICBpZiAodGhpcy5sYWJlbHNWaWV3RW5hYmxlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fY291bnRpbnVvdXMgPSBjb250aW51b3VzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgaWYgdGhlIHtAbGluayBJZ3hTbGlkZXJDb21wb25lbnR9IGlzIHNldCBhcyBjb250aW51b3VzLlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBAVmlld0NoaWxkKFwic2xpZGVyMlwiKVxuICAgICAqIHB1YmxpYyBzbGlkZXI6IElneFNsaWRlckNvbXBvbmVudDtcbiAgICAgKiBuZ0FmdGVyVmlld0luaXQoKXtcbiAgICAgKiAgICAgbGV0IGNvbnRpbnVvdXMgPSB0aGlzLnNsaWRlci5jb250aW51b3VzO1xuICAgICAqIH1cbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIEBEZXByZWNhdGVQcm9wZXJ0eShgSWd4U2xpZGVyQ29tcG9uZW50IFxcYGlzQ29udGludW91c1xcYCBwcm9wZXJ0eSBpcyBkZXByZWNhdGVkLlxcblVzZSBcXGBjb250aW51b3VzXFxgIGluc3RlYWQuYClcbiAgICBwdWJsaWMgZ2V0IGlzQ29udGludW91cygpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29udGludW91cztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgcHVibGljIHNldCBpc0NvbnRpbnVvdXMoY29udGludW91czogYm9vbGVhbikge1xuICAgICAgICB0aGlzLmNvbnRpbnVvdXMgPSBjb250aW51b3VzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIG1heGltdW0gdmFsdWUgZm9yIHRoZSB7QGxpbmsgSWd4U2xpZGVyQ29tcG9uZW50fS5cbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICpAVmlld0NoaWxkKFwic2xpZGVyXCIpXG4gICAgICpwdWJsaWMgc2xpZGVyOiBJZ3hTbGlkZXJDb21wb25lbnQ7XG4gICAgICpuZ0FmdGVyVmlld0luaXQoKXtcbiAgICAgKiAgICBsZXQgc2xpZGVyTWF4ID0gdGhpcy5zbGlkZXIubWF4VmFsdWU7XG4gICAgICp9XG4gICAgICogYGBgXG4gICAgICovXG4gICAgcHVibGljIGdldCBtYXhWYWx1ZSgpOiBudW1iZXIge1xuICAgICAgICByZXR1cm4gdGhpcy5sYWJlbHNWaWV3RW5hYmxlZCA/XG4gICAgICAgICAgICB0aGlzLmxhYmVscy5sZW5ndGggLSAxIDpcbiAgICAgICAgICAgIHRoaXMuX21heFZhbHVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIG1heGltYWwgdmFsdWUgZm9yIHRoZSBgSWd4U2xpZGVyQ29tcG9uZW50YC5cbiAgICAgKiBUaGUgZGVmYXVsdCBtYXhpbXVtIHZhbHVlIGlzIDEwMC5cbiAgICAgKiBgYGBodG1sXG4gICAgICogPGlneC1zbGlkZXIgW3R5cGVdPVwic2xpZGVyVHlwZVwiIFttaW5WYWx1ZV09XCI1NlwiIFttYXhWYWx1ZV09XCIyNTZcIj5cbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHB1YmxpYyBzZXQgbWF4VmFsdWUodmFsdWU6IG51bWJlcikge1xuICAgICAgICBpZiAodmFsdWUgPD0gdGhpcy5fbWluVmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuX21heFZhbHVlID0gdGhpcy5fbWluVmFsdWUgKyAxO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fbWF4VmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh2YWx1ZSA8IHRoaXMubG93ZXJCb3VuZCkge1xuICAgICAgICAgICAgdGhpcy51cGRhdGVMb3dlckJvdW5kQW5kTWluVHJhdmVsWm9uZSgpO1xuICAgICAgICAgICAgdGhpcy51cHBlckJvdW5kID0gdmFsdWU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyByZWZyZXNoIG1heCB0cmF2ZWwgem9uZSBsaW1pdHMuXG4gICAgICAgIHRoaXMuX3BNYXggPSAxO1xuICAgICAgICAvLyByZWNhbGN1bGF0ZSBzdGVwIGRpc3RhbmNlLlxuICAgICAgICB0aGlzLnN0ZXBEaXN0YW5jZSA9IHRoaXMuY2FsY3VsYXRlU3RlcERpc3RhbmNlKCk7XG4gICAgICAgIHRoaXMucG9zaXRpb25IYW5kbGVzQW5kVXBkYXRlVHJhY2soKTtcbiAgICAgICAgdGhpcy5zZXRUaWNrSW50ZXJ2YWwobnVsbCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpSZXR1cm5zIHRoZSBtaW5pbWFsIHZhbHVlIG9mIHRoZSBgSWd4U2xpZGVyQ29tcG9uZW50YC5cbiAgICAgKmBgYHR5cGVzY3JpcHRcbiAgICAgKkBWaWV3Q2hpbGQoXCJzbGlkZXIyXCIpXG4gICAgICpwdWJsaWMgc2xpZGVyOiBJZ3hTbGlkZXJDb21wb25lbnQ7XG4gICAgICpuZ0FmdGVyVmlld0luaXQoKXtcbiAgICAgKiAgICBsZXQgc2xpZGVyTWluID0gdGhpcy5zbGlkZXIubWluVmFsdWU7XG4gICAgICp9XG4gICAgICpgYGBcbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0IG1pblZhbHVlKCk6IG51bWJlciB7XG4gICAgICAgIGlmICh0aGlzLmxhYmVsc1ZpZXdFbmFibGVkKSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLl9taW5WYWx1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBtaW5pbWFsIHZhbHVlIGZvciB0aGUgYElneFNsaWRlckNvbXBvbmVudGAuXG4gICAgICogVGhlIGRlZmF1bHQgbWluaW1hbCB2YWx1ZSBpcyAwLlxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8aWd4LXNsaWRlciBbdHlwZV09XCJzbGlkZXJUeXBlXCIgW21pblZhbHVlXT1cIjU2XCIgW21heFZhbHVlXT1cIjEwMFwiPlxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgcHVibGljIHNldCBtaW5WYWx1ZSh2YWx1ZTogbnVtYmVyKSB7XG4gICAgICAgIGlmICh2YWx1ZSA+PSB0aGlzLm1heFZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLl9taW5WYWx1ZSA9IHRoaXMubWF4VmFsdWUgLSAxO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fbWluVmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh2YWx1ZSA+IHRoaXMudXBwZXJCb3VuZCkge1xuICAgICAgICAgICAgdGhpcy51cGRhdGVVcHBlckJvdW5kQW5kTWF4VHJhdmVsWm9uZSgpO1xuICAgICAgICAgICAgdGhpcy5sb3dlckJvdW5kID0gdmFsdWU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBSZWZyZXNoIG1pbiB0cmF2ZWwgem9uZSBsaW1pdC5cbiAgICAgICAgdGhpcy5fcE1pbiA9IDA7XG4gICAgICAgIC8vIFJlY2FsY3VsYXRlIHN0ZXAgZGlzdGFuY2UuXG4gICAgICAgIHRoaXMuc3RlcERpc3RhbmNlID0gdGhpcy5jYWxjdWxhdGVTdGVwRGlzdGFuY2UoKTtcbiAgICAgICAgdGhpcy5wb3NpdGlvbkhhbmRsZXNBbmRVcGRhdGVUcmFjaygpO1xuICAgICAgICB0aGlzLnNldFRpY2tJbnRlcnZhbChudWxsKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBsb3dlciBib3VuZGFyeSBvZiB0aGUgYElneFNsaWRlckNvbXBvbmVudGAuXG4gICAgICpgYGB0eXBlc2NyaXB0XG4gICAgICpAVmlld0NoaWxkKFwic2xpZGVyXCIpXG4gICAgICpwdWJsaWMgc2xpZGVyOiBJZ3hTbGlkZXJDb21wb25lbnQ7XG4gICAgICpuZ0FmdGVyVmlld0luaXQoKXtcbiAgICAgKiAgICBsZXQgc2xpZGVyTG93Qm91bmQgPSB0aGlzLnNsaWRlci5sb3dlckJvdW5kO1xuICAgICAqfVxuICAgICAqYGBgXG4gICAgICovXG4gICAgcHVibGljIGdldCBsb3dlckJvdW5kKCk6IG51bWJlciB7XG4gICAgICAgIGlmICghTnVtYmVyLmlzTmFOKHRoaXMuX2xvd2VyQm91bmQpICYmIHRoaXMuX2xvd2VyQm91bmQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudmFsdWVJblJhbmdlKHRoaXMuX2xvd2VyQm91bmQsIHRoaXMubWluVmFsdWUsIHRoaXMubWF4VmFsdWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMubWluVmFsdWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgbG93ZXIgYm91bmRhcnkgb2YgdGhlIGBJZ3hTbGlkZXJDb21wb25lbnRgLlxuICAgICAqIElmIG5vdCBzZXQgaXMgdGhlIHNhbWUgYXMgbWluIHZhbHVlLlxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8aWd4LXNsaWRlciBbc3RlcF09XCI1XCIgW2xvd2VyQm91bmRdPVwiMjBcIj5cbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHB1YmxpYyBzZXQgbG93ZXJCb3VuZCh2YWx1ZTogbnVtYmVyKSB7XG4gICAgICAgIGlmICh2YWx1ZSA+PSB0aGlzLnVwcGVyQm91bmQgfHwgKHRoaXMubGFiZWxzVmlld0VuYWJsZWQgJiYgdmFsdWUgPCAwKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fbG93ZXJCb3VuZCA9IHRoaXMudmFsdWVJblJhbmdlKHZhbHVlLCB0aGlzLm1pblZhbHVlLCB0aGlzLm1heFZhbHVlKTtcblxuICAgICAgICAvLyBSZWZyZXNoIHRpbWUgdHJhdmVsIHpvbmUuXG4gICAgICAgIHRoaXMuX3BNaW4gPSB0aGlzLnZhbHVlVG9GcmFjdGlvbih0aGlzLl9sb3dlckJvdW5kKSB8fCAwO1xuICAgICAgICB0aGlzLnBvc2l0aW9uSGFuZGxlc0FuZFVwZGF0ZVRyYWNrKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgdXBwZXIgYm91bmRhcnkgb2YgdGhlIGBJZ3hTbGlkZXJDb21wb25lbnRgLlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKkBWaWV3Q2hpbGQoXCJzbGlkZXJcIilcbiAgICAgKnB1YmxpYyBzbGlkZXI6IElneFNsaWRlckNvbXBvbmVudDtcbiAgICAgKm5nQWZ0ZXJWaWV3SW5pdCgpe1xuICAgICAqICAgIGxldCBzbGlkZXJVcEJvdW5kID0gdGhpcy5zbGlkZXIudXBwZXJCb3VuZDtcbiAgICAgKn1cbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0IHVwcGVyQm91bmQoKTogbnVtYmVyIHtcbiAgICAgICAgaWYgKCFOdW1iZXIuaXNOYU4odGhpcy5fdXBwZXJCb3VuZCkgJiYgdGhpcy5fdXBwZXJCb3VuZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy52YWx1ZUluUmFuZ2UodGhpcy5fdXBwZXJCb3VuZCwgdGhpcy5taW5WYWx1ZSwgdGhpcy5tYXhWYWx1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5tYXhWYWx1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSB1cHBlciBib3VuZGFyeSBvZiB0aGUgYElneFNsaWRlckNvbXBvbmVudGAuXG4gICAgICogSWYgbm90IHNldCBpcyB0aGUgc2FtZSBhcyBtYXggdmFsdWUuXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxpZ3gtc2xpZGVyIFtzdGVwXT1cIjVcIiBbdXBwZXJCb3VuZF09XCIyMFwiPlxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgcHVibGljIHNldCB1cHBlckJvdW5kKHZhbHVlOiBudW1iZXIpIHtcbiAgICAgICAgaWYgKHZhbHVlIDw9IHRoaXMubG93ZXJCb3VuZCB8fCAodGhpcy5sYWJlbHNWaWV3RW5hYmxlZCAmJiB2YWx1ZSA+IHRoaXMubGFiZWxzLmxlbmd0aCAtIDEpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl91cHBlckJvdW5kID0gdGhpcy52YWx1ZUluUmFuZ2UodmFsdWUsIHRoaXMubWluVmFsdWUsIHRoaXMubWF4VmFsdWUpO1xuICAgICAgICAvLyBSZWZyZXNoIHRpbWUgdHJhdmVsIHpvbmUuXG4gICAgICAgIHRoaXMuX3BNYXggPSB0aGlzLnZhbHVlVG9GcmFjdGlvbih0aGlzLl91cHBlckJvdW5kKSB8fCAxO1xuICAgICAgICB0aGlzLnBvc2l0aW9uSGFuZGxlc0FuZFVwZGF0ZVRyYWNrKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgc2xpZGVyIHZhbHVlLiBJZiB0aGUgc2xpZGVyIGlzIG9mIHR5cGUge0BsaW5rIFNsaWRlclR5cGUuU0xJREVSfSB0aGUgcmV0dXJuZWQgdmFsdWUgaXMgbnVtYmVyLlxuICAgICAqIElmIHRoZSBzbGlkZXIgdHlwZSBpcyB7QGxpbmsgU2xpZGVyVHlwZS5SQU5HRX0gdGhlIHJldHVybmVkIHZhbHVlIHJlcHJlc2VudHMgYW4gb2JqZWN0IG9mIHtAbGluayBsb3dlclZhbHVlfSBhbmQge0BsaW5rIHVwcGVyVmFsdWV9LlxuICAgICAqYGBgdHlwZXNjcmlwdFxuICAgICAqQFZpZXdDaGlsZChcInNsaWRlcjJcIilcbiAgICAgKnB1YmxpYyBzbGlkZXI6IElneFNsaWRlckNvbXBvbmVudDtcbiAgICAgKnB1YmxpYyBzbGlkZXJWYWx1ZShldmVudCl7XG4gICAgICogICAgbGV0IHNsaWRlclZhbCA9IHRoaXMuc2xpZGVyLnZhbHVlO1xuICAgICAqfVxuICAgICAqYGBgXG4gICAgICovXG4gICAgcHVibGljIGdldCB2YWx1ZSgpOiBudW1iZXIgfCBJUmFuZ2VTbGlkZXJWYWx1ZSB7XG4gICAgICAgIGlmICh0aGlzLmlzUmFuZ2UpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgbG93ZXI6IHRoaXMudmFsdWVJblJhbmdlKHRoaXMubG93ZXJWYWx1ZSwgdGhpcy5sb3dlckJvdW5kLCB0aGlzLnVwcGVyQm91bmQpLFxuICAgICAgICAgICAgICAgIHVwcGVyOiB0aGlzLnZhbHVlSW5SYW5nZSh0aGlzLnVwcGVyVmFsdWUsIHRoaXMubG93ZXJCb3VuZCwgdGhpcy51cHBlckJvdW5kKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnZhbHVlSW5SYW5nZSh0aGlzLnVwcGVyVmFsdWUsIHRoaXMubG93ZXJCb3VuZCwgdGhpcy51cHBlckJvdW5kKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIHNsaWRlciB2YWx1ZS5cbiAgICAgKiBJZiB0aGUgc2xpZGVyIGlzIG9mIHR5cGUge0BsaW5rIFNsaWRlclR5cGUuU0xJREVSfSB0aGUgYXJndW1lbnQgaXMgbnVtYmVyLiBCeSBkZWZhdWx0IHRoZSB7QGxpbmsgdmFsdWV9IGdldHMgdGhlIHtAbGluayBsb3dlckJvdW5kfS5cbiAgICAgKiBJZiB0aGUgc2xpZGVyIHR5cGUgaXMge0BsaW5rIFNsaWRlclR5cGUuUkFOR0V9IHRoZSBhcmd1bWVudFxuICAgICAqIHJlcHJlc2VudHMgYW4gb2JqZWN0IG9mIHtAbGluayBsb3dlclZhbHVlfSBhbmQge0BsaW5rIHVwcGVyVmFsdWV9IHByb3BlcnRpZXMuXG4gICAgICogQnkgZGVmYXVsdCB0aGUgb2JqZWN0IGlzIGFzc29jaWF0ZWQgd2l0aCB0aGUge0BsaW5rIGxvd2VyQm91bmR9IGFuZCB7QGxpbmsgdXBwZXJCb3VuZH0gcHJvcGVydHkgdmFsdWVzLlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKnJhbmdlVmFsdWUgPSB7XG4gICAgICogICBsb3dlcjogMzAsXG4gICAgICogICB1cHBlcjogNjBcbiAgICAgKn07XG4gICAgICogYGBgXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxpZ3gtc2xpZGVyIFt0eXBlXT1cInNsaWRlclR5cGVcIiBbKG5nTW9kZWwpXT1cInJhbmdlVmFsdWVcIiBbbWluVmFsdWVdPVwiNTZcIiBbbWF4VmFsdWVdPVwiMjU2XCI+XG4gICAgICogYGBgXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBwdWJsaWMgc2V0IHZhbHVlKHZhbHVlOiBudW1iZXIgfCBJUmFuZ2VTbGlkZXJWYWx1ZSkge1xuICAgICAgICBpZiAoIXRoaXMuaXNSYW5nZSkge1xuICAgICAgICAgICAgdGhpcy51cHBlclZhbHVlID0gdmFsdWUgYXMgbnVtYmVyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFsdWUgPSB0aGlzLnZhbGlkYXRlSW5pdGlhbFZhbHVlKHZhbHVlIGFzIElSYW5nZVNsaWRlclZhbHVlKTtcbiAgICAgICAgICAgIHRoaXMudXBwZXJWYWx1ZSA9ICh2YWx1ZSBhcyBJUmFuZ2VTbGlkZXJWYWx1ZSkudXBwZXI7XG4gICAgICAgICAgICB0aGlzLmxvd2VyVmFsdWUgPSAodmFsdWUgYXMgSVJhbmdlU2xpZGVyVmFsdWUpLmxvd2VyO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fb25DaGFuZ2VDYWxsYmFjayh0aGlzLnZhbHVlKTtcblxuICAgICAgICBpZiAodGhpcy5faGFzVmlld0luaXQpIHtcbiAgICAgICAgICAgIHRoaXMucG9zaXRpb25IYW5kbGVzQW5kVXBkYXRlVHJhY2soKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgZXZlbnQgaXMgZW1pdHRlZCB3aGVuIHVzZXIgaGFzIHN0b3BwZWQgaW50ZXJhY3RpbmcgdGhlIHRodW1iIGFuZCB2YWx1ZSBpcyBjaGFuZ2VkLlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBwdWJsaWMgY2hhbmdlKGV2ZW50KXtcbiAgICAgKiAgICBhbGVydChcIlRoZSB2YWx1ZSBoYXMgYmVlbiBjaGFuZ2VkIVwiKTtcbiAgICAgKn1cbiAgICAgKiBgYGBcbiAgICAgKiBgYGBodG1sXG4gICAgICogPGlneC1zbGlkZXIgKG9uVmFsdWVDaGFuZ2UpPVwiY2hhbmdlKCRldmVudClcIiAjc2xpZGVyIFsobmdNb2RlbCldPVwidGFzay5wZXJjZW50Q29tcGxldGVkXCIgW3N0ZXBdPVwiNVwiPlxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIEBPdXRwdXQoKVxuICAgIHB1YmxpYyBvblZhbHVlQ2hhbmdlID0gbmV3IEV2ZW50RW1pdHRlcjxJU2xpZGVyVmFsdWVDaGFuZ2VFdmVudEFyZ3M+KCk7XG5cblxuICAgIGNvbnN0cnVjdG9yKHByaXZhdGUgcmVuZGVyZXI6IFJlbmRlcmVyMiwgcHJpdmF0ZSBfZWw6IEVsZW1lbnRSZWYpIHsgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIEBIb3N0TGlzdGVuZXIoJ3BvaW50ZXJkb3duJywgWyckZXZlbnQnXSlcbiAgICBwdWJsaWMgb25Qb2ludGVyRG93bigkZXZlbnQpIHtcbiAgICAgICAgdGhpcy5maW5kQ2xvc2VzdFRodW1iKCRldmVudCk7XG5cbiAgICAgICAgaWYgKCF0aGlzLnRodW1iVG8uaXNBY3RpdmUgJiYgdGhpcy50aHVtYkZyb20gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5zaG93VGh1bWJMYWJlbHMoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgQEhvc3RMaXN0ZW5lcigncG9pbnRlcnVwJylcbiAgICBwdWJsaWMgb25Qb2ludGVyVXAoKSB7XG4gICAgICAgIGlmICghdGhpcy50aHVtYlRvLmlzQWN0aXZlICYmIHRoaXMudGh1bWJGcm9tID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuaGlkZVRodW1iTGFiZWxzKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIEBIb3N0TGlzdGVuZXIoJ2ZvY3VzJylcbiAgICBwdWJsaWMgb25Gb2N1cygpIHtcbiAgICAgICAgdGhpcy50b2dnbGVUaHVtYkxhYmVscygpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBASG9zdExpc3RlbmVyKCdibHVyJylcbiAgICBwdWJsaWMgb25CbHVyKCkge1xuICAgICAgICB0aGlzLmhpZGVUaHVtYkxhYmVscygpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBASG9zdExpc3RlbmVyKCdwYW4nLCBbJyRldmVudCddKVxuICAgIHB1YmxpYyBvblBhbkxpc3RlbmVyKCRldmVudCkge1xuICAgICAgICB0aGlzLnVwZGF0ZSgkZXZlbnQuc3JjRXZlbnQuY2xpZW50WCk7XG4gICAgfVxuXG4gICAgQEhvc3RMaXN0ZW5lcigncGFuc3RhcnQnKVxuICAgIHB1YmxpYyBvblBhblN0YXJ0KCkge1xuICAgICAgICB0aGlzLnNob3dUaHVtYkxhYmVscygpO1xuICAgIH1cblxuICAgIEBIb3N0TGlzdGVuZXIoJ3BhbmVuZCcpXG4gICAgcHVibGljIG9uUGFuRW5kKCkge1xuICAgICAgICB0aGlzLmhpZGVUaHVtYkxhYmVscygpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBASG9zdExpc3RlbmVyKCd0YXAnLCBbJyRldmVudCddKVxuICAgIHB1YmxpYyBvblRhcExpc3RlbmVyKCRldmVudCkge1xuICAgICAgICB0aGlzLm9uVGFwKCRldmVudCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpSZXR1cm5zIHdoZXRoZXIgdGhlIGBJZ3hTbGlkZXJDb21wb25lbnRgIHR5cGUgaXMgUkFOR0UuXG4gICAgICpgYGB0eXBlc2NyaXB0XG4gICAgICpAVmlld0NoaWxkKFwic2xpZGVyXCIpXG4gICAgICpwdWJsaWMgc2xpZGVyOiBJZ3hTbGlkZXJDb21wb25lbnQ7XG4gICAgICpuZ0FmdGVyVmlld0luaXQoKXtcbiAgICAgKiAgICBsZXQgc2xpZGVyUmFuZ2UgPSB0aGlzLnNsaWRlci5pc1JhbmdlO1xuICAgICAqfVxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIHB1YmxpYyBnZXQgaXNSYW5nZSgpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudHlwZSA9PT0gU2xpZGVyVHlwZS5SQU5HRTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBsb3dlciB2YWx1ZSBvZiB0aGUgYElneFNsaWRlckNvbXBvbmVudGAuXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIEBWaWV3Q2hpbGQoXCJzbGlkZXJcIilcbiAgICAgKiBwdWJsaWMgc2xpZGVyOiBJZ3hTbGlkZXJDb21wb25lbnQ7XG4gICAgICogcHVibGljIGxvd1ZhbHVlKGV2ZW50KXtcbiAgICAgKiAgICBsZXQgc2xpZGVyTG93VmFsdWUgPSB0aGlzLnNsaWRlci5sb3dlclZhbHVlO1xuICAgICAqfVxuICAgICAqYGBgXG4gICAgICovXG4gICAgcHVibGljIGdldCBsb3dlclZhbHVlKCk6IG51bWJlciB7XG4gICAgICAgIGlmICghTnVtYmVyLmlzTmFOKHRoaXMuX2xvd2VyVmFsdWUpICYmIHRoaXMuX2xvd2VyVmFsdWUgIT09IHVuZGVmaW5lZCAmJiB0aGlzLl9sb3dlclZhbHVlID49IHRoaXMubG93ZXJCb3VuZCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2xvd2VyVmFsdWU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5sb3dlckJvdW5kO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqU2V0cyB0aGUgbG93ZXIgdmFsdWUgb2YgdGhlIGBJZ3hTbGlkZXJDb21wb25lbnRgLlxuICAgICAqYGBgdHlwZXNjcmlwdFxuICAgICAqQFZpZXdDaGlsZChcInNsaWRlcjJcIilcbiAgICAgKnB1YmxpYyBzbGlkZXI6IElneFNsaWRlckNvbXBvbmVudDtcbiAgICAgKnB1YmxpYyBsb3dWYWx1ZShldmVudCl7XG4gICAgICogICAgdGhpcy5zbGlkZXIubG93ZXJWYWx1ZSA9IDEyMDtcbiAgICAgKn1cbiAgICAgKmBgYFxuICAgICAqL1xuICAgIHB1YmxpYyBzZXQgbG93ZXJWYWx1ZSh2YWx1ZTogbnVtYmVyKSB7XG4gICAgICAgIHZhbHVlID0gdGhpcy52YWx1ZUluUmFuZ2UodmFsdWUsIHRoaXMubG93ZXJCb3VuZCwgdGhpcy51cHBlckJvdW5kKTtcbiAgICAgICAgdGhpcy5fbG93ZXJWYWx1ZSA9IHZhbHVlO1xuXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpSZXR1cm5zIHRoZSB1cHBlciB2YWx1ZSBvZiB0aGUgYElneFNsaWRlckNvbXBvbmVudGAuXG4gICAgICpgYGB0eXBlc2NyaXB0XG4gICAgICpAVmlld0NoaWxkKFwic2xpZGVyMlwiKVxuICAgICAqcHVibGljIHNsaWRlcjogSWd4U2xpZGVyQ29tcG9uZW50O1xuICAgICAqcHVibGljIHVwcGVyVmFsdWUoZXZlbnQpe1xuICAgICAqICAgIGxldCB1cHBlclZhbHVlID0gdGhpcy5zbGlkZXIudXBwZXJWYWx1ZTtcbiAgICAgKn1cbiAgICAgKmBgYFxuICAgICAqL1xuICAgIHB1YmxpYyBnZXQgdXBwZXJWYWx1ZSgpIHtcbiAgICAgICAgaWYgKCFOdW1iZXIuaXNOYU4odGhpcy5fdXBwZXJWYWx1ZSkgJiYgdGhpcy5fdXBwZXJWYWx1ZSAhPT0gdW5kZWZpbmVkICYmIHRoaXMuX3VwcGVyVmFsdWUgPD0gdGhpcy51cHBlckJvdW5kKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fdXBwZXJWYWx1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLnVwcGVyQm91bmQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpTZXRzIHRoZSB1cHBlciB2YWx1ZSBvZiB0aGUgYElneFNsaWRlckNvbXBvbmVudGAuXG4gICAgICpgYGB0eXBlc2NyaXB0XG4gICAgICpAVmlld0NoaWxkKFwic2xpZGVyMlwiKVxuICAgICAqcHVibGljIHNsaWRlcjogSWd4U2xpZGVyQ29tcG9uZW50O1xuICAgICAqcHVibGljIHVwcGVyVmFsdWUoZXZlbnQpe1xuICAgICAqICAgIHRoaXMuc2xpZGVyLnVwcGVyVmFsdWUgPSAxMjA7XG4gICAgICp9XG4gICAgICpgYGBcbiAgICAgKi9cbiAgICBwdWJsaWMgc2V0IHVwcGVyVmFsdWUodmFsdWU6IG51bWJlcikge1xuICAgICAgICB2YWx1ZSA9IHRoaXMudmFsdWVJblJhbmdlKHZhbHVlLCB0aGlzLmxvd2VyQm91bmQsIHRoaXMudXBwZXJCb3VuZCk7XG4gICAgICAgIHRoaXMuX3VwcGVyVmFsdWUgPSB2YWx1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSB2YWx1ZSBjb3JyZXNwb25kaW5nIHRoZSBsb3dlciBsYWJlbC5cbiAgICAgKmBgYHR5cGVzY3JpcHRcbiAgICAgKiBAVmlld0NoaWxkKFwic2xpZGVyXCIpXG4gICAgICogcHVibGljIHNsaWRlcjogSWd4U2xpZGVyQ29tcG9uZW50O1xuICAgICAqIGxldCBsYWJlbCA9IHRoaXMuc2xpZGVyLmxvd2VyTGFiZWw7XG4gICAgICpgYGBcbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0IGxvd2VyTGFiZWwoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxhYmVsc1ZpZXdFbmFibGVkID9cbiAgICAgICAgICAgIHRoaXMubGFiZWxzW3RoaXMubG93ZXJWYWx1ZV0gOlxuICAgICAgICAgICAgdGhpcy5sb3dlclZhbHVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHZhbHVlIGNvcnJlc3BvbmRpbmcgdGhlIHVwcGVyIGxhYmVsLlxuICAgICAqYGBgdHlwZXNjcmlwdFxuICAgICAqIEBWaWV3Q2hpbGQoXCJzbGlkZXJcIilcbiAgICAgKiBwdWJsaWMgc2xpZGVyOiBJZ3hTbGlkZXJDb21wb25lbnQ7XG4gICAgICogbGV0IGxhYmVsID0gdGhpcy5zbGlkZXIudXBwZXJMYWJlbDtcbiAgICAgKmBgYFxuICAgICAqL1xuICAgIHB1YmxpYyBnZXQgdXBwZXJMYWJlbCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubGFiZWxzVmlld0VuYWJsZWQgP1xuICAgICAgICAgICAgdGhpcy5sYWJlbHNbdGhpcy51cHBlclZhbHVlXSA6XG4gICAgICAgICAgICB0aGlzLnVwcGVyVmFsdWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBpZiBsYWJlbCB2aWV3IGlzIGVuYWJsZWQuXG4gICAgICogSWYgdGhlIHtAbGluayBsYWJlbHN9IGlzIHNldCwgdGhlIHZpZXcgaXMgYXV0b21hdGljYWxseSBhY3RpdmF0ZWQuXG4gICAgICpgYGB0eXBlc2NyaXB0XG4gICAgICogQFZpZXdDaGlsZChcInNsaWRlclwiKVxuICAgICAqIHB1YmxpYyBzbGlkZXI6IElneFNsaWRlckNvbXBvbmVudDtcbiAgICAgKiBsZXQgbGFiZWxWaWV3ID0gdGhpcy5zbGlkZXIubGFiZWxzVmlld0VuYWJsZWQ7XG4gICAgICpgYGBcbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0IGxhYmVsc1ZpZXdFbmFibGVkKCk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gISEodGhpcy5sYWJlbHMgJiYgdGhpcy5sYWJlbHMubGVuZ3RoID4gMSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHB1YmxpYyBuZ09uSW5pdCgpIHtcbiAgICAgICAgdGhpcy5zbGlkZXJTZXR1cCgpO1xuXG4gICAgICAgIC8vIFNldCB0cmFjayB0cmF2ZWwgem9uZVxuICAgICAgICB0aGlzLl9wTWluID0gdGhpcy52YWx1ZVRvRnJhY3Rpb24odGhpcy5sb3dlckJvdW5kKSB8fCAwO1xuICAgICAgICB0aGlzLl9wTWF4ID0gdGhpcy52YWx1ZVRvRnJhY3Rpb24odGhpcy51cHBlckJvdW5kKSB8fCAxO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBwdWJsaWMgbmdBZnRlclZpZXdJbml0KCkge1xuICAgICAgICB0aGlzLl9oYXNWaWV3SW5pdCA9IHRydWU7XG4gICAgICAgIHRoaXMucG9zaXRpb25IYW5kbGVzQW5kVXBkYXRlVHJhY2soKTtcbiAgICAgICAgdGhpcy5zZXRUaWNrSW50ZXJ2YWwodGhpcy5sYWJlbHMpO1xuXG4gICAgICAgIHRoaXMuc3Vic2NyaWJlVG8odGhpcy50aHVtYkZyb20sIHRoaXMudGh1bWJDaGFuZ2VkLmJpbmQodGhpcykpO1xuICAgICAgICB0aGlzLnN1YnNjcmliZVRvKHRoaXMudGh1bWJUbywgdGhpcy50aHVtYkNoYW5nZWQuYmluZCh0aGlzKSk7XG5cbiAgICAgICAgdGhpcy50aHVtYnMuY2hhbmdlcy5waXBlKHRha2VVbnRpbCh0aGlzLl9kZXN0cm95JCkpLnN1YnNjcmliZShjaGFuZ2UgPT4ge1xuICAgICAgICAgICAgY29uc3QgdCA9IGNoYW5nZS5maW5kKCh0aHVtYjogSWd4U2xpZGVyVGh1bWJDb21wb25lbnQpID0+IHRodW1iLnR5cGUgPT09IFNsaWRlckhhbmRsZS5GUk9NKTtcbiAgICAgICAgICAgIHRoaXMucG9zaXRpb25IYW5kbGUodCwgdGhpcy5sb3dlclZhbHVlKTtcbiAgICAgICAgICAgIHRoaXMuc3Vic2NyaWJlVG8odCwgdGhpcy50aHVtYkNoYW5nZWQuYmluZCh0aGlzKSk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBwdWJsaWMgbmdBZnRlckNvbnRlbnRJbml0KCkge1xuICAgICAgICAvLyBDYWxjdWxhdGVzIHRoZSBkaXN0YW5jZSBiZXR3ZWVuIGV2ZXJ5IHN0ZXAgaW4gcGl4ZWxzLlxuICAgICAgICB0aGlzLnN0ZXBEaXN0YW5jZSA9IHRoaXMuY2FsY3VsYXRlU3RlcERpc3RhbmNlKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHB1YmxpYyBuZ09uRGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5fZGVzdHJveSQubmV4dCh0cnVlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHVibGljIHdyaXRlVmFsdWUodmFsdWU6IGFueSk6IHZvaWQge1xuICAgICAgICBpZiAoIXZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHB1YmxpYyByZWdpc3Rlck9uQ2hhbmdlKGZuOiBhbnkpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5fb25DaGFuZ2VDYWxsYmFjayA9IGZuO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBwdWJsaWMgcmVnaXN0ZXJPblRvdWNoZWQoZm46IGFueSk6IHZvaWQge1xuICAgICAgICB0aGlzLl9vblRvdWNoZWRDYWxsYmFjayA9IGZuO1xuICAgIH1cblxuICAgIC8qKiBAaGlkZGVuICovXG4gICAgcHVibGljIGdldEVkaXRFbGVtZW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pc1JhbmdlID8gdGhpcy50aHVtYkZyb20ubmF0aXZlRWxlbWVudCA6IHRoaXMudGh1bWJUby5uYXRpdmVFbGVtZW50O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHB1YmxpYyBvblRhcCgkZXZlbnQpIHtcbiAgICAgICAgdGhpcy51cGRhdGUoJGV2ZW50LnNyY0V2ZW50LmNsaWVudFgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBwdWJsaWMgdXBkYXRlKG1vdXNlWCkge1xuICAgICAgICBpZiAodGhpcy5kaXNhYmxlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVXBkYXRlIFRvL0Zyb20gVmFsdWVzXG4gICAgICAgIHRoaXMub25QYW4ubmV4dChtb3VzZVgpO1xuXG4gICAgICAgIC8vIEZpbmFsbHkgZG8gcG9zaXRpb25IYW5kbGVzQW5kVXBkYXRlVHJhY2sgdGhlIERPTVxuICAgICAgICAvLyBiYXNlZCBvbiBkYXRhIHZhbHVlc1xuICAgICAgICB0aGlzLnBvc2l0aW9uSGFuZGxlc0FuZFVwZGF0ZVRyYWNrKCk7XG4gICAgICAgIHRoaXMuX29uVG91Y2hlZENhbGxiYWNrKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHB1YmxpYyB0aHVtYkNoYW5nZWQodmFsdWU6IG51bWJlciwgdGh1bWJUeXBlOiBudW1iZXIpIHtcbiAgICAgICAgY29uc3Qgb2xkVmFsdWUgPSB0aGlzLnZhbHVlO1xuXG4gICAgICAgIGxldCBuZXdWYWw6IElSYW5nZVNsaWRlclZhbHVlO1xuICAgICAgICBpZiAodGhpcy5pc1JhbmdlKSB7XG4gICAgICAgICAgICBpZiAodGh1bWJUeXBlID09PSBTbGlkZXJIYW5kbGUuRlJPTSkge1xuICAgICAgICAgICAgICAgIG5ld1ZhbCA9IHtcbiAgICAgICAgICAgICAgICAgICAgbG93ZXI6ICh0aGlzLnZhbHVlIGFzIElSYW5nZVNsaWRlclZhbHVlKS5sb3dlciArIHZhbHVlLFxuICAgICAgICAgICAgICAgICAgICB1cHBlcjogKHRoaXMudmFsdWUgYXMgSVJhbmdlU2xpZGVyVmFsdWUpLnVwcGVyXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbmV3VmFsID0ge1xuICAgICAgICAgICAgICAgICAgICBsb3dlcjogKHRoaXMudmFsdWUgYXMgSVJhbmdlU2xpZGVyVmFsdWUpLmxvd2VyLFxuICAgICAgICAgICAgICAgICAgICB1cHBlcjogKHRoaXMudmFsdWUgYXMgSVJhbmdlU2xpZGVyVmFsdWUpLnVwcGVyICsgdmFsdWVcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBTd2FwIHRoZSB0aHVtYnMgaWYgYSBjb2xsaXNpb24gYXBwZWFycy5cbiAgICAgICAgICAgIGlmIChuZXdWYWwubG93ZXIgPj0gbmV3VmFsLnVwcGVyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy52YWx1ZSA9IHRoaXMuc3dhcFRodW1iKG5ld1ZhbCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMudmFsdWUgPSBuZXdWYWw7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMudmFsdWUgPSB0aGlzLnZhbHVlIGFzIG51bWJlciArIHZhbHVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuaGFzVmFsdWVDaGFuZ2VkKG9sZFZhbHVlKSkge1xuICAgICAgICAgICAgdGhpcy5lbWl0VmFsdWVDaGFuZ2VkKG9sZFZhbHVlKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBwdWJsaWMgb25UaHVtYkNoYW5nZSgpIHtcbiAgICAgICAgdGhpcy50b2dnbGVUaHVtYkxhYmVscygpO1xuICAgIH1cblxuICAgIHByaXZhdGUgc3dhcFRodW1iKHZhbHVlOiBJUmFuZ2VTbGlkZXJWYWx1ZSkge1xuICAgICAgICBpZiAodGhpcy50aHVtYkZyb20uaXNBY3RpdmUpIHtcbiAgICAgICAgICAgIHZhbHVlLnVwcGVyID0gdGhpcy51cHBlclZhbHVlO1xuICAgICAgICAgICAgdmFsdWUubG93ZXIgPSB0aGlzLnVwcGVyVmFsdWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YWx1ZS51cHBlciA9IHRoaXMubG93ZXJWYWx1ZTtcbiAgICAgICAgICAgIHZhbHVlLmxvd2VyID0gdGhpcy5sb3dlclZhbHVlO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy50b2dnbGVUaHVtYigpO1xuXG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG5cbiAgICBwcml2YXRlIGZpbmRDbG9zZXN0VGh1bWIoZXZlbnQpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNSYW5nZSkge1xuICAgICAgICAgICAgdGhpcy5jbG9zZXN0SGFuZGxlKGV2ZW50LmNsaWVudFgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy50aHVtYlRvLm5hdGl2ZUVsZW1lbnQuZm9jdXMoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMudXBkYXRlKGV2ZW50LmNsaWVudFgpO1xuXG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSB1cGRhdGVMb3dlckJvdW5kQW5kTWluVHJhdmVsWm9uZSgpIHtcbiAgICAgICAgdGhpcy5sb3dlckJvdW5kID0gdGhpcy5taW5WYWx1ZTtcbiAgICAgICAgdGhpcy5fcE1pbiA9IDA7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSB1cGRhdGVVcHBlckJvdW5kQW5kTWF4VHJhdmVsWm9uZSgpIHtcbiAgICAgICAgdGhpcy51cHBlckJvdW5kID0gdGhpcy5tYXhWYWx1ZTtcbiAgICAgICAgdGhpcy5fcE1heCA9IDE7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBzbGlkZXJTZXR1cCgpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIGlmIHtAbGluayBTbGlkZXJUeXBlLlNMSURFUn0gdGhhbiB0aGUgaW5pdGlhbCB2YWx1ZSBzaG9sZCBiZSB0aGUgbG93ZXN0IG9uZS5cbiAgICAgICAgICovXG4gICAgICAgIGlmICghdGhpcy5pc1JhbmdlICYmIHRoaXMudmFsdWUgPT09IHRoaXMudXBwZXJCb3VuZCkge1xuICAgICAgICAgICAgdGhpcy52YWx1ZSA9IHRoaXMubG93ZXJCb3VuZDtcbiAgICAgICAgfVxuXG4gICAgfVxuXG4gICAgcHJpdmF0ZSBjYWxjdWxhdGVTdGVwRGlzdGFuY2UoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9lbC5uYXRpdmVFbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLndpZHRoIC8gKHRoaXMubWF4VmFsdWUgLSB0aGlzLm1pblZhbHVlKSAqIHRoaXMuc3RlcDtcbiAgICB9XG5cbiAgICBwcml2YXRlIHRvZ2dsZVRodW1iKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50aHVtYkZyb20uaXNBY3RpdmUgP1xuICAgICAgICAgICAgdGhpcy50aHVtYlRvLm5hdGl2ZUVsZW1lbnQuZm9jdXMoKSA6XG4gICAgICAgICAgICB0aGlzLnRodW1iRnJvbS5uYXRpdmVFbGVtZW50LmZvY3VzKCk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSB2YWx1ZUluUmFuZ2UodmFsdWUsIG1pbiA9IDAsIG1heCA9IDEwMCkge1xuICAgICAgICByZXR1cm4gTWF0aC5tYXgoTWF0aC5taW4odmFsdWUsIG1heCksIG1pbik7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBnZW5lcmF0ZVRpY2tNYXJrcyhjb2xvcjogc3RyaW5nLCBpbnRlcnZhbDogbnVtYmVyKSB7XG4gICAgICAgIHJldHVybiBpbnRlcnZhbCAhPT0gbnVsbCA/IGByZXBlYXRpbmctbGluZWFyLWdyYWRpZW50KFxuICAgICAgICAgICAgJHsndG8gbGVmdCd9LFxuICAgICAgICAgICAgJHtjb2xvcn0sXG4gICAgICAgICAgICAke2NvbG9yfSAxLjVweCxcbiAgICAgICAgICAgIHRyYW5zcGFyZW50IDEuNXB4LFxuICAgICAgICAgICAgdHJhbnNwYXJlbnQgJHtpbnRlcnZhbH0lXG4gICAgICAgICksIHJlcGVhdGluZy1saW5lYXItZ3JhZGllbnQoXG4gICAgICAgICAgICAkeyd0byByaWdodCd9LFxuICAgICAgICAgICAgJHtjb2xvcn0sXG4gICAgICAgICAgICAke2NvbG9yfSAxLjVweCxcbiAgICAgICAgICAgIHRyYW5zcGFyZW50IDEuNXB4LFxuICAgICAgICAgICAgdHJhbnNwYXJlbnQgJHtpbnRlcnZhbH0lXG4gICAgICAgIClgIDogaW50ZXJ2YWw7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBwb3NpdGlvbkhhbmRsZShoYW5kbGU6IEVsZW1lbnRSZWYsIHBvc2l0aW9uOiBudW1iZXIpIHtcbiAgICAgICAgaWYgKCFoYW5kbGUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGhhbmRsZS5uYXRpdmVFbGVtZW50LnN0eWxlLmxlZnQgPSBgJHt0aGlzLnZhbHVlVG9GcmFjdGlvbihwb3NpdGlvbikgKiAxMDB9JWA7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBwb3NpdGlvbkhhbmRsZXNBbmRVcGRhdGVUcmFjaygpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzUmFuZ2UpIHtcbiAgICAgICAgICAgIHRoaXMucG9zaXRpb25IYW5kbGUodGhpcy50aHVtYlRvLCB0aGlzLnZhbHVlIGFzIG51bWJlcik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnBvc2l0aW9uSGFuZGxlKHRoaXMudGh1bWJUbywgKHRoaXMudmFsdWUgYXMgSVJhbmdlU2xpZGVyVmFsdWUpLnVwcGVyKTtcbiAgICAgICAgICAgIHRoaXMucG9zaXRpb25IYW5kbGUodGhpcy50aHVtYkZyb20sICh0aGlzLnZhbHVlIGFzIElSYW5nZVNsaWRlclZhbHVlKS5sb3dlcik7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnVwZGF0ZVRyYWNrKCk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBjbG9zZXN0SGFuZGxlKG1vdXNlWCkge1xuICAgICAgICBjb25zdCBmcm9tT2Zmc2V0ID0gdGhpcy50aHVtYkZyb20ubmF0aXZlRWxlbWVudC5vZmZzZXRMZWZ0ICsgdGhpcy50aHVtYkZyb20ubmF0aXZlRWxlbWVudC5vZmZzZXRXaWR0aCAvIDI7XG4gICAgICAgIGNvbnN0IHRvT2Zmc2V0ID0gdGhpcy50aHVtYlRvLm5hdGl2ZUVsZW1lbnQub2Zmc2V0TGVmdCArIHRoaXMudGh1bWJUby5uYXRpdmVFbGVtZW50Lm9mZnNldFdpZHRoIC8gMjtcbiAgICAgICAgY29uc3QgeFBvaW50ZXIgPSBtb3VzZVggLSB0aGlzLl9lbC5uYXRpdmVFbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmxlZnQ7XG4gICAgICAgIGNvbnN0IG1hdGNoID0gdGhpcy5jbG9zZXN0VG8oeFBvaW50ZXIsIFtmcm9tT2Zmc2V0LCB0b09mZnNldF0pO1xuXG4gICAgICAgIGlmIChtYXRjaCA9PT0gZnJvbU9mZnNldCkge1xuICAgICAgICAgICAgdGhpcy50aHVtYkZyb20ubmF0aXZlRWxlbWVudC5mb2N1cygpO1xuICAgICAgICB9IGVsc2UgaWYgKG1hdGNoID09PSB0b09mZnNldCkge1xuICAgICAgICAgICAgdGhpcy50aHVtYlRvLm5hdGl2ZUVsZW1lbnQuZm9jdXMoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHByaXZhdGUgc2V0VGlja0ludGVydmFsKGxhYmVscykge1xuICAgICAgICBpZiAodGhpcy5jb250aW51b3VzKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgaW50ZXJ2YWw7XG4gICAgICAgIGNvbnN0IHRyYWNrUHJvZ3Jlc3MgPSAxMDA7XG4gICAgICAgIGlmICh0aGlzLmxhYmVsc1ZpZXdFbmFibGVkKSB7XG4gICAgICAgICAgICAvLyBDYWxjIHRpY2tzIGRlcGVuZGluZyBvbiB0aGUgbGFiZWxzIGxlbmd0aDtcbiAgICAgICAgICAgIGludGVydmFsID0gKCh0cmFja1Byb2dyZXNzIC8gKHRoaXMubGFiZWxzLmxlbmd0aCAtIDEpICogMTApKSAvIDEwO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgdHJhY2tSYW5nZSA9IHRoaXMubWF4VmFsdWUgLSB0aGlzLm1pblZhbHVlO1xuICAgICAgICAgICAgaW50ZXJ2YWwgPSB0aGlzLnN0ZXAgPiAxID9cbiAgICAgICAgICAgICAgICAodHJhY2tQcm9ncmVzcyAvICgodHJhY2tSYW5nZSAvIHRoaXMuc3RlcCkpICogMTApIC8gMTBcbiAgICAgICAgICAgICAgICA6IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yZW5kZXJlci5zZXRTdHlsZSh0aGlzLnRpY2tzLm5hdGl2ZUVsZW1lbnQsICdiYWNrZ3JvdW5kJywgdGhpcy5nZW5lcmF0ZVRpY2tNYXJrcygnd2hpdGUnLCBpbnRlcnZhbCkpO1xuICAgIH1cblxuICAgIHByaXZhdGUgc2hvd1RodW1iTGFiZWxzKCkge1xuICAgICAgICBpZiAodGhpcy5kaXNhYmxlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy50aHVtYlRvLnNob3dUaHVtYkxhYmVsKCk7XG4gICAgICAgIGlmICh0aGlzLnRodW1iRnJvbSkge1xuICAgICAgICAgICAgdGhpcy50aHVtYkZyb20uc2hvd1RodW1iTGFiZWwoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHByaXZhdGUgaGlkZVRodW1iTGFiZWxzKCkge1xuICAgICAgICBpZiAodGhpcy5kaXNhYmxlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy50aHVtYlRvLmhpZGVUaHVtYkxhYmVsKCk7XG4gICAgICAgIGlmICh0aGlzLnRodW1iRnJvbSkge1xuICAgICAgICAgICAgdGhpcy50aHVtYkZyb20uaGlkZVRodW1iTGFiZWwoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHByaXZhdGUgdG9nZ2xlVGh1bWJMYWJlbHMoKSB7XG4gICAgICAgIHRoaXMuc2hvd1RodW1iTGFiZWxzKCk7XG4gICAgICAgIHRoaXMuaGlkZVRodW1iTGFiZWxzKCk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBjbG9zZXN0VG8oZ29hbDogbnVtYmVyLCBwb3NpdGlvbnM6IG51bWJlcltdKTogbnVtYmVyIHtcbiAgICAgICAgcmV0dXJuIHBvc2l0aW9ucy5yZWR1Y2UoKHByZXZpb3VzLCBjdXJyZW50KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gKE1hdGguYWJzKGdvYWwgLSBjdXJyZW50KSA8IE1hdGguYWJzKGdvYWwgLSBwcmV2aW91cykgPyBjdXJyZW50IDogcHJldmlvdXMpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBwcml2YXRlIHZhbHVlVG9GcmFjdGlvbih2YWx1ZTogbnVtYmVyLCBwTWluID0gdGhpcy5fcE1pbiwgcE1heCA9IHRoaXMuX3BNYXgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmFsdWVJblJhbmdlKCh2YWx1ZSAtIHRoaXMubWluVmFsdWUpIC8gKHRoaXMubWF4VmFsdWUgLSB0aGlzLm1pblZhbHVlKSwgcE1pbiwgcE1heCk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSB1cGRhdGVUcmFjaygpIHtcbiAgICAgICAgY29uc3QgZnJvbVBvc2l0aW9uID0gdGhpcy52YWx1ZVRvRnJhY3Rpb24odGhpcy5sb3dlclZhbHVlKTtcbiAgICAgICAgY29uc3QgdG9Qb3NpdGlvbiA9IHRoaXMudmFsdWVUb0ZyYWN0aW9uKHRoaXMudXBwZXJWYWx1ZSk7XG4gICAgICAgIGNvbnN0IHBvc2l0aW9uR2FwID0gdG9Qb3NpdGlvbiAtIGZyb21Qb3NpdGlvbjtcblxuICAgICAgICBsZXQgdHJhY2tMZWZ0SW5kZW50aW9uID0gZnJvbVBvc2l0aW9uO1xuICAgICAgICBpZiAodGhpcy5pc1JhbmdlKSB7XG4gICAgICAgICAgICBpZiAocG9zaXRpb25HYXApIHtcbiAgICAgICAgICAgICAgICB0cmFja0xlZnRJbmRlbnRpb24gPSBNYXRoLnJvdW5kKCgxIC8gcG9zaXRpb25HYXAgKiBmcm9tUG9zaXRpb24pICogMTAwKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5yZW5kZXJlci5zZXRTdHlsZSh0aGlzLnRyYWNrLm5hdGl2ZUVsZW1lbnQsICd0cmFuc2Zvcm0nLCBgc2NhbGVYKCR7cG9zaXRpb25HYXB9KSB0cmFuc2xhdGVYKCR7dHJhY2tMZWZ0SW5kZW50aW9ufSUpYCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnJlbmRlcmVyLnNldFN0eWxlKHRoaXMudHJhY2submF0aXZlRWxlbWVudCwgJ3RyYW5zZm9ybScsIGBzY2FsZVgoJHt0b1Bvc2l0aW9ufSlgKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHByaXZhdGUgdmFsaWRhdGVJbml0aWFsVmFsdWUodmFsdWU6IElSYW5nZVNsaWRlclZhbHVlKSB7XG4gICAgICAgIGlmICh2YWx1ZS5sb3dlciA8IHRoaXMubG93ZXJCb3VuZCAmJiB2YWx1ZS51cHBlciA8IHRoaXMubG93ZXJCb3VuZCkge1xuICAgICAgICAgICAgdmFsdWUudXBwZXIgPSB0aGlzLmxvd2VyQm91bmQ7XG4gICAgICAgICAgICB2YWx1ZS5sb3dlciA9IHRoaXMubG93ZXJCb3VuZDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh2YWx1ZS5sb3dlciA+IHRoaXMudXBwZXJCb3VuZCAmJiB2YWx1ZS51cHBlciA+IHRoaXMudXBwZXJCb3VuZCkge1xuICAgICAgICAgICAgdmFsdWUudXBwZXIgPSB0aGlzLnVwcGVyQm91bmQ7XG4gICAgICAgICAgICB2YWx1ZS5sb3dlciA9IHRoaXMudXBwZXJCb3VuZDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh2YWx1ZS51cHBlciA8IHZhbHVlLmxvd2VyKSB7XG4gICAgICAgICAgICB2YWx1ZS51cHBlciA9IHRoaXMudXBwZXJWYWx1ZTtcbiAgICAgICAgICAgIHZhbHVlLmxvd2VyID0gdGhpcy5sb3dlclZhbHVlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cblxuICAgIHByaXZhdGUgc3Vic2NyaWJlVG8odGh1bWI6IElneFNsaWRlclRodW1iQ29tcG9uZW50LCBjYWxsYmFjazogKGE6IG51bWJlciwgYjogbnVtYmVyKSA9PiB2b2lkKSB7XG4gICAgICAgIGlmICghdGh1bWIpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRodW1iLm9uVGh1bWJWYWx1ZUNoYW5nZVxuICAgICAgICAgICAgLnBpcGUodGFrZVVudGlsKHRoaXMudW5zdWJzY3JpYmVyKHRodW1iKSkpXG4gICAgICAgICAgICAuc3Vic2NyaWJlKHZhbHVlID0+IGNhbGxiYWNrKHZhbHVlLCB0aHVtYi50eXBlKSk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSB1bnN1YnNjcmliZXIodGh1bWI6IElneFNsaWRlclRodW1iQ29tcG9uZW50KSB7XG4gICAgICAgIHJldHVybiBtZXJnZSh0aGlzLl9kZXN0cm95JCwgdGh1bWIuZGVzdHJveSk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBoYXNWYWx1ZUNoYW5nZWQob2xkVmFsdWUpIHtcbiAgICAgICAgY29uc3QgaXNTbGlkZXJXaXRoRGlmZmVyZW50VmFsdWU6IGJvb2xlYW4gPSAhdGhpcy5pc1JhbmdlICYmIG9sZFZhbHVlICE9PSB0aGlzLnZhbHVlO1xuICAgICAgICBjb25zdCBpc1JhbmdlV2l0aE9uZURpZmZlcmVudFZhbHVlOiBib29sZWFuID0gdGhpcy5pc1JhbmdlICYmXG4gICAgICAgICAgICAoKG9sZFZhbHVlIGFzIElSYW5nZVNsaWRlclZhbHVlKS5sb3dlciAhPT0gKHRoaXMudmFsdWUgYXMgSVJhbmdlU2xpZGVyVmFsdWUpLmxvd2VyIHx8XG4gICAgICAgICAgICAgICAgKG9sZFZhbHVlIGFzIElSYW5nZVNsaWRlclZhbHVlKS51cHBlciAhPT0gKHRoaXMudmFsdWUgYXMgSVJhbmdlU2xpZGVyVmFsdWUpLnVwcGVyKTtcblxuICAgICAgICByZXR1cm4gaXNTbGlkZXJXaXRoRGlmZmVyZW50VmFsdWUgfHwgaXNSYW5nZVdpdGhPbmVEaWZmZXJlbnRWYWx1ZTtcbiAgICB9XG5cbiAgICBwcml2YXRlIGVtaXRWYWx1ZUNoYW5nZWQob2xkVmFsdWU6IG51bWJlciB8IElSYW5nZVNsaWRlclZhbHVlKSB7XG4gICAgICAgIHRoaXMub25WYWx1ZUNoYW5nZS5lbWl0KHsgb2xkVmFsdWUsIHZhbHVlOiB0aGlzLnZhbHVlIH0pO1xuICAgIH1cbn1cblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbkBOZ01vZHVsZSh7XG4gICAgZGVjbGFyYXRpb25zOiBbSWd4U2xpZGVyQ29tcG9uZW50LCBJZ3hUaHVtYkZyb21UZW1wbGF0ZURpcmVjdGl2ZSwgSWd4VGh1bWJUb1RlbXBsYXRlRGlyZWN0aXZlLCBJZ3hTbGlkZXJUaHVtYkNvbXBvbmVudF0sXG4gICAgZXhwb3J0czogW0lneFNsaWRlckNvbXBvbmVudCwgSWd4VGh1bWJGcm9tVGVtcGxhdGVEaXJlY3RpdmUsIElneFRodW1iVG9UZW1wbGF0ZURpcmVjdGl2ZSwgSWd4U2xpZGVyVGh1bWJDb21wb25lbnRdLFxuICAgIGltcG9ydHM6IFtDb21tb25Nb2R1bGVdXG59KVxuZXhwb3J0IGNsYXNzIElneFNsaWRlck1vZHVsZSB7XG59XG4iXX0=