/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { DOCUMENT, isPlatformBrowser } from '@angular/common';
import { ChangeDetectionStrategy, ChangeDetectorRef, Component, ContentChild, ContentChildren, ElementRef, forwardRef, Inject, Input, NgZone, PLATFORM_ID, QueryList, Renderer2, TemplateRef, ViewChild, ViewContainerRef, } from '@angular/core';
import { NG_VALUE_ACCESSOR } from '@angular/forms';
import { BehaviorSubject, forkJoin, fromEvent, interval, merge, of, Subject, timer } from 'rxjs';
import { bufferCount, filter, switchMap, takeUntil, tap } from 'rxjs/operators';
import { NgxHmCarouselItemDirective } from './ngx-hm-carousel-item.directive';
import { resizeObservable } from './rxjs.observable.resize';
export class NgxHmCarouselComponent {
    /**
     * @param {?} platformId
     * @param {?} _document
     * @param {?} _renderer
     * @param {?} _zone
     * @param {?} _cd
     */
    constructor(platformId, _document, _renderer, _zone, _cd) {
        this.platformId = platformId;
        this._document = _document;
        this._renderer = _renderer;
        this._zone = _zone;
        this._cd = _cd;
        this.aniTime = 400;
        this.aniClass = 'transition';
        this.aniClassAuto = this.aniClass;
        this.panBoundary = 0.15;
        // this default autoplay animation is same as aniClass
        this.align = 'center';
        this.notDrag = false;
        this.mourseEnable = false;
        this.delay = 8000;
        this.direction = 'right';
        this.scrollNum = 1;
        this.isDragMany = false;
        this.swipeVelocity = 0.3;
        this.breakpoint = [];
        // using for check mouse or touchend
        this.leaveObs$ = merge(fromEvent(this._document, 'mouseup'), fromEvent(this._document, 'touchend')).pipe(tap((/**
         * @param {?} e
         * @return {?}
         */
        (e) => {
            this.grabbing = false;
            e.stopPropagation();
            e.preventDefault();
        })));
        this.isFromAuto = true;
        this.isAutoNum = false;
        this.mouseOnContainer = false;
        this.alignDistance = 0;
        this.elmWidth = 0;
        this.infiniteElmRefs = [];
        this.restart = new BehaviorSubject(null);
        this.speedChange = new BehaviorSubject(5000);
        this.stopEvent = new Subject();
        this.destroy$ = new Subject();
        this._porgressWidth = 0;
        this._currentIndex = 0;
        this._showNum = 1;
        this._autoplay = false;
        this._infinite = false;
        this._tmpInfinite = false;
        this._grabbing = false;
        this._disableDrag = false;
        this.panCount = 0;
        // this variable use for check the init value is write with ngModel,
        // when init first, not set with animation
        this.hasInitWriteValue = false;
        this.onChange = (/**
         * @param {?} _
         * @return {?}
         */
        (_) => { });
        this.onTouched = (/**
         * @return {?}
         */
        () => { });
    }
    /**
     * @return {?}
     */
    get disableDrag() {
        return this._disableDrag;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set disableDrag(value) {
        if (this.rootElm) {
            if (this._disableDrag !== value) {
                if (value) {
                    this.destoryHammer();
                }
                else {
                    this.hammer = this.bindHammer();
                }
            }
        }
        this._disableDrag = value;
    }
    /**
     * @return {?}
     */
    get infinite() { return this._infinite; }
    /**
     * @param {?} value
     * @return {?}
     */
    set infinite(value) {
        this._infinite = value;
        this.infiniteElmRefs.forEach((/**
         * @param {?} ref
         * @return {?}
         */
        (ref) => {
            this.addStyle(ref.rootNodes[0], {
                visibility: this.runLoop ? 'visible' : 'hidden'
            });
        }));
    }
    /**
     * @return {?}
     */
    get speed() { return this.speedChange.value; }
    /**
     * @param {?} value
     * @return {?}
     */
    set speed(value) {
        this._zone.runOutsideAngular((/**
         * @return {?}
         */
        () => {
            this.speedChange.next(value);
        }));
    }
    /**
     * @return {?}
     */
    get showNum() { return this._showNum; }
    /**
     * @param {?} value
     * @return {?}
     */
    set showNum(value) {
        if (value === 'auto') {
            this.isAutoNum = true;
        }
        else {
            this._showNum = +value;
            if (this.rootElm) {
                this.setViewWidth();
                this.reSetAlignDistance();
            }
        }
    }
    /**
     * @return {?}
     */
    get autoplay() { return this._autoplay; }
    /**
     * @param {?} value
     * @return {?}
     */
    set autoplay(value) {
        if (isPlatformBrowser(this.platformId)) {
            if (this.elms) {
                this.progressWidth = 0;
                if (value) {
                    this._zone.runOutsideAngular((/**
                     * @return {?}
                     */
                    () => {
                        this.doNextSub$ = this.doNext.subscribe();
                    }));
                }
                else {
                    if (this.doNextSub$) {
                        this.doNextSub$.unsubscribe();
                    }
                }
            }
        }
        this._autoplay = value;
        // if set autoplay, then the infinite is true
        if (value) {
            this._tmpInfinite = this.infinite;
            this.infinite = true;
        }
        else {
            this.infinite = this._tmpInfinite;
        }
    }
    /**
     * @return {?}
     */
    get currentIndex() { return this._currentIndex; }
    /**
     * @param {?} value
     * @return {?}
     */
    set currentIndex(value) {
        // if now index if not equale to save index, do someting
        if (this.currentIndex !== value) {
            // if the value is not contain with the boundary not handler
            if (!this.runLoop && !(0 <= value && value <= this.itemElms.length - 1)) {
                return;
            }
            this._currentIndex = value;
            if (this.elms) {
                if (this.autoplay && !this.isFromAuto) {
                    this._zone.runOutsideAngular((/**
                     * @return {?}
                     */
                    () => {
                        this.stopEvent.next();
                        this.callRestart();
                    }));
                }
                this.drawView(this.currentIndex, this.hasInitWriteValue);
                if (this.isDragMany) {
                    this.hasInitWriteValue = true;
                }
            }
            if (0 <= this.currentIndex && this.currentIndex <= this.itemElms.length - 1) {
                this._zone.run((/**
                 * @return {?}
                 */
                () => {
                    this.onChange(this.currentIndex);
                    this._cd.detectChanges();
                }));
            }
        }
        this.isFromAuto = false;
    }
    /**
     * @return {?}
     */
    get progressWidth() { return this._porgressWidth; }
    /**
     * @param {?} value
     * @return {?}
     */
    set progressWidth(value) {
        if (this.progressElm !== undefined && this.autoplay) {
            this._porgressWidth = value;
            this._renderer.setStyle(((/** @type {?} */ (this.progressContainerElm.nativeElement))).children[0], 'width', `${this.progressWidth}%`);
        }
    }
    /**
     * @return {?}
     */
    get grabbing() { return this._grabbing; }
    /**
     * @param {?} value
     * @return {?}
     */
    set grabbing(value) {
        if (this._grabbing !== value) {
            // console.log(value);
            this._zone.run((/**
             * @return {?}
             */
            () => {
                this._grabbing = value;
                if (value) {
                    this._renderer.addClass(this.containerElm, 'grabbing');
                }
                else {
                    this.panCount = 0;
                    this.callRestart();
                    this._renderer.removeClass(this.containerElm, 'grabbing');
                }
                this._cd.detectChanges();
            }));
        }
    }
    /**
     * @private
     * @param {?} value
     * @return {?}
     */
    set left(value) {
        if (isPlatformBrowser(this.platformId)) {
            this._renderer.setStyle(this.containerElm, 'transform', `translateX(${value}px)`);
        }
        else {
            this._renderer.setStyle(this.containerElm, 'transform', `translateX(${value}%)`);
        }
    }
    /**
     * @private
     * @return {?}
     */
    get maxRightIndex() {
        /** @type {?} */
        let addIndex = 0;
        switch (this.align) {
            case 'left':
                addIndex = 0;
                break;
            case 'center':
                addIndex = (/** @type {?} */ (this.showNum)) - 1;
                break;
            case 'right':
                addIndex = (/** @type {?} */ (this.showNum)) - 1;
                break;
        }
        return ((this.itemElms.length - 1) - this._showNum + 1) + addIndex;
    }
    /**
     * @private
     * @return {?}
     */
    get runLoop() { return this.autoplay || this.infinite; }
    /**
     * @private
     * @return {?}
     */
    get lengthOne() { return this.itemElms.length === 1; }
    /**
     * @private
     * @return {?}
     */
    get rootElmWidth() {
        return (isPlatformBrowser(this.platformId) ? this.rootElm.getBoundingClientRect().width : 100);
    }
    /**
     * @private
     * @param {?} value
     * @return {?}
     */
    set containerElmWidth(value) {
        this.setStyle(this.containerElm, 'width', value);
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        this.rootElm = this.container.nativeElement;
        this.containerElm = (/** @type {?} */ (this.rootElm.children[0]));
        this.init();
        forkJoin(this.bindClick(), 
        // when item changed, remove old hammer binding, and reset width
        this.itemElms.changes.pipe(
        // detectChanges to change view dots
        tap((/**
         * @return {?}
         */
        () => {
            if (this.currentIndex > this.itemElms.length - 1) {
                // i can't pass the changedetection check, only the way to using timeout. :(
                setTimeout((/**
                 * @return {?}
                 */
                () => {
                    this.currentIndex = this.itemElms.length - 1;
                }), 0);
            }
            this.destroy();
            this.removeInfiniteElm();
            this.init();
            this.progressWidth = 0;
        })), tap((/**
         * @return {?}
         */
        () => this._cd.detectChanges()))), resizeObservable(this.rootElm, (/**
         * @return {?}
         */
        () => this.containerResize()))).pipe(takeUntil(this.destroy$)).subscribe();
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.destroy();
        this.destroy$.next();
        this.destroy$.unsubscribe();
    }
    /**
     * @param {?} value
     * @return {?}
     */
    writeValue(value) {
        if (value || value === 0) {
            this.currentIndex = value;
            this.hasInitWriteValue = true;
        }
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnChange(fn) { this.onChange = fn; }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnTouched(fn) { this.onTouched = fn; }
    /**
     * @private
     * @return {?}
     */
    init() {
        this.initVariable();
        this.setViewWidth(true);
        this.reSetAlignDistance();
        if (!this.disableDrag) {
            this.hammer = this.bindHammer();
        }
        this.drawView(this.currentIndex, false);
        if (isPlatformBrowser(this.platformId) && this.runLoop) {
            this.addInfiniteElm();
        }
    }
    /**
     * @private
     * @return {?}
     */
    destroy() {
        this.destoryHammer();
        if (this.autoplay) {
            this.doNextSub$.unsubscribe();
        }
    }
    /**
     * @private
     * @return {?}
     */
    destoryHammer() {
        if (this.hammer) {
            this.hammer.destroy();
        }
    }
    /**
     * @private
     * @return {?}
     */
    addInfiniteElm() {
        for (let i = 1; i <= this.showNum; i++) {
            /** @type {?} */
            const elm = this.infiniteContainer.createEmbeddedView(this.contentContent, {
                $implicit: this.data[this.itemElms.length - i],
                index: this.itemElms.length - i
            });
            this.addStyle(elm.rootNodes[0], {
                position: 'absolute',
                // boxShadow: `0 0 0 5000px rgba(200, 75, 75, 0.5) inset`,
                transform: `translateX(-${100 * i}%)`,
                visibility: this.runLoop ? 'visible' : 'hidden'
            });
            this.setStyle(elm.rootNodes[0], 'width', this.elmWidth);
            /** @type {?} */
            const elm2 = this.infiniteContainer.createEmbeddedView(this.contentContent, {
                $implicit: this.data[i - 1],
                index: i - 1
            });
            this.addStyle(elm2.rootNodes[0], {
                // boxShadow: `0 0 0 5000px rgba(200, 75, 75, 0.5) inset`,
                position: 'absolute',
                right: 0,
                top: 0,
                transform: `translateX(${100 * i}%)`,
                visibility: this.runLoop ? 'visible' : 'hidden'
            });
            this.setStyle(elm2.rootNodes[0], 'width', this.elmWidth);
            elm.detectChanges();
            elm2.detectChanges();
            this.infiniteElmRefs.push(elm);
            this.infiniteElmRefs.push(elm2);
        }
    }
    /**
     * @private
     * @return {?}
     */
    removeInfiniteElm() {
        this.infiniteElmRefs.forEach((/**
         * @param {?} a
         * @return {?}
         */
        a => {
            a.detach();
            a.destroy();
        }));
        if (this.infiniteContainer) {
            this.infiniteContainer.clear();
        }
        this.infiniteElmRefs = [];
    }
    /**
     * @private
     * @return {?}
     */
    containerResize() {
        this.setViewWidth();
        this.reSetAlignDistance();
        // 因為不能滑了，所以要回到第一個，以確保全部都有顯示
        if (this.align !== 'center' && this.showNum >= this.elms.length) {
            this.currentIndex = 0;
        }
        this.drawView(this.currentIndex, false);
    }
    /**
     * @private
     * @return {?}
     */
    initVariable() {
        this._zone.runOutsideAngular((/**
         * @return {?}
         */
        () => {
            this.elms = this.itemElms.toArray().map((/**
             * @param {?} x
             * @return {?}
             */
            x => x.nativeElement));
            /** @type {?} */
            let startEvent = this.restart.asObservable();
            /** @type {?} */
            let stopEvent = this.stopEvent.asObservable();
            if (this.mourseEnable) {
                startEvent = merge(startEvent, fromEvent(this.containerElm, 'mouseleave').pipe(
                // when leave, we should reverse grabbing state to set the mouseOn state,
                // because when the grabbing, the mask will on, and it will occur leave again
                filter((/**
                 * @return {?}
                 */
                () => !this.grabbing)), tap((/**
                 * @return {?}
                 */
                () => this.mouseOnContainer = false))));
                stopEvent = merge(stopEvent, fromEvent(this.containerElm, 'mouseover').pipe(tap((/**
                 * @return {?}
                 */
                () => this.mouseOnContainer = true))));
            }
            this.doNext = startEvent.pipe(
            // not using debounceTime, it will stop mourseover event detect, will cause mourse-enable error
            // debounceTime(this.delay),
            switchMap((/**
             * @return {?}
             */
            () => this.speedChange)), switchMap((/**
             * @return {?}
             */
            () => timer(this.delay).pipe(switchMap((/**
             * @return {?}
             */
            () => this.runProgress(20))), tap((/**
             * @return {?}
             */
            () => {
                this.isFromAuto = true;
                // console.log('next');
                if (this.direction === 'left') {
                    this.currentIndex -= this.scrollNum;
                }
                else {
                    this.currentIndex += this.scrollNum;
                }
            })), takeUntil(stopEvent.pipe(tap((/**
             * @return {?}
             */
            () => this.progressWidth = 0))))))));
            if (this.autoplay) {
                this.doNextSub$ = this.doNext.subscribe();
            }
        }));
    }
    /**
     * @private
     * @return {?}
     */
    reSetAlignDistance() {
        switch (this.align) {
            case 'center':
                this.alignDistance = (this.rootElmWidth - this.elmWidth) / 2;
                break;
            case 'left':
                this.alignDistance = 0;
                break;
            case 'right':
                this.alignDistance = this.rootElmWidth - this.elmWidth;
                break;
        }
    }
    /**
     * @private
     * @param {?=} isInit
     * @return {?}
     */
    setViewWidth(isInit) {
        if (this.isAutoNum) {
            this._showNum = this.getAutoNum();
        }
        this._renderer.addClass(this.containerElm, 'grab');
        if (isInit) {
            // remain one elm height
            this._renderer.addClass(this.containerElm, 'ngx-hm-carousel-display-npwrap');
        }
        this.elmWidth = this.rootElmWidth / this._showNum;
        this._renderer.removeClass(this.containerElm, 'ngx-hm-carousel-display-npwrap');
        this.containerElmWidth = this.elmWidth * this.elms.length;
        this._renderer.setStyle(this.containerElm, 'position', 'relative');
        this.infiniteElmRefs.forEach((/**
         * @param {?} ref
         * @return {?}
         */
        (ref) => {
            this.setStyle(ref.rootNodes[0], 'width', this.elmWidth);
        }));
        this.elms.forEach((/**
         * @param {?} elm
         * @return {?}
         */
        (elm) => {
            this.setStyle(elm, 'width', this.elmWidth);
        }));
    }
    /**
     * @private
     * @return {?}
     */
    bindHammer() {
        if (!isPlatformBrowser(this.platformId)) {
            return null;
        }
        return this._zone.runOutsideAngular((/**
         * @return {?}
         */
        () => {
            /** @type {?} */
            const hm = new Hammer.Manager(this.containerElm);
            /** @type {?} */
            const pan = new Hammer.Pan({ direction: Hammer.DIRECTION_HORIZONTAL, threshold: 0 });
            hm.add(pan);
            hm.on('panleft panright panend pancancel', (/**
             * @param {?} e
             * @return {?}
             */
            (e) => {
                // console.log(e.type);
                if (this.lengthOne) {
                    return;
                }
                this.removeContainerTransition();
                if (this.autoplay) {
                    this._zone.runOutsideAngular((/**
                     * @return {?}
                     */
                    () => { this.stopEvent.next(); }));
                }
                switch (e.type) {
                    case 'panleft':
                    case 'panright':
                        this.panCount++;
                        // only when panmove more than two times, set move
                        if (this.panCount < 2) {
                            return;
                        }
                        this.grabbing = true;
                        // When show-num is bigger than length, stop hammer
                        if (this.align !== 'center' && this.showNum >= this.elms.length) {
                            this.hammer.stop(true);
                            return;
                        }
                        // Slow down at the first and last pane.
                        if (!this.runLoop && this.outOfBound(e.type)) {
                            e.deltaX *= 0.2;
                        }
                        if (!this.notDrag) {
                            this.left = -this.currentIndex * this.elmWidth + this.alignDistance + e.deltaX;
                        }
                        // // if not dragmany, when bigger than half
                        if (!this.isDragMany) {
                            if (Math.abs(e.deltaX) > this.elmWidth * 0.5) {
                                if (e.deltaX > 0) {
                                    this.currentIndex -= this.scrollNum;
                                }
                                else {
                                    this.currentIndex += this.scrollNum;
                                }
                                this.hammer.stop(true);
                                return;
                            }
                        }
                        break;
                    case 'pancancel':
                        this.drawView(this.currentIndex);
                        break;
                    case 'panend':
                        // if boundary more than rate
                        if (this.panBoundary !== false &&
                            Math.abs(e.deltaX) > this.elmWidth * this.panBoundary) {
                            /** @type {?} */
                            const moveNum = this.isDragMany ?
                                Math.ceil(Math.abs(e.deltaX) / this.elmWidth) : this.scrollNum;
                            /** @type {?} */
                            const prevIndex = this.currentIndex - moveNum;
                            /** @type {?} */
                            const nextIndex = this.currentIndex + moveNum;
                            // if right
                            if (e.deltaX > 0) {
                                this.goPrev(prevIndex);
                                // left
                            }
                            else {
                                this.goNext(nextIndex);
                            }
                            break;
                        }
                        else if (e.velocityX < -this.swipeVelocity && e.distance > 10) {
                            this.goNext(this.currentIndex + this.scrollNum);
                        }
                        else if (e.velocityX > this.swipeVelocity && e.distance > 10) {
                            this.goPrev(this.currentIndex - this.scrollNum);
                        }
                        else {
                            this.drawView(this.currentIndex);
                        }
                        break;
                }
            }));
            return hm;
        }));
    }
    /**
     * @private
     * @param {?} prevIndex
     * @return {?}
     */
    goPrev(prevIndex) {
        if (!this.runLoop && prevIndex < 0) {
            prevIndex = 0;
            this.drawView(0);
        }
        this.currentIndex = prevIndex;
    }
    /**
     * @private
     * @param {?} nextIndex
     * @return {?}
     */
    goNext(nextIndex) {
        if (!this.runLoop && nextIndex > this.maxRightIndex) {
            nextIndex = this.maxRightIndex;
            this.drawView(nextIndex);
        }
        this.currentIndex = nextIndex;
    }
    /**
     * @private
     * @return {?}
     */
    bindClick() {
        if (this.btnNext && this.btnPrev) {
            return forkJoin(fromEvent(this.btnNext.nativeElement, 'click').pipe(tap((/**
             * @return {?}
             */
            () => this.currentIndex++))), fromEvent(this.btnPrev.nativeElement, 'click').pipe(tap((/**
             * @return {?}
             */
            () => this.currentIndex--))));
        }
        return of(null);
    }
    /**
     * @private
     * @return {?}
     */
    callRestart() {
        // if that is autoplay
        // if that mouse is not on container( only mouse-enable is true, the state maybe true)
        // if now is grabbing, skip this restart, using grabbing change restart
        if (this.autoplay && !this.mouseOnContainer && !this.grabbing) {
            this._zone.runOutsideAngular((/**
             * @return {?}
             */
            () => {
                this.restart.next(null);
            }));
        }
    }
    /**
     * @private
     * @param {?} index
     * @param {?=} isAnimation
     * @param {?=} isFromAuto
     * @return {?}
     */
    drawView(index, isAnimation = true, isFromAuto = this.isFromAuto) {
        // move element only on length is more than 1
        if (this.elms.length > 1) {
            this.removeContainerTransition();
            this.left = -((index * this.elmWidth) - this.alignDistance);
            if (isAnimation) {
                if (isFromAuto) {
                    this._renderer.addClass(this.containerElm, this.aniClassAuto);
                }
                else {
                    this._renderer.addClass(this.containerElm, this.aniClass);
                }
                // if infinite move to next index with timeout
                this.infiniteHandler(index);
            }
        }
        else {
            this.left = this.alignDistance;
        }
    }
    /**
     * @private
     * @return {?}
     */
    removeContainerTransition() {
        this._renderer.removeClass(this.containerElm, this.aniClass);
        this._renderer.removeClass(this.containerElm, this.aniClassAuto);
    }
    /**
     * @private
     * @param {?} index
     * @return {?}
     */
    infiniteHandler(index) {
        if (this.runLoop) {
            /** @type {?} */
            let state = 0;
            state = (index < 0) ? -1 : state;
            state = (index > (this.itemElms.length - 1)) ? 1 : state;
            // index = index % this._showNum;
            if (state !== 0) {
                switch (state) {
                    case -1:
                        this._currentIndex = (this.itemElms.length + index) % this.itemElms.length;
                        break;
                    case 1:
                        this._currentIndex = index % this.itemElms.length;
                        break;
                }
                /** @type {?} */
                const isFromAuto = this.isFromAuto;
                if (this.saveTimeOut) {
                    this.saveTimeOut.unsubscribe();
                }
                this.saveTimeOut = timer(this.aniTime).pipe(switchMap((/**
                 * @return {?}
                 */
                () => {
                    // if it is any loop carousel, the next event need wait the timeout complete
                    if (this.aniTime === this.speed) {
                        this.removeContainerTransition();
                        this.left = -((this._currentIndex - state) * this.elmWidth) + this.alignDistance;
                        return timer(50).pipe(tap((/**
                         * @return {?}
                         */
                        () => {
                            this.drawView(this.currentIndex, this.hasInitWriteValue, isFromAuto);
                        })));
                    }
                    else {
                        this.drawView(this.currentIndex, false);
                    }
                    return of(null);
                })), takeUntil(this.stopEvent)).subscribe();
            }
        }
    }
    /**
     * @private
     * @param {?} type
     * @return {?}
     */
    outOfBound(type) {
        switch (type) {
            case 'panleft':
                return this.currentIndex >= this.maxRightIndex;
            case 'panright':
                return this.currentIndex <= 0;
        }
    }
    /**
     * @private
     * @param {?} betweenTime
     * @return {?}
     */
    runProgress(betweenTime) {
        return this._zone.runOutsideAngular((/**
         * @return {?}
         */
        () => {
            /** @type {?} */
            const howTimes = this.speed / betweenTime;
            /** @type {?} */
            const everyIncrease = 100 / this.speed * betweenTime;
            return interval(betweenTime).pipe(tap((/**
             * @param {?} t
             * @return {?}
             */
            t => {
                this.progressWidth = (t % howTimes) * everyIncrease;
            })), bufferCount(Math.round(howTimes), 0));
        }));
    }
    /**
     * @private
     * @return {?}
     */
    getAutoNum() {
        /** @type {?} */
        const currWidth = this.rootElmWidth;
        // check user has had set breakpoint
        if (this.breakpoint.length > 0) {
            // get the last bigget point
            /** @type {?} */
            const now = this.breakpoint.find((/**
             * @param {?} b
             * @return {?}
             */
            (b) => {
                return b.width >= currWidth;
            }));
            // if find value, it is current width
            if (now) {
                return now.number;
            }
            return this.breakpoint[this.breakpoint.length - 1].number;
        }
        // system init show number
        /** @type {?} */
        const initNum = 3;
        // 610
        if (currWidth > 300) {
            return Math.floor(initNum + (currWidth / 200));
        }
        return initNum;
    }
    /**
     * @private
     * @param {?} elm
     * @param {?} style
     * @return {?}
     */
    addStyle(elm, style) {
        if (style) {
            Object.keys(style).forEach((/**
             * @param {?} key
             * @return {?}
             */
            (key) => {
                /** @type {?} */
                const value = style[key];
                this._renderer.setStyle(elm, key, value);
            }));
        }
    }
    /**
     * @private
     * @param {?} elm
     * @param {?} style
     * @param {?} value
     * @return {?}
     */
    setStyle(elm, style, value) {
        if (isPlatformBrowser(this.platformId)) {
            this._renderer.setStyle(elm, style, `${value}px`);
        }
        else {
            this._renderer.setStyle(elm, style, `${value}%`);
        }
    }
}
NgxHmCarouselComponent.decorators = [
    { type: Component, args: [{
                selector: 'ngx-hm-carousel',
                template: "<div #containerElm class=\"carousel\">\n  <!-- main content -->\n  <ng-content select=\"[ngx-hm-carousel-container]\"></ng-content>\n  <!-- left -->\n  <div #prev *ngIf=\"contentPrev\"\n    class=\"direction left\">\n    <ng-container *ngTemplateOutlet=\"contentPrev\"></ng-container>\n  </div>\n  <!--  right -->\n  <div #next *ngIf=\"contentNext\"\n    class=\"direction right\">\n    <ng-container *ngTemplateOutlet=\"contentNext\"></ng-container>\n  </div>\n  <!-- indicators -->\n  <ul class=\"indicators\" *ngIf=\"dotElm\">\n    <li\n      *ngFor=\"let dot of itemElms; let i = index;\"\n      (click)=\"currentIndex = i\">\n      <ng-container\n        *ngTemplateOutlet=\"dotElm, context: {\n          $implicit: {\n            index : i,\n            currentIndex : currentIndex\n          }\n        }\">\n      </ng-container>\n    </li>\n  </ul>\n  <!-- progress -->\n  <div *ngIf=\"progressElm && autoplay\" #progress>\n    <ng-container\n      *ngTemplateOutlet=\"progressElm\">\n    </ng-container>\n  </div>\n\n  <div class=\"mask\" *ngIf=\"grabbing\">\n    <ng-container *ngIf=\"leaveObs$ | async\"></ng-container>\n  </div>\n</div>\n",
                providers: [{
                        provide: NG_VALUE_ACCESSOR,
                        useExisting: forwardRef((/**
                         * @return {?}
                         */
                        () => NgxHmCarouselComponent)),
                        multi: true
                    }],
                changeDetection: ChangeDetectionStrategy.OnPush,
                styles: [":host{display:block;height:100%}.ngx-hm-carousel-display-npwrap{display:flex!important;flex-wrap:nowrap!important;flex-direction:row!important;overflow:hidden!important}.carousel{overflow:hidden;position:relative;width:100%;height:100%}.carousel ul.indicators{list-style:none;bottom:1rem;left:0;margin:0;padding:0;position:absolute;text-align:center;width:100%}.carousel ul.indicators li{cursor:pointer;display:inline-block;position:relative;padding:.5rem}.carousel .direction{position:absolute;height:100%;cursor:pointer;display:flex;align-items:center;justify-content:center;top:0}.carousel .direction.left{left:0}.carousel .direction.right{position:absolute;right:0}.grab{cursor:-webkit-grab;cursor:grab}.grabbing{cursor:-webkit-grabbing;cursor:grabbing}.mask{position:absolute;left:0;top:0;right:0;bottom:0}"]
            }] }
];
/** @nocollapse */
NgxHmCarouselComponent.ctorParameters = () => [
    { type: Object, decorators: [{ type: Inject, args: [PLATFORM_ID,] }] },
    { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] }] },
    { type: Renderer2 },
    { type: NgZone },
    { type: ChangeDetectorRef }
];
NgxHmCarouselComponent.propDecorators = {
    container: [{ type: ViewChild, args: ['containerElm', { static: false },] }],
    btnPrev: [{ type: ViewChild, args: ['prev', { static: false },] }],
    btnNext: [{ type: ViewChild, args: ['next', { static: false },] }],
    progressContainerElm: [{ type: ViewChild, args: ['progress', { static: false },] }],
    itemElms: [{ type: ContentChildren, args: [NgxHmCarouselItemDirective, { read: ElementRef },] }],
    contentPrev: [{ type: ContentChild, args: ['carouselPrev', { static: false },] }],
    contentNext: [{ type: ContentChild, args: ['carouselNext', { static: false },] }],
    dotElm: [{ type: ContentChild, args: ['carouselDot', { static: false },] }],
    progressElm: [{ type: ContentChild, args: ['carouselProgress', { static: false },] }],
    infiniteContainer: [{ type: ContentChild, args: ['infiniteContainer', { static: false, read: ViewContainerRef },] }],
    contentContent: [{ type: ContentChild, args: ['carouselContent', { static: false },] }],
    data: [{ type: Input }],
    aniTime: [{ type: Input }],
    aniClass: [{ type: Input }],
    aniClassAuto: [{ type: Input }],
    swipe: [{ type: Input }],
    panBoundary: [{ type: Input, args: ['pan-boundary',] }],
    align: [{ type: Input }],
    notDrag: [{ type: Input, args: ['not-follow-pan',] }],
    mourseEnable: [{ type: Input, args: ['mourse-enable',] }],
    delay: [{ type: Input, args: ['between-delay',] }],
    direction: [{ type: Input, args: ['autoplay-direction',] }],
    scrollNum: [{ type: Input, args: ['scroll-num',] }],
    isDragMany: [{ type: Input, args: ['drag-many',] }],
    swipeVelocity: [{ type: Input, args: ['swipe-velocity',] }],
    breakpoint: [{ type: Input }],
    disableDrag: [{ type: Input, args: ['disable-drag',] }],
    infinite: [{ type: Input, args: ['infinite',] }],
    speed: [{ type: Input, args: ['autoplay-speed',] }],
    showNum: [{ type: Input, args: ['show-num',] }],
    autoplay: [{ type: Input, args: ['autoplay',] }]
};
if (false) {
    /** @type {?} */
    NgxHmCarouselComponent.prototype.container;
    /** @type {?} */
    NgxHmCarouselComponent.prototype.btnPrev;
    /** @type {?} */
    NgxHmCarouselComponent.prototype.btnNext;
    /** @type {?} */
    NgxHmCarouselComponent.prototype.progressContainerElm;
    /** @type {?} */
    NgxHmCarouselComponent.prototype.itemElms;
    /** @type {?} */
    NgxHmCarouselComponent.prototype.contentPrev;
    /** @type {?} */
    NgxHmCarouselComponent.prototype.contentNext;
    /** @type {?} */
    NgxHmCarouselComponent.prototype.dotElm;
    /** @type {?} */
    NgxHmCarouselComponent.prototype.progressElm;
    /** @type {?} */
    NgxHmCarouselComponent.prototype.infiniteContainer;
    /** @type {?} */
    NgxHmCarouselComponent.prototype.contentContent;
    /** @type {?} */
    NgxHmCarouselComponent.prototype.data;
    /** @type {?} */
    NgxHmCarouselComponent.prototype.aniTime;
    /** @type {?} */
    NgxHmCarouselComponent.prototype.aniClass;
    /** @type {?} */
    NgxHmCarouselComponent.prototype.aniClassAuto;
    /** @type {?} */
    NgxHmCarouselComponent.prototype.swipe;
    /** @type {?} */
    NgxHmCarouselComponent.prototype.panBoundary;
    /** @type {?} */
    NgxHmCarouselComponent.prototype.align;
    /** @type {?} */
    NgxHmCarouselComponent.prototype.notDrag;
    /** @type {?} */
    NgxHmCarouselComponent.prototype.mourseEnable;
    /** @type {?} */
    NgxHmCarouselComponent.prototype.delay;
    /** @type {?} */
    NgxHmCarouselComponent.prototype.direction;
    /** @type {?} */
    NgxHmCarouselComponent.prototype.scrollNum;
    /** @type {?} */
    NgxHmCarouselComponent.prototype.isDragMany;
    /** @type {?} */
    NgxHmCarouselComponent.prototype.swipeVelocity;
    /** @type {?} */
    NgxHmCarouselComponent.prototype.breakpoint;
    /** @type {?} */
    NgxHmCarouselComponent.prototype.leaveObs$;
    /**
     * @type {?}
     * @private
     */
    NgxHmCarouselComponent.prototype.isFromAuto;
    /**
     * @type {?}
     * @private
     */
    NgxHmCarouselComponent.prototype.isAutoNum;
    /**
     * @type {?}
     * @private
     */
    NgxHmCarouselComponent.prototype.mouseOnContainer;
    /**
     * @type {?}
     * @private
     */
    NgxHmCarouselComponent.prototype.alignDistance;
    /**
     * @type {?}
     * @private
     */
    NgxHmCarouselComponent.prototype.elmWidth;
    /**
     * @type {?}
     * @private
     */
    NgxHmCarouselComponent.prototype.rootElm;
    /**
     * @type {?}
     * @private
     */
    NgxHmCarouselComponent.prototype.containerElm;
    /**
     * @type {?}
     * @private
     */
    NgxHmCarouselComponent.prototype.elms;
    /**
     * @type {?}
     * @private
     */
    NgxHmCarouselComponent.prototype.infiniteElmRefs;
    /**
     * @type {?}
     * @private
     */
    NgxHmCarouselComponent.prototype.hammer;
    /**
     * @type {?}
     * @private
     */
    NgxHmCarouselComponent.prototype.saveTimeOut;
    /**
     * @type {?}
     * @private
     */
    NgxHmCarouselComponent.prototype.doNextSub$;
    /**
     * @type {?}
     * @private
     */
    NgxHmCarouselComponent.prototype.doNext;
    /**
     * @type {?}
     * @private
     */
    NgxHmCarouselComponent.prototype.restart;
    /**
     * @type {?}
     * @private
     */
    NgxHmCarouselComponent.prototype.speedChange;
    /**
     * @type {?}
     * @private
     */
    NgxHmCarouselComponent.prototype.stopEvent;
    /**
     * @type {?}
     * @private
     */
    NgxHmCarouselComponent.prototype.destroy$;
    /**
     * @type {?}
     * @private
     */
    NgxHmCarouselComponent.prototype._porgressWidth;
    /**
     * @type {?}
     * @private
     */
    NgxHmCarouselComponent.prototype._currentIndex;
    /**
     * @type {?}
     * @private
     */
    NgxHmCarouselComponent.prototype._showNum;
    /**
     * @type {?}
     * @private
     */
    NgxHmCarouselComponent.prototype._autoplay;
    /**
     * @type {?}
     * @private
     */
    NgxHmCarouselComponent.prototype._infinite;
    /**
     * @type {?}
     * @private
     */
    NgxHmCarouselComponent.prototype._tmpInfinite;
    /**
     * @type {?}
     * @private
     */
    NgxHmCarouselComponent.prototype._grabbing;
    /**
     * @type {?}
     * @private
     */
    NgxHmCarouselComponent.prototype._disableDrag;
    /**
     * @type {?}
     * @private
     */
    NgxHmCarouselComponent.prototype.panCount;
    /**
     * @type {?}
     * @private
     */
    NgxHmCarouselComponent.prototype.hasInitWriteValue;
    /**
     * @type {?}
     * @private
     */
    NgxHmCarouselComponent.prototype.onChange;
    /**
     * @type {?}
     * @private
     */
    NgxHmCarouselComponent.prototype.onTouched;
    /**
     * @type {?}
     * @private
     */
    NgxHmCarouselComponent.prototype.platformId;
    /**
     * @type {?}
     * @private
     */
    NgxHmCarouselComponent.prototype._document;
    /**
     * @type {?}
     * @private
     */
    NgxHmCarouselComponent.prototype._renderer;
    /**
     * @type {?}
     * @private
     */
    NgxHmCarouselComponent.prototype._zone;
    /**
     * @type {?}
     * @private
     */
    NgxHmCarouselComponent.prototype._cd;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibmd4LWhtLWNhcm91c2VsLmNvbXBvbmVudC5qcyIsInNvdXJjZVJvb3QiOiJuZzovL25neC1obS1jYXJvdXNlbC8iLCJzb3VyY2VzIjpbImxpYi9uZ3gtaG0tY2Fyb3VzZWwuY29tcG9uZW50LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7QUFBQSxPQUFPLEVBQUUsUUFBUSxFQUFFLGlCQUFpQixFQUFFLE1BQU0saUJBQWlCLENBQUM7QUFDOUQsT0FBTyxFQUVMLHVCQUF1QixFQUN2QixpQkFBaUIsRUFDakIsU0FBUyxFQUNULFlBQVksRUFDWixlQUFlLEVBQ2YsVUFBVSxFQUVWLFVBQVUsRUFDVixNQUFNLEVBQ04sS0FBSyxFQUNMLE1BQU0sRUFFTixXQUFXLEVBQ1gsU0FBUyxFQUNULFNBQVMsRUFDVCxXQUFXLEVBQ1gsU0FBUyxFQUNULGdCQUFnQixHQUNqQixNQUFNLGVBQWUsQ0FBQztBQUN2QixPQUFPLEVBQXdCLGlCQUFpQixFQUFFLE1BQU0sZ0JBQWdCLENBQUM7QUFDekUsT0FBTyxFQUFFLGVBQWUsRUFBRSxRQUFRLEVBQUUsU0FBUyxFQUFFLFFBQVEsRUFBRSxLQUFLLEVBQWMsRUFBRSxFQUFFLE9BQU8sRUFBZ0IsS0FBSyxFQUFFLE1BQU0sTUFBTSxDQUFDO0FBQzNILE9BQU8sRUFBRSxXQUFXLEVBQUUsTUFBTSxFQUFFLFNBQVMsRUFBRSxTQUFTLEVBQUUsR0FBRyxFQUFFLE1BQU0sZ0JBQWdCLENBQUM7QUFFaEYsT0FBTyxFQUFFLDBCQUEwQixFQUFFLE1BQU0sa0NBQWtDLENBQUM7QUFFOUUsT0FBTyxFQUFFLGdCQUFnQixFQUFFLE1BQU0sMEJBQTBCLENBQUM7QUFhNUQsTUFBTSxPQUFPLHNCQUFzQjs7Ozs7Ozs7SUFtUWpDLFlBQytCLFVBQWtCLEVBQ3JCLFNBQVMsRUFDM0IsU0FBb0IsRUFDcEIsS0FBYSxFQUNiLEdBQXNCO1FBSkQsZUFBVSxHQUFWLFVBQVUsQ0FBUTtRQUNyQixjQUFTLEdBQVQsU0FBUyxDQUFBO1FBQzNCLGNB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bEgsZ0RBQXFGOztJQUVyRixzQ0FBcUI7O0lBQ3JCLHlDQUF1Qjs7SUFDdkIsMENBQWlDOztJQUNqQyw4Q0FBc0M7O0lBQ3RDLHVDQUFlOztJQUNmLDZDQUEwRDs7SUFHMUQsdUNBQXVEOztJQUN2RCx5Q0FBeUM7O0lBQ3pDLDhDQUE2Qzs7SUFDN0MsdUNBQXFDOztJQUNyQywyQ0FBbUU7O0lBQ25FLDJDQUFtQzs7SUFDbkMsNENBQXVDOztJQUN2QywrQ0FBNkM7O0lBRTdDLDRDQUFzRDs7SUE4SXRELDJDQVNFOzs7OztJQXFDRiw0Q0FBMEI7Ozs7O0lBQzFCLDJDQUEwQjs7Ozs7SUFDMUIsa0RBQWlDOzs7OztJQUNqQywrQ0FBMEI7Ozs7O0lBQzFCLDBDQUFxQjs7Ozs7SUFFckIseUNBQTZCOzs7OztJQUM3Qiw4Q0FBa0M7Ozs7O0lBRWxDLHNDQUFpQzs7Ozs7SUFDakMsaURBQTBEOzs7OztJQUUxRCx3Q0FBOEI7Ozs7O0lBRTlCLDZDQUFrQzs7Ozs7SUFDbEMsNENBQWlDOzs7OztJQUNqQyx3Q0FBZ0M7Ozs7O0lBRWhDLHlDQUFpRDs7Ozs7SUFDakQsNkNBQWdEOzs7OztJQUNoRCwyQ0FBdUM7Ozs7O0lBQ3ZDLDBDQUFzQzs7Ozs7SUFFdEMsZ0RBQTJCOzs7OztJQUMzQiwrQ0FBMEI7Ozs7O0lBQzFCLDBDQUFxQjs7Ozs7SUFDckIsMkNBQTBCOzs7OztJQUMxQiwyQ0FBMEI7Ozs7O0lBQzFCLDhDQUE2Qjs7Ozs7SUFDN0IsMkNBQTBCOzs7OztJQUMxQiw4Q0FBNkI7Ozs7O0lBRTdCLDBDQUFxQjs7Ozs7SUFLckIsbURBQWtDOzs7OztJQTJEbEMsMENBQW1DOzs7OztJQUNuQywyQ0FBOEI7Ozs7O0lBekQ1Qiw0Q0FBK0M7Ozs7O0lBQy9DLDJDQUFtQzs7Ozs7SUFDbkMsMkNBQTRCOzs7OztJQUM1Qix1Q0FBcUI7Ozs7O0lBQ3JCLHFDQUE4QiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IERPQ1VNRU5ULCBpc1BsYXRmb3JtQnJvd3NlciB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5pbXBvcnQge1xuICBBZnRlclZpZXdJbml0LFxuICBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneSxcbiAgQ2hhbmdlRGV0ZWN0b3JSZWYsXG4gIENvbXBvbmVudCxcbiAgQ29udGVudENoaWxkLFxuICBDb250ZW50Q2hpbGRyZW4sXG4gIEVsZW1lbnRSZWYsXG4gIEVtYmVkZGVkVmlld1JlZixcbiAgZm9yd2FyZFJlZixcbiAgSW5qZWN0LFxuICBJbnB1dCxcbiAgTmdab25lLFxuICBPbkRlc3Ryb3ksXG4gIFBMQVRGT1JNX0lELFxuICBRdWVyeUxpc3QsXG4gIFJlbmRlcmVyMixcbiAgVGVtcGxhdGVSZWYsXG4gIFZpZXdDaGlsZCxcbiAgVmlld0NvbnRhaW5lclJlZixcbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBDb250cm9sVmFsdWVBY2Nlc3NvciwgTkdfVkFMVUVfQUNDRVNTT1IgfSBmcm9tICdAYW5ndWxhci9mb3Jtcyc7XG5pbXBvcnQgeyBCZWhhdmlvclN1YmplY3QsIGZvcmtKb2luLCBmcm9tRXZlbnQsIGludGVydmFsLCBtZXJnZSwgT2JzZXJ2YWJsZSwgb2YsIFN1YmplY3QsIFN1YnNjcmlwdGlvbiwgdGltZXIgfSBmcm9tICdyeGpzJztcbmltcG9ydCB7IGJ1ZmZlckNvdW50LCBmaWx0ZXIsIHN3aXRjaE1hcCwgdGFrZVVudGlsLCB0YXAgfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XG5cbmltcG9ydCB7IE5neEhtQ2Fyb3VzZWxJdGVtRGlyZWN0aXZlIH0gZnJvbSAnLi9uZ3gtaG0tY2Fyb3VzZWwtaXRlbS5kaXJlY3RpdmUnO1xuaW1wb3J0IHsgTmd4SG1DYXJvdXNlbEJyZWFrUG9pbnRVcCB9IGZyb20gJy4vbmd4LWhtLWNhcm91c2VsLm1vZGVsJztcbmltcG9ydCB7IHJlc2l6ZU9ic2VydmFibGUgfSBmcm9tICcuL3J4anMub2JzZXJ2YWJsZS5yZXNpemUnO1xuXG5AQ29tcG9uZW50KHtcbiAgc2VsZWN0b3I6ICduZ3gtaG0tY2Fyb3VzZWwnLFxuICB0ZW1wbGF0ZVVybDogJy4vbmd4LWhtLWNhcm91c2VsLmNvbXBvbmVudC5odG1sJyxcbiAgc3R5bGVVcmxzOiBbJy4vbmd4LWhtLWNhcm91c2VsLmNvbXBvbmVudC5zY3NzJ10sXG4gIHByb3ZpZGVyczogW3tcbiAgICBwcm92aWRlOiBOR19WQUxVRV9BQ0NFU1NPUixcbiAgICB1c2VFeGlzdGluZzogZm9yd2FyZFJlZigoKSA9PiBOZ3hIbUNhcm91c2VsQ29tcG9uZW50KSxcbiAgICBtdWx0aTogdHJ1ZVxuICB9XSxcbiAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2hcbn0pXG5leHBvcnQgY2xhc3MgTmd4SG1DYXJvdXNlbENvbXBvbmVudCBpbXBsZW1lbnRzIENvbnRyb2xWYWx1ZUFjY2Vzc29yLCBBZnRlclZpZXdJbml0LCBPbkRlc3Ryb3kge1xuICBAVmlld0NoaWxkKCdjb250YWluZXJFbG0nLCB7IHN0YXRpYzogZmFsc2UgfSkgY29udGFpbmVyOiBFbGVtZW50UmVmO1xuICBAVmlld0NoaWxkKCdwcmV2JywgeyBzdGF0aWM6IGZhbHNlIH0pIGJ0blByZXY6IEVsZW1lbnRSZWY7XG4gIEBWaWV3Q2hpbGQoJ25leHQnLCB7IHN0YXRpYzogZmFsc2UgfSkgYnRuTmV4dDogRWxlbWVudFJlZjtcbiAgQFZpZXdDaGlsZCgncHJvZ3Jlc3MnLCB7IHN0YXRpYzogZmFsc2UgfSkgcHJvZ3Jlc3NDb250YWluZXJFbG06IEVsZW1lbnRSZWY7XG4gIC8vIGdldCBhbGwgaXRlbSBlbG1zXG4gIEBDb250ZW50Q2hpbGRyZW4oTmd4SG1DYXJvdXNlbEl0ZW1EaXJlY3RpdmUsIHsgcmVhZDogRWxlbWVudFJlZiB9KSBpdGVtRWxtczogUXVlcnlMaXN0PEVsZW1lbnRSZWY+O1xuICBAQ29udGVudENoaWxkKCdjYXJvdXNlbFByZXYnLCB7IHN0YXRpYzogZmFsc2UgfSkgY29udGVudFByZXY6IFRlbXBsYXRlUmVmPGFueT47XG4gIEBDb250ZW50Q2hpbGQoJ2Nhcm91c2VsTmV4dCcsIHsgc3RhdGljOiBmYWxzZSB9KSBjb250ZW50TmV4dDogVGVtcGxhdGVSZWY8YW55PjtcbiAgQENvbnRlbnRDaGlsZCgnY2Fyb3VzZWxEb3QnLCB7IHN0YXRpYzogZmFsc2UgfSkgZG90RWxtOiBUZW1wbGF0ZVJlZjxhbnk+O1xuICBAQ29udGVudENoaWxkKCdjYXJvdXNlbFByb2dyZXNzJywgeyBzdGF0aWM6IGZhbHNlIH0pIHByb2dyZXNzRWxtOiBUZW1wbGF0ZVJlZjxhbnk+O1xuXG4gIEBDb250ZW50Q2hpbGQoJ2luZmluaXRlQ29udGFpbmVyJywgeyBzdGF0aWM6IGZhbHNlLCByZWFkOiBWaWV3Q29udGFpbmVyUmVmIH0pIGluZmluaXRlQ29udGFpbmVyOiBWaWV3Q29udGFpbmVyUmVmO1xuICBAQ29udGVudENoaWxkKCdjYXJvdXNlbENvbnRlbnQnLCB7IHN0YXRpYzogZmFsc2UgfSkgY29udGVudENvbnRlbnQ6IFRlbXBsYXRlUmVmPGFueT47XG5cbiAgQElucHV0KCkgZGF0YTogYW55W107XG4gIEBJbnB1dCgpIGFuaVRpbWUgPSA0MDA7XG4gIEBJbnB1dCgpIGFuaUNsYXNzID0gJ3RyYW5zaXRpb24nO1xuICBASW5wdXQoKSBhbmlDbGFzc0F1dG8gPSB0aGlzLmFuaUNsYXNzO1xuICBASW5wdXQoKSBzd2lwZTtcbiAgQElucHV0KCdwYW4tYm91bmRhcnknKSBwYW5Cb3VuZGFyeTogbnVtYmVyIHwgZmFsc2UgPSAwLjE1O1xuXG4gIC8vIHRoaXMgZGVmYXVsdCBhdXRvcGxheSBhbmltYXRpb24gaXMgc2FtZSBhcyBhbmlDbGFzc1xuICBASW5wdXQoKSBhbGlnbjogJ2xlZnQnIHwgJ2NlbnRlcicgfCAncmlnaHQnID0gJ2NlbnRlcic7XG4gIEBJbnB1dCgnbm90LWZvbGxvdy1wYW4nKSBub3REcmFnID0gZmFsc2U7XG4gIEBJbnB1dCgnbW91cnNlLWVuYWJsZScpIG1vdXJzZUVuYWJsZSA9IGZhbHNlO1xuICBASW5wdXQoJ2JldHdlZW4tZGVsYXknKSBkZWxheSA9IDgwMDA7XG4gIEBJbnB1dCgnYXV0b3BsYXktZGlyZWN0aW9uJykgZGlyZWN0aW9uOiAnbGVmdCcgfCAncmlnaHQnID0gJ3JpZ2h0JztcbiAgQElucHV0KCdzY3JvbGwtbnVtJykgc2Nyb2xsTnVtID0gMTtcbiAgQElucHV0KCdkcmFnLW1hbnknKSBpc0RyYWdNYW55ID0gZmFsc2U7XG4gIEBJbnB1dCgnc3dpcGUtdmVsb2NpdHknKSBzd2lwZVZlbG9jaXR5ID0gMC4zO1xuXG4gIEBJbnB1dCgpIGJyZWFrcG9pbnQ6IE5neEhtQ2Fyb3VzZWxCcmVha1BvaW50VXBbXSA9IFtdO1xuXG4gIEBJbnB1dCgnZGlzYWJsZS1kcmFnJylcbiAgZ2V0IGRpc2FibGVEcmFnKCkge1xuICAgIHJldHVybiB0aGlzLl9kaXNhYmxlRHJhZztcbiAgfVxuICBzZXQgZGlzYWJsZURyYWcodmFsdWUpIHtcbiAgICBpZiAodGhpcy5yb290RWxtKSB7XG4gICAgICBpZiAodGhpcy5fZGlzYWJsZURyYWcgIT09IHZhbHVlKSB7XG4gICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgIHRoaXMuZGVzdG9yeUhhbW1lcigpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuaGFtbWVyID0gdGhpcy5iaW5kSGFtbWVyKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5fZGlzYWJsZURyYWcgPSB2YWx1ZTtcbiAgfVxuXG4gIEBJbnB1dCgnaW5maW5pdGUnKVxuICBnZXQgaW5maW5pdGUoKSB7IHJldHVybiB0aGlzLl9pbmZpbml0ZTsgfVxuICBzZXQgaW5maW5pdGUodmFsdWUpIHtcbiAgICB0aGlzLl9pbmZpbml0ZSA9IHZhbHVlO1xuXG4gICAgdGhpcy5pbmZpbml0ZUVsbVJlZnMuZm9yRWFjaCgocmVmKSA9PiB7XG4gICAgICB0aGlzLmFkZFN0eWxlKHJlZi5yb290Tm9kZXNbMF0sIHtcbiAgICAgICAgdmlzaWJpbGl0eTogdGhpcy5ydW5Mb29wID8gJ3Zpc2libGUnIDogJ2hpZGRlbidcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgQElucHV0KCdhdXRvcGxheS1zcGVlZCcpXG4gIGdldCBzcGVlZCgpIHsgcmV0dXJuIHRoaXMuc3BlZWRDaGFuZ2UudmFsdWU7IH1cbiAgc2V0IHNwZWVkKHZhbHVlKSB7XG4gICAgdGhpcy5fem9uZS5ydW5PdXRzaWRlQW5ndWxhcigoKSA9PiB7XG4gICAgICB0aGlzLnNwZWVkQ2hhbmdlLm5leHQodmFsdWUpO1xuICAgIH0pO1xuICB9XG5cbiAgQElucHV0KCdzaG93LW51bScpXG4gIGdldCBzaG93TnVtKCkgeyByZXR1cm4gdGhpcy5fc2hvd051bTsgfVxuICBzZXQgc2hvd051bSh2YWx1ZTogbnVtYmVyIHwgJ2F1dG8nKSB7XG4gICAgaWYgKHZhbHVlID09PSAnYXV0bycpIHtcbiAgICAgIHRoaXMuaXNBdXRvTnVtID0gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fc2hvd051bSA9ICt2YWx1ZTtcbiAgICAgIGlmICh0aGlzLnJvb3RFbG0pIHtcbiAgICAgICAgdGhpcy5zZXRWaWV3V2lkdGgoKTtcbiAgICAgICAgdGhpcy5yZVNldEFsaWduRGlzdGFuY2UoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBASW5wdXQoJ2F1dG9wbGF5JylcbiAgZ2V0IGF1dG9wbGF5KCkgeyByZXR1cm4gdGhpcy5fYXV0b3BsYXk7IH1cbiAgc2V0IGF1dG9wbGF5KHZhbHVlKSB7XG4gICAgaWYgKGlzUGxhdGZvcm1Ccm93c2VyKHRoaXMucGxhdGZvcm1JZCkpIHtcbiAgICAgIGlmICh0aGlzLmVsbXMpIHtcbiAgICAgICAgdGhpcy5wcm9ncmVzc1dpZHRoID0gMDtcbiAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgdGhpcy5fem9uZS5ydW5PdXRzaWRlQW5ndWxhcigoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmRvTmV4dFN1YiQgPSB0aGlzLmRvTmV4dC5zdWJzY3JpYmUoKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAodGhpcy5kb05leHRTdWIkKSB7IHRoaXMuZG9OZXh0U3ViJC51bnN1YnNjcmliZSgpOyB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5fYXV0b3BsYXkgPSB2YWx1ZTtcbiAgICAvLyBpZiBzZXQgYXV0b3BsYXksIHRoZW4gdGhlIGluZmluaXRlIGlzIHRydWVcbiAgICBpZiAodmFsdWUpIHtcbiAgICAgIHRoaXMuX3RtcEluZmluaXRlID0gdGhpcy5pbmZpbml0ZTtcbiAgICAgIHRoaXMuaW5maW5pdGUgPSB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmluZmluaXRlID0gdGhpcy5fdG1wSW5maW5pdGU7XG4gICAgfVxuICB9XG5cbiAgZ2V0IGN1cnJlbnRJbmRleCgpIHsgcmV0dXJuIHRoaXMuX2N1cnJlbnRJbmRleDsgfVxuICBzZXQgY3VycmVudEluZGV4KHZhbHVlKSB7XG4gICAgLy8gaWYgbm93IGluZGV4IGlmIG5vdCBlcXVhbGUgdG8gc2F2ZSBpbmRleCwgZG8gc29tZXRpbmdcbiAgICBpZiAodGhpcy5jdXJyZW50SW5kZXggIT09IHZhbHVlKSB7XG5cbiAgICAgIC8vIGlmIHRoZSB2YWx1ZSBpcyBub3QgY29udGFpbiB3aXRoIHRoZSBib3VuZGFyeSBub3QgaGFuZGxlclxuICAgICAgaWYgKCF0aGlzLnJ1bkxvb3AgJiYgISgwIDw9IHZhbHVlICYmIHZhbHVlIDw9IHRoaXMuaXRlbUVsbXMubGVuZ3RoIC0gMSkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5fY3VycmVudEluZGV4ID0gdmFsdWU7XG4gICAgICBpZiAodGhpcy5lbG1zKSB7XG4gICAgICAgIGlmICh0aGlzLmF1dG9wbGF5ICYmICF0aGlzLmlzRnJvbUF1dG8pIHtcblxuICAgICAgICAgIHRoaXMuX3pvbmUucnVuT3V0c2lkZUFuZ3VsYXIoKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5zdG9wRXZlbnQubmV4dCgpO1xuICAgICAgICAgICAgdGhpcy5jYWxsUmVzdGFydCgpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZHJhd1ZpZXcodGhpcy5jdXJyZW50SW5kZXgsIHRoaXMuaGFzSW5pdFdyaXRlVmFsdWUpO1xuICAgICAgICBpZiAodGhpcy5pc0RyYWdNYW55KSB7XG4gICAgICAgICAgdGhpcy5oYXNJbml0V3JpdGVWYWx1ZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICgwIDw9IHRoaXMuY3VycmVudEluZGV4ICYmIHRoaXMuY3VycmVudEluZGV4IDw9IHRoaXMuaXRlbUVsbXMubGVuZ3RoIC0gMSkge1xuICAgICAgICB0aGlzLl96b25lLnJ1bigoKSA9PiB7XG4gICAgICAgICAgdGhpcy5vbkNoYW5nZSh0aGlzLmN1cnJlbnRJbmRleCk7XG4gICAgICAgICAgdGhpcy5fY2QuZGV0ZWN0Q2hhbmdlcygpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5pc0Zyb21BdXRvID0gZmFsc2U7XG4gIH1cblxuICBnZXQgcHJvZ3Jlc3NXaWR0aCgpIHsgcmV0dXJuIHRoaXMuX3BvcmdyZXNzV2lkdGg7IH1cbiAgc2V0IHByb2dyZXNzV2lkdGgodmFsdWUpIHtcbiAgICBpZiAodGhpcy5wcm9ncmVzc0VsbSAhPT0gdW5kZWZpbmVkICYmIHRoaXMuYXV0b3BsYXkpIHtcbiAgICAgIHRoaXMuX3BvcmdyZXNzV2lkdGggPSB2YWx1ZTtcbiAgICAgIHRoaXMuX3JlbmRlcmVyLnNldFN0eWxlKFxuICAgICAgICAodGhpcy5wcm9ncmVzc0NvbnRhaW5lckVsbS5uYXRpdmVFbGVtZW50IGFzIEhUTUxFbGVtZW50KS5jaGlsZHJlblswXSxcbiAgICAgICAgJ3dpZHRoJyxcbiAgICAgICAgYCR7dGhpcy5wcm9ncmVzc1dpZHRofSVgXG4gICAgICApO1xuICAgIH1cbiAgfVxuXG4gIGdldCBncmFiYmluZygpIHsgcmV0dXJuIHRoaXMuX2dyYWJiaW5nOyB9XG4gIHNldCBncmFiYmluZyh2YWx1ZTogYm9vbGVhbikge1xuICAgIGlmICh0aGlzLl9ncmFiYmluZyAhPT0gdmFsdWUpIHtcbiAgICAgIC8vIGNvbnNvbGUubG9nKHZhbHVlKTtcbiAgICAgIHRoaXMuX3pvbmUucnVuKCgpID0+IHtcbiAgICAgICAgdGhpcy5fZ3JhYmJpbmcgPSB2YWx1ZTtcbiAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgdGhpcy5fcmVuZGVyZXIuYWRkQ2xhc3ModGhpcy5jb250YWluZXJFbG0sICdncmFiYmluZycpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMucGFuQ291bnQgPSAwO1xuICAgICAgICAgIHRoaXMuY2FsbFJlc3RhcnQoKTtcbiAgICAgICAgICB0aGlzLl9yZW5kZXJlci5yZW1vdmVDbGFzcyh0aGlzLmNvbnRhaW5lckVsbSwgJ2dyYWJiaW5nJyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fY2QuZGV0ZWN0Q2hhbmdlcygpO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgLy8gdXNpbmcgZm9yIGNoZWNrIG1vdXNlIG9yIHRvdWNoZW5kXG4gIGxlYXZlT2JzJCA9IG1lcmdlKFxuICAgIGZyb21FdmVudCh0aGlzLl9kb2N1bWVudCwgJ21vdXNldXAnKSxcbiAgICBmcm9tRXZlbnQodGhpcy5fZG9jdW1lbnQsICd0b3VjaGVuZCcpXG4gICkucGlwZShcbiAgICB0YXAoKGU6IEV2ZW50KSA9PiB7XG4gICAgICB0aGlzLmdyYWJiaW5nID0gZmFsc2U7XG4gICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH0pXG4gICk7XG5cbiAgcHJpdmF0ZSBzZXQgbGVmdCh2YWx1ZTogbnVtYmVyKSB7XG4gICAgaWYgKGlzUGxhdGZvcm1Ccm93c2VyKHRoaXMucGxhdGZvcm1JZCkpIHtcbiAgICAgIHRoaXMuX3JlbmRlcmVyLnNldFN0eWxlKHRoaXMuY29udGFpbmVyRWxtLCAndHJhbnNmb3JtJywgYHRyYW5zbGF0ZVgoJHt2YWx1ZX1weClgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fcmVuZGVyZXIuc2V0U3R5bGUodGhpcy5jb250YWluZXJFbG0sICd0cmFuc2Zvcm0nLCBgdHJhbnNsYXRlWCgke3ZhbHVlfSUpYCk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBnZXQgbWF4UmlnaHRJbmRleCgpIHtcbiAgICBsZXQgYWRkSW5kZXggPSAwO1xuICAgIHN3aXRjaCAodGhpcy5hbGlnbikge1xuICAgICAgY2FzZSAnbGVmdCc6XG4gICAgICAgIGFkZEluZGV4ID0gMDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdjZW50ZXInOlxuICAgICAgICBhZGRJbmRleCA9IHRoaXMuc2hvd051bSBhcyBudW1iZXIgLSAxO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3JpZ2h0JzpcbiAgICAgICAgYWRkSW5kZXggPSB0aGlzLnNob3dOdW0gYXMgbnVtYmVyIC0gMTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHJldHVybiAoKHRoaXMuaXRlbUVsbXMubGVuZ3RoIC0gMSkgLSB0aGlzLl9zaG93TnVtICsgMSkgKyBhZGRJbmRleDtcbiAgfVxuXG4gIHByaXZhdGUgZ2V0IHJ1bkxvb3AoKSB7IHJldHVybiB0aGlzLmF1dG9wbGF5IHx8IHRoaXMuaW5maW5pdGU7IH1cbiAgcHJpdmF0ZSBnZXQgbGVuZ3RoT25lKCkgeyByZXR1cm4gdGhpcy5pdGVtRWxtcy5sZW5ndGggPT09IDE7IH1cblxuICBwcml2YXRlIGdldCByb290RWxtV2lkdGgoKSB7XG4gICAgcmV0dXJuIChpc1BsYXRmb3JtQnJvd3Nlcih0aGlzLnBsYXRmb3JtSWQpID8gdGhpcy5yb290RWxtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLndpZHRoIDogMTAwKTtcbiAgfVxuXG4gIHByaXZhdGUgc2V0IGNvbnRhaW5lckVsbVdpZHRoKHZhbHVlOiBudW1iZXIpIHtcbiAgICB0aGlzLnNldFN0eWxlKHRoaXMuY29udGFpbmVyRWxtLCAnd2lkdGgnLCB2YWx1ZSk7XG4gIH1cblxuICBwcml2YXRlIGlzRnJvbUF1dG8gPSB0cnVlO1xuICBwcml2YXRlIGlzQXV0b051bSA9IGZhbHNlO1xuICBwcml2YXRlIG1vdXNlT25Db250YWluZXIgPSBmYWxzZTtcbiAgcHJpdmF0ZSBhbGlnbkRpc3RhbmNlID0gMDtcbiAgcHJpdmF0ZSBlbG1XaWR0aCA9IDA7XG5cbiAgcHJpdmF0ZSByb290RWxtOiBIVE1MRWxlbWVudDtcbiAgcHJpdmF0ZSBjb250YWluZXJFbG06IEhUTUxFbGVtZW50O1xuXG4gIHByaXZhdGUgZWxtczogQXJyYXk8SFRNTEVsZW1lbnQ+O1xuICBwcml2YXRlIGluZmluaXRlRWxtUmVmczogQXJyYXk8RW1iZWRkZWRWaWV3UmVmPGFueT4+ID0gW107XG5cbiAgcHJpdmF0ZSBoYW1tZXI6IEhhbW1lck1hbmFnZXI7XG5cbiAgcHJpdmF0ZSBzYXZlVGltZU91dDogU3Vic2NyaXB0aW9uO1xuICBwcml2YXRlIGRvTmV4dFN1YiQ6IFN1YnNjcmlwdGlvbjtcbiAgcHJpdmF0ZSBkb05leHQ6IE9ic2VydmFibGU8YW55PjtcblxuICBwcml2YXRlIHJlc3RhcnQgPSBuZXcgQmVoYXZpb3JTdWJqZWN0PGFueT4obnVsbCk7XG4gIHByaXZhdGUgc3BlZWRDaGFuZ2UgPSBuZXcgQmVoYXZpb3JTdWJqZWN0KDUwMDApO1xuICBwcml2YXRlIHN0b3BFdmVudCA9IG5ldyBTdWJqZWN0PGFueT4oKTtcbiAgcHJpdmF0ZSBkZXN0cm95JCA9IG5ldyBTdWJqZWN0PGFueT4oKTtcblxuICBwcml2YXRlIF9wb3JncmVzc1dpZHRoID0gMDtcbiAgcHJpdmF0ZSBfY3VycmVudEluZGV4ID0gMDtcbiAgcHJpdmF0ZSBfc2hvd051bSA9IDE7XG4gIHByaXZhdGUgX2F1dG9wbGF5ID0gZmFsc2U7XG4gIHByaXZhdGUgX2luZmluaXRlID0gZmFsc2U7XG4gIHByaXZhdGUgX3RtcEluZmluaXRlID0gZmFsc2U7XG4gIHByaXZhdGUgX2dyYWJiaW5nID0gZmFsc2U7XG4gIHByaXZhdGUgX2Rpc2FibGVEcmFnID0gZmFsc2U7XG5cbiAgcHJpdmF0ZSBwYW5Db3VudCA9IDA7XG5cblxuICAvLyB0aGlzIHZhcmlhYmxlIHVzZSBmb3IgY2hlY2sgdGhlIGluaXQgdmFsdWUgaXMgd3JpdGUgd2l0aCBuZ01vZGVsLFxuICAvLyB3aGVuIGluaXQgZmlyc3QsIG5vdCBzZXQgd2l0aCBhbmltYXRpb25cbiAgcHJpdmF0ZSBoYXNJbml0V3JpdGVWYWx1ZSA9IGZhbHNlO1xuXG4gIGNvbnN0cnVjdG9yKFxuICAgIEBJbmplY3QoUExBVEZPUk1fSUQpIHByaXZhdGUgcGxhdGZvcm1JZDogT2JqZWN0LFxuICAgIEBJbmplY3QoRE9DVU1FTlQpIHByaXZhdGUgX2RvY3VtZW50LFxuICAgIHByaXZhdGUgX3JlbmRlcmVyOiBSZW5kZXJlcjIsXG4gICAgcHJpdmF0ZSBfem9uZTogTmdab25lLFxuICAgIHByaXZhdGUgX2NkOiBDaGFuZ2VEZXRlY3RvclJlZlxuICApIHsgfVxuXG4gIG5nQWZ0ZXJWaWV3SW5pdCgpIHtcbiAgICB0aGlzLnJvb3RFbG0gPSB0aGlzLmNvbnRhaW5lci5uYXRpdmVFbGVtZW50O1xuICAgIHRoaXMuY29udGFpbmVyRWxtID0gdGhpcy5yb290RWxtLmNoaWxkcmVuWzBdIGFzIEhUTUxFbGVtZW50O1xuXG4gICAgdGhpcy5pbml0KCk7XG5cbiAgICBmb3JrSm9pbihcbiAgICAgIHRoaXMuYmluZENsaWNrKCksXG4gICAgICAvLyB3aGVuIGl0ZW0gY2hhbmdlZCwgcmVtb3ZlIG9sZCBoYW1tZXIgYmluZGluZywgYW5kIHJlc2V0IHdpZHRoXG4gICAgICB0aGlzLml0ZW1FbG1zLmNoYW5nZXMucGlwZShcbiAgICAgICAgLy8gZGV0ZWN0Q2hhbmdlcyB0byBjaGFuZ2UgdmlldyBkb3RzXG4gICAgICAgIHRhcCgoKSA9PiB7XG4gICAgICAgICAgaWYgKHRoaXMuY3VycmVudEluZGV4ID4gdGhpcy5pdGVtRWxtcy5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICAvLyBpIGNhbid0IHBhc3MgdGhlIGNoYW5nZWRldGVjdGlvbiBjaGVjaywgb25seSB0aGUgd2F5IHRvIHVzaW5nIHRpbWVvdXQuIDooXG4gICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgdGhpcy5jdXJyZW50SW5kZXggPSB0aGlzLml0ZW1FbG1zLmxlbmd0aCAtIDE7XG4gICAgICAgICAgICB9LCAwKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5kZXN0cm95KCk7XG4gICAgICAgICAgdGhpcy5yZW1vdmVJbmZpbml0ZUVsbSgpO1xuICAgICAgICAgIHRoaXMuaW5pdCgpO1xuICAgICAgICAgIHRoaXMucHJvZ3Jlc3NXaWR0aCA9IDA7XG4gICAgICAgIH0pLFxuICAgICAgICB0YXAoKCkgPT4gdGhpcy5fY2QuZGV0ZWN0Q2hhbmdlcygpKSxcbiAgICAgICksXG4gICAgICByZXNpemVPYnNlcnZhYmxlKFxuICAgICAgICB0aGlzLnJvb3RFbG0sICgpID0+IHRoaXMuY29udGFpbmVyUmVzaXplKClcbiAgICAgIClcbiAgICApLnBpcGUoXG4gICAgICB0YWtlVW50aWwodGhpcy5kZXN0cm95JCksXG4gICAgKS5zdWJzY3JpYmUoKTtcblxuICB9XG5cbiAgbmdPbkRlc3Ryb3koKSB7XG4gICAgdGhpcy5kZXN0cm95KCk7XG4gICAgdGhpcy5kZXN0cm95JC5uZXh0KCk7XG4gICAgdGhpcy5kZXN0cm95JC51bnN1YnNjcmliZSgpO1xuICB9XG5cbiAgd3JpdGVWYWx1ZSh2YWx1ZTogYW55KSB7XG4gICAgaWYgKHZhbHVlIHx8IHZhbHVlID09PSAwKSB7XG4gICAgICB0aGlzLmN1cnJlbnRJbmRleCA9IHZhbHVlO1xuICAgICAgdGhpcy5oYXNJbml0V3JpdGVWYWx1ZSA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgcmVnaXN0ZXJPbkNoYW5nZShmbjogKHZhbHVlOiBhbnkpID0+IGFueSkgeyB0aGlzLm9uQ2hhbmdlID0gZm47IH1cbiAgcmVnaXN0ZXJPblRvdWNoZWQoZm46ICgpID0+IGFueSkgeyB0aGlzLm9uVG91Y2hlZCA9IGZuOyB9XG4gIHByaXZhdGUgb25DaGFuZ2UgPSAoXzogYW55KSA9PiB7IH07XG4gIHByaXZhdGUgb25Ub3VjaGVkID0gKCkgPT4geyB9O1xuXG4gIHByaXZhdGUgaW5pdCgpIHtcbiAgICB0aGlzLmluaXRWYXJpYWJsZSgpO1xuICAgIHRoaXMuc2V0Vmlld1dpZHRoKHRydWUpO1xuICAgIHRoaXMucmVTZXRBbGlnbkRpc3RhbmNlKCk7XG4gICAgaWYgKCF0aGlzLmRpc2FibGVEcmFnKSB7XG4gICAgICB0aGlzLmhhbW1lciA9IHRoaXMuYmluZEhhbW1lcigpO1xuICAgIH1cbiAgICB0aGlzLmRyYXdWaWV3KHRoaXMuY3VycmVudEluZGV4LCBmYWxzZSk7XG4gICAgaWYgKGlzUGxhdGZvcm1Ccm93c2VyKHRoaXMucGxhdGZvcm1JZCkgJiYgdGhpcy5ydW5Mb29wKSB7XG4gICAgICB0aGlzLmFkZEluZmluaXRlRWxtKCk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBkZXN0cm95KCkge1xuICAgIHRoaXMuZGVzdG9yeUhhbW1lcigpO1xuXG4gICAgaWYgKHRoaXMuYXV0b3BsYXkpIHsgdGhpcy5kb05leHRTdWIkLnVuc3Vic2NyaWJlKCk7IH1cbiAgfVxuXG4gIHByaXZhdGUgZGVzdG9yeUhhbW1lcigpIHtcbiAgICBpZiAodGhpcy5oYW1tZXIpIHtcbiAgICAgIHRoaXMuaGFtbWVyLmRlc3Ryb3koKTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIGFkZEluZmluaXRlRWxtKCkge1xuICAgIGZvciAobGV0IGkgPSAxOyBpIDw9IHRoaXMuc2hvd051bTsgaSsrKSB7XG4gICAgICBjb25zdCBlbG0gPSB0aGlzLmluZmluaXRlQ29udGFpbmVyLmNyZWF0ZUVtYmVkZGVkVmlldyh0aGlzLmNvbnRlbnRDb250ZW50LCB7XG4gICAgICAgICRpbXBsaWNpdDogdGhpcy5kYXRhW3RoaXMuaXRlbUVsbXMubGVuZ3RoIC0gaV0sXG4gICAgICAgIGluZGV4OiB0aGlzLml0ZW1FbG1zLmxlbmd0aCAtIGlcbiAgICAgIH0pO1xuICAgICAgdGhpcy5hZGRTdHlsZShlbG0ucm9vdE5vZGVzWzBdLCB7XG4gICAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuICAgICAgICAvLyBib3hTaGFkb3c6IGAwIDAgMCA1MDAwcHggcmdiYSgyMDAsIDc1LCA3NSwgMC41KSBpbnNldGAsXG4gICAgICAgIHRyYW5zZm9ybTogYHRyYW5zbGF0ZVgoLSR7MTAwICogaX0lKWAsXG4gICAgICAgIHZpc2liaWxpdHk6IHRoaXMucnVuTG9vcCA/ICd2aXNpYmxlJyA6ICdoaWRkZW4nXG4gICAgICB9KTtcbiAgICAgIHRoaXMuc2V0U3R5bGUoZWxtLnJvb3ROb2Rlc1swXSwgJ3dpZHRoJywgdGhpcy5lbG1XaWR0aCk7XG5cbiAgICAgIGNvbnN0IGVsbTIgPSB0aGlzLmluZmluaXRlQ29udGFpbmVyLmNyZWF0ZUVtYmVkZGVkVmlldyh0aGlzLmNvbnRlbnRDb250ZW50LCB7XG4gICAgICAgICRpbXBsaWNpdDogdGhpcy5kYXRhW2kgLSAxXSxcbiAgICAgICAgaW5kZXg6IGkgLSAxXG4gICAgICB9KTtcbiAgICAgIHRoaXMuYWRkU3R5bGUoZWxtMi5yb290Tm9kZXNbMF0sIHtcbiAgICAgICAgLy8gYm94U2hhZG93OiBgMCAwIDAgNTAwMHB4IHJnYmEoMjAwLCA3NSwgNzUsIDAuNSkgaW5zZXRgLFxuICAgICAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcbiAgICAgICAgcmlnaHQ6IDAsXG4gICAgICAgIHRvcDogMCxcbiAgICAgICAgdHJhbnNmb3JtOiBgdHJhbnNsYXRlWCgkezEwMCAqIGl9JSlgLFxuICAgICAgICB2aXNpYmlsaXR5OiB0aGlzLnJ1bkxvb3AgPyAndmlzaWJsZScgOiAnaGlkZGVuJ1xuICAgICAgfSk7XG4gICAgICB0aGlzLnNldFN0eWxlKGVsbTIucm9vdE5vZGVzWzBdLCAnd2lkdGgnLCB0aGlzLmVsbVdpZHRoKTtcblxuICAgICAgZWxtLmRldGVjdENoYW5nZXMoKTtcbiAgICAgIGVsbTIuZGV0ZWN0Q2hhbmdlcygpO1xuXG4gICAgICB0aGlzLmluZmluaXRlRWxtUmVmcy5wdXNoKGVsbSk7XG4gICAgICB0aGlzLmluZmluaXRlRWxtUmVmcy5wdXNoKGVsbTIpO1xuICAgIH1cblxuICB9XG5cbiAgcHJpdmF0ZSByZW1vdmVJbmZpbml0ZUVsbSgpIHtcbiAgICB0aGlzLmluZmluaXRlRWxtUmVmcy5mb3JFYWNoKGEgPT4ge1xuICAgICAgYS5kZXRhY2goKTtcbiAgICAgIGEuZGVzdHJveSgpO1xuICAgIH0pO1xuICAgIGlmICh0aGlzLmluZmluaXRlQ29udGFpbmVyKSB7XG4gICAgICB0aGlzLmluZmluaXRlQ29udGFpbmVyLmNsZWFyKCk7XG4gICAgfVxuICAgIHRoaXMuaW5maW5pdGVFbG1SZWZzID0gW107XG4gIH1cblxuICBwcml2YXRlIGNvbnRhaW5lclJlc2l6ZSgpIHtcbiAgICB0aGlzLnNldFZpZXdXaWR0aCgpO1xuICAgIHRoaXMucmVTZXRBbGlnbkRpc3RhbmNlKCk7XG5cbiAgICAvLyDlm6DngrrkuI3og73mu5HkuobvvIzmiYDku6XopoHlm57liLDnrKzkuIDlgIvvvIzku6Xnorrkv53lhajpg6jpg73mnInpoa/npLpcbiAgICBpZiAodGhpcy5hbGlnbiAhPT0gJ2NlbnRlcicgJiYgdGhpcy5zaG93TnVtID49IHRoaXMuZWxtcy5sZW5ndGgpIHtcbiAgICAgIHRoaXMuY3VycmVudEluZGV4ID0gMDtcbiAgICB9XG4gICAgdGhpcy5kcmF3Vmlldyh0aGlzLmN1cnJlbnRJbmRleCwgZmFsc2UpO1xuICB9XG5cbiAgcHJpdmF0ZSBpbml0VmFyaWFibGUoKSB7XG4gICAgdGhpcy5fem9uZS5ydW5PdXRzaWRlQW5ndWxhcigoKSA9PiB7XG5cbiAgICAgIHRoaXMuZWxtcyA9IHRoaXMuaXRlbUVsbXMudG9BcnJheSgpLm1hcCh4ID0+IHgubmF0aXZlRWxlbWVudCk7XG5cbiAgICAgIGxldCBzdGFydEV2ZW50ID0gdGhpcy5yZXN0YXJ0LmFzT2JzZXJ2YWJsZSgpO1xuICAgICAgbGV0IHN0b3BFdmVudCA9IHRoaXMuc3RvcEV2ZW50LmFzT2JzZXJ2YWJsZSgpO1xuICAgICAgaWYgKHRoaXMubW91cnNlRW5hYmxlKSB7XG4gICAgICAgIHN0YXJ0RXZlbnQgPSBtZXJnZShcbiAgICAgICAgICBzdGFydEV2ZW50LFxuICAgICAgICAgIGZyb21FdmVudCh0aGlzLmNvbnRhaW5lckVsbSwgJ21vdXNlbGVhdmUnKS5waXBlKFxuICAgICAgICAgICAgLy8gd2hlbiBsZWF2ZSwgd2Ugc2hvdWxkIHJldmVyc2UgZ3JhYmJpbmcgc3RhdGUgdG8gc2V0IHRoZSBtb3VzZU9uIHN0YXRlLFxuICAgICAgICAgICAgLy8gYmVjYXVzZSB3aGVuIHRoZSBncmFiYmluZywgdGhlIG1hc2sgd2lsbCBvbiwgYW5kIGl0IHdpbGwgb2NjdXIgbGVhdmUgYWdhaW5cbiAgICAgICAgICAgIGZpbHRlcigoKSA9PiAhdGhpcy5ncmFiYmluZyksXG4gICAgICAgICAgICB0YXAoKCkgPT4gdGhpcy5tb3VzZU9uQ29udGFpbmVyID0gZmFsc2UpXG4gICAgICAgICAgKVxuICAgICAgICApO1xuICAgICAgICBzdG9wRXZlbnQgPSBtZXJnZShcbiAgICAgICAgICBzdG9wRXZlbnQsXG4gICAgICAgICAgZnJvbUV2ZW50KHRoaXMuY29udGFpbmVyRWxtLCAnbW91c2VvdmVyJykucGlwZShcbiAgICAgICAgICAgIHRhcCgoKSA9PiB0aGlzLm1vdXNlT25Db250YWluZXIgPSB0cnVlKVxuICAgICAgICAgIClcbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5kb05leHQgPSBzdGFydEV2ZW50LnBpcGUoXG4gICAgICAgIC8vIG5vdCB1c2luZyBkZWJvdW5jZVRpbWUsIGl0IHdpbGwgc3RvcCBtb3Vyc2VvdmVyIGV2ZW50IGRldGVjdCwgd2lsbCBjYXVzZSBtb3Vyc2UtZW5hYmxlIGVycm9yXG4gICAgICAgIC8vIGRlYm91bmNlVGltZSh0aGlzLmRlbGF5KSxcbiAgICAgICAgc3dpdGNoTWFwKCgpID0+IHRoaXMuc3BlZWRDaGFuZ2UpLFxuICAgICAgICBzd2l0Y2hNYXAoKCkgPT5cbiAgICAgICAgICB0aW1lcih0aGlzLmRlbGF5KS5waXBlKFxuICAgICAgICAgICAgc3dpdGNoTWFwKCgpID0+IHRoaXMucnVuUHJvZ3Jlc3MoMjApKSxcbiAgICAgICAgICAgIHRhcCgoKSA9PiB7XG4gICAgICAgICAgICAgIHRoaXMuaXNGcm9tQXV0byA9IHRydWU7XG4gICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCduZXh0Jyk7XG4gICAgICAgICAgICAgIGlmICh0aGlzLmRpcmVjdGlvbiA9PT0gJ2xlZnQnKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50SW5kZXggLT0gdGhpcy5zY3JvbGxOdW07XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50SW5kZXggKz0gdGhpcy5zY3JvbGxOdW07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgdGFrZVVudGlsKHN0b3BFdmVudC5waXBlKFxuICAgICAgICAgICAgICB0YXAoKCkgPT4gdGhpcy5wcm9ncmVzc1dpZHRoID0gMClcbiAgICAgICAgICAgICkpXG4gICAgICAgICAgKVxuICAgICAgICApKTtcblxuICAgICAgaWYgKHRoaXMuYXV0b3BsYXkpIHtcbiAgICAgICAgdGhpcy5kb05leHRTdWIkID0gdGhpcy5kb05leHQuc3Vic2NyaWJlKCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBwcml2YXRlIHJlU2V0QWxpZ25EaXN0YW5jZSgpIHtcbiAgICBzd2l0Y2ggKHRoaXMuYWxpZ24pIHtcbiAgICAgIGNhc2UgJ2NlbnRlcic6XG4gICAgICAgIHRoaXMuYWxpZ25EaXN0YW5jZSA9ICh0aGlzLnJvb3RFbG1XaWR0aCAtIHRoaXMuZWxtV2lkdGgpIC8gMjtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdsZWZ0JzpcbiAgICAgICAgdGhpcy5hbGlnbkRpc3RhbmNlID0gMDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdyaWdodCc6XG4gICAgICAgIHRoaXMuYWxpZ25EaXN0YW5jZSA9IHRoaXMucm9vdEVsbVdpZHRoIC0gdGhpcy5lbG1XaWR0aDtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBzZXRWaWV3V2lkdGgoaXNJbml0PzogYm9vbGVhbikge1xuICAgIGlmICh0aGlzLmlzQXV0b051bSkge1xuICAgICAgdGhpcy5fc2hvd051bSA9IHRoaXMuZ2V0QXV0b051bSgpO1xuICAgIH1cbiAgICB0aGlzLl9yZW5kZXJlci5hZGRDbGFzcyh0aGlzLmNvbnRhaW5lckVsbSwgJ2dyYWInKTtcbiAgICBpZiAoaXNJbml0KSB7XG4gICAgICAvLyByZW1haW4gb25lIGVsbSBoZWlnaHRcbiAgICAgIHRoaXMuX3JlbmRlcmVyLmFkZENsYXNzKHRoaXMuY29udGFpbmVyRWxtLCAnbmd4LWhtLWNhcm91c2VsLWRpc3BsYXktbnB3cmFwJyk7XG4gICAgfVxuICAgIHRoaXMuZWxtV2lkdGggPSB0aGlzLnJvb3RFbG1XaWR0aCAvIHRoaXMuX3Nob3dOdW07XG5cbiAgICB0aGlzLl9yZW5kZXJlci5yZW1vdmVDbGFzcyh0aGlzLmNvbnRhaW5lckVsbSwgJ25neC1obS1jYXJvdXNlbC1kaXNwbGF5LW5wd3JhcCcpO1xuXG4gICAgdGhpcy5jb250YWluZXJFbG1XaWR0aCA9IHRoaXMuZWxtV2lkdGggKiB0aGlzLmVsbXMubGVuZ3RoO1xuXG4gICAgdGhpcy5fcmVuZGVyZXIuc2V0U3R5bGUodGhpcy5jb250YWluZXJFbG0sICdwb3NpdGlvbicsICdyZWxhdGl2ZScpO1xuXG4gICAgdGhpcy5pbmZpbml0ZUVsbVJlZnMuZm9yRWFjaCgocmVmKSA9PiB7XG4gICAgICB0aGlzLnNldFN0eWxlKHJlZi5yb290Tm9kZXNbMF0sICd3aWR0aCcsIHRoaXMuZWxtV2lkdGgpO1xuICAgIH0pO1xuICAgIHRoaXMuZWxtcy5mb3JFYWNoKChlbG06IEhUTUxFbGVtZW50KSA9PiB7XG4gICAgICB0aGlzLnNldFN0eWxlKGVsbSwgJ3dpZHRoJywgdGhpcy5lbG1XaWR0aCk7XG4gICAgfSk7XG5cbiAgfVxuXG4gIHByaXZhdGUgYmluZEhhbW1lcigpIHtcbiAgICBpZiAoIWlzUGxhdGZvcm1Ccm93c2VyKHRoaXMucGxhdGZvcm1JZCkpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fem9uZS5ydW5PdXRzaWRlQW5ndWxhcigoKSA9PiB7XG5cbiAgICAgIGNvbnN0IGhtID0gbmV3IEhhbW1lci5NYW5hZ2VyKHRoaXMuY29udGFpbmVyRWxtKTtcblxuICAgICAgY29uc3QgcGFuID0gbmV3IEhhbW1lci5QYW4oeyBkaXJlY3Rpb246IEhhbW1lci5ESVJFQ1RJT05fSE9SSVpPTlRBTCwgdGhyZXNob2xkOiAwIH0pO1xuXG4gICAgICBobS5hZGQocGFuKTtcblxuICAgICAgaG0ub24oJ3BhbmxlZnQgcGFucmlnaHQgcGFuZW5kIHBhbmNhbmNlbCcsIChlOiBIYW1tZXJJbnB1dCkgPT4ge1xuICAgICAgICAvLyBjb25zb2xlLmxvZyhlLnR5cGUpO1xuXG4gICAgICAgIGlmICh0aGlzLmxlbmd0aE9uZSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMucmVtb3ZlQ29udGFpbmVyVHJhbnNpdGlvbigpO1xuXG4gICAgICAgIGlmICh0aGlzLmF1dG9wbGF5KSB7XG4gICAgICAgICAgdGhpcy5fem9uZS5ydW5PdXRzaWRlQW5ndWxhcigoKSA9PiB7IHRoaXMuc3RvcEV2ZW50Lm5leHQoKTsgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBzd2l0Y2ggKGUudHlwZSkge1xuICAgICAgICAgIGNhc2UgJ3BhbmxlZnQnOlxuICAgICAgICAgIGNhc2UgJ3BhbnJpZ2h0JzpcbiAgICAgICAgICAgIHRoaXMucGFuQ291bnQrKztcbiAgICAgICAgICAgIC8vIG9ubHkgd2hlbiBwYW5tb3ZlIG1vcmUgdGhhbiB0d28gdGltZXMsIHNldCBtb3ZlXG4gICAgICAgICAgICBpZiAodGhpcy5wYW5Db3VudCA8IDIpIHtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLmdyYWJiaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgIC8vIFdoZW4gc2hvdy1udW0gaXMgYmlnZ2VyIHRoYW4gbGVuZ3RoLCBzdG9wIGhhbW1lclxuICAgICAgICAgICAgaWYgKHRoaXMuYWxpZ24gIT09ICdjZW50ZXInICYmIHRoaXMuc2hvd051bSA+PSB0aGlzLmVsbXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIHRoaXMuaGFtbWVyLnN0b3AodHJ1ZSk7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFNsb3cgZG93biBhdCB0aGUgZmlyc3QgYW5kIGxhc3QgcGFuZS5cbiAgICAgICAgICAgIGlmICghdGhpcy5ydW5Mb29wICYmIHRoaXMub3V0T2ZCb3VuZChlLnR5cGUpKSB7XG4gICAgICAgICAgICAgIGUuZGVsdGFYICo9IDAuMjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCF0aGlzLm5vdERyYWcpIHtcbiAgICAgICAgICAgICAgdGhpcy5sZWZ0ID0gLXRoaXMuY3VycmVudEluZGV4ICogdGhpcy5lbG1XaWR0aCArIHRoaXMuYWxpZ25EaXN0YW5jZSArIGUuZGVsdGFYO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyAvLyBpZiBub3QgZHJhZ21hbnksIHdoZW4gYmlnZ2VyIHRoYW4gaGFsZlxuICAgICAgICAgICAgaWYgKCF0aGlzLmlzRHJhZ01hbnkpIHtcbiAgICAgICAgICAgICAgaWYgKE1hdGguYWJzKGUuZGVsdGFYKSA+IHRoaXMuZWxtV2lkdGggKiAwLjUpIHtcbiAgICAgICAgICAgICAgICBpZiAoZS5kZWx0YVggPiAwKSB7XG4gICAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnRJbmRleCAtPSB0aGlzLnNjcm9sbE51bTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50SW5kZXggKz0gdGhpcy5zY3JvbGxOdW07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuaGFtbWVyLnN0b3AodHJ1ZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICdwYW5jYW5jZWwnOlxuICAgICAgICAgICAgdGhpcy5kcmF3Vmlldyh0aGlzLmN1cnJlbnRJbmRleCk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ3BhbmVuZCc6XG4gICAgICAgICAgICAvLyBpZiBib3VuZGFyeSBtb3JlIHRoYW4gcmF0ZVxuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICB0aGlzLnBhbkJvdW5kYXJ5ICE9PSBmYWxzZSAmJlxuICAgICAgICAgICAgICBNYXRoLmFicyhlLmRlbHRhWCkgPiB0aGlzLmVsbVdpZHRoICogdGhpcy5wYW5Cb3VuZGFyeVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgIGNvbnN0IG1vdmVOdW0gPSB0aGlzLmlzRHJhZ01hbnkgP1xuICAgICAgICAgICAgICAgIE1hdGguY2VpbChNYXRoLmFicyhlLmRlbHRhWCkgLyB0aGlzLmVsbVdpZHRoKSA6IHRoaXMuc2Nyb2xsTnVtO1xuXG4gICAgICAgICAgICAgIGNvbnN0IHByZXZJbmRleCA9IHRoaXMuY3VycmVudEluZGV4IC0gbW92ZU51bTtcbiAgICAgICAgICAgICAgY29uc3QgbmV4dEluZGV4ID0gdGhpcy5jdXJyZW50SW5kZXggKyBtb3ZlTnVtO1xuXG4gICAgICAgICAgICAgIC8vIGlmIHJpZ2h0XG4gICAgICAgICAgICAgIGlmIChlLmRlbHRhWCA+IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLmdvUHJldihwcmV2SW5kZXgpO1xuICAgICAgICAgICAgICAgIC8vIGxlZnRcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmdvTmV4dChuZXh0SW5kZXgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChlLnZlbG9jaXR5WCA8IC10aGlzLnN3aXBlVmVsb2NpdHkgJiYgZS5kaXN0YW5jZSA+IDEwKSB7XG4gICAgICAgICAgICAgIHRoaXMuZ29OZXh0KHRoaXMuY3VycmVudEluZGV4ICsgdGhpcy5zY3JvbGxOdW0pO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChlLnZlbG9jaXR5WCA+IHRoaXMuc3dpcGVWZWxvY2l0eSAmJiBlLmRpc3RhbmNlID4gMTApIHtcbiAgICAgICAgICAgICAgdGhpcy5nb1ByZXYodGhpcy5jdXJyZW50SW5kZXggLSB0aGlzLnNjcm9sbE51bSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB0aGlzLmRyYXdWaWV3KHRoaXMuY3VycmVudEluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgcmV0dXJuIGhtO1xuICAgIH0pO1xuXG4gIH1cblxuICBwcml2YXRlIGdvUHJldihwcmV2SW5kZXg6IG51bWJlcikge1xuICAgIGlmICghdGhpcy5ydW5Mb29wICYmIHByZXZJbmRleCA8IDApIHtcbiAgICAgIHByZXZJbmRleCA9IDA7XG4gICAgICB0aGlzLmRyYXdWaWV3KDApO1xuICAgIH1cbiAgICB0aGlzLmN1cnJlbnRJbmRleCA9IHByZXZJbmRleDtcbiAgfVxuXG4gIHByaXZhdGUgZ29OZXh0KG5leHRJbmRleDogbnVtYmVyKSB7XG4gICAgaWYgKCF0aGlzLnJ1bkxvb3AgJiYgbmV4dEluZGV4ID4gdGhpcy5tYXhSaWdodEluZGV4KSB7XG4gICAgICBuZXh0SW5kZXggPSB0aGlzLm1heFJpZ2h0SW5kZXg7XG4gICAgICB0aGlzLmRyYXdWaWV3KG5leHRJbmRleCk7XG4gICAgfVxuICAgIHRoaXMuY3VycmVudEluZGV4ID0gbmV4dEluZGV4O1xuICB9XG5cbiAgcHJpdmF0ZSBiaW5kQ2xpY2soKSB7XG4gICAgaWYgKHRoaXMuYnRuTmV4dCAmJiB0aGlzLmJ0blByZXYpIHtcbiAgICAgIHJldHVybiBmb3JrSm9pbihcbiAgICAgICAgZnJvbUV2ZW50KHRoaXMuYnRuTmV4dC5uYXRpdmVFbGVtZW50LCAnY2xpY2snKS5waXBlKFxuICAgICAgICAgIHRhcCgoKSA9PiB0aGlzLmN1cnJlbnRJbmRleCsrKVxuICAgICAgICApLFxuICAgICAgICBmcm9tRXZlbnQodGhpcy5idG5QcmV2Lm5hdGl2ZUVsZW1lbnQsICdjbGljaycpLnBpcGUoXG4gICAgICAgICAgdGFwKCgpID0+IHRoaXMuY3VycmVudEluZGV4LS0pXG4gICAgICAgIClcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiBvZihudWxsKTtcbiAgfVxuXG4gIHByaXZhdGUgY2FsbFJlc3RhcnQoKSB7XG4gICAgLy8gaWYgdGhhdCBpcyBhdXRvcGxheVxuICAgIC8vIGlmIHRoYXQgbW91c2UgaXMgbm90IG9uIGNvbnRhaW5lciggb25seSBtb3VzZS1lbmFibGUgaXMgdHJ1ZSwgdGhlIHN0YXRlIG1heWJlIHRydWUpXG4gICAgLy8gaWYgbm93IGlzIGdyYWJiaW5nLCBza2lwIHRoaXMgcmVzdGFydCwgdXNpbmcgZ3JhYmJpbmcgY2hhbmdlIHJlc3RhcnRcbiAgICBpZiAodGhpcy5hdXRvcGxheSAmJiAhdGhpcy5tb3VzZU9uQ29udGFpbmVyICYmICF0aGlzLmdyYWJiaW5nKSB7XG4gICAgICB0aGlzLl96b25lLnJ1bk91dHNpZGVBbmd1bGFyKCgpID0+IHtcbiAgICAgICAgdGhpcy5yZXN0YXJ0Lm5leHQobnVsbCk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIGRyYXdWaWV3KGluZGV4OiBudW1iZXIsIGlzQW5pbWF0aW9uID0gdHJ1ZSwgaXNGcm9tQXV0byA9IHRoaXMuaXNGcm9tQXV0bykge1xuICAgIC8vIG1vdmUgZWxlbWVudCBvbmx5IG9uIGxlbmd0aCBpcyBtb3JlIHRoYW4gMVxuICAgIGlmICh0aGlzLmVsbXMubGVuZ3RoID4gMSkge1xuICAgICAgdGhpcy5yZW1vdmVDb250YWluZXJUcmFuc2l0aW9uKCk7XG4gICAgICB0aGlzLmxlZnQgPSAtKChpbmRleCAqIHRoaXMuZWxtV2lkdGgpIC0gdGhpcy5hbGlnbkRpc3RhbmNlKTtcblxuICAgICAgaWYgKGlzQW5pbWF0aW9uKSB7XG4gICAgICAgIGlmIChpc0Zyb21BdXRvKSB7XG4gICAgICAgICAgdGhpcy5fcmVuZGVyZXIuYWRkQ2xhc3ModGhpcy5jb250YWluZXJFbG0sIHRoaXMuYW5pQ2xhc3NBdXRvKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLl9yZW5kZXJlci5hZGRDbGFzcyh0aGlzLmNvbnRhaW5lckVsbSwgdGhpcy5hbmlDbGFzcyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gaWYgaW5maW5pdGUgbW92ZSB0byBuZXh0IGluZGV4IHdpdGggdGltZW91dFxuICAgICAgICB0aGlzLmluZmluaXRlSGFuZGxlcihpbmRleCk7XG4gICAgICB9XG5cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5sZWZ0ID0gdGhpcy5hbGlnbkRpc3RhbmNlO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgcmVtb3ZlQ29udGFpbmVyVHJhbnNpdGlvbigpIHtcbiAgICB0aGlzLl9yZW5kZXJlci5yZW1vdmVDbGFzcyh0aGlzLmNvbnRhaW5lckVsbSwgdGhpcy5hbmlDbGFzcyk7XG4gICAgdGhpcy5fcmVuZGVyZXIucmVtb3ZlQ2xhc3ModGhpcy5jb250YWluZXJFbG0sIHRoaXMuYW5pQ2xhc3NBdXRvKTtcbiAgfVxuXG4gIHByaXZhdGUgaW5maW5pdGVIYW5kbGVyKGluZGV4OiBudW1iZXIpIHtcbiAgICBpZiAodGhpcy5ydW5Mb29wKSB7XG4gICAgICBsZXQgc3RhdGUgPSAwO1xuICAgICAgc3RhdGUgPSAoaW5kZXggPCAwKSA/IC0xIDogc3RhdGU7XG4gICAgICBzdGF0ZSA9IChpbmRleCA+ICh0aGlzLml0ZW1FbG1zLmxlbmd0aCAtIDEpKSA/IDEgOiBzdGF0ZTtcblxuICAgICAgLy8gaW5kZXggPSBpbmRleCAlIHRoaXMuX3Nob3dOdW07XG4gICAgICBpZiAoc3RhdGUgIT09IDApIHtcbiAgICAgICAgc3dpdGNoIChzdGF0ZSkge1xuICAgICAgICAgIGNhc2UgLTE6XG4gICAgICAgICAgICB0aGlzLl9jdXJyZW50SW5kZXggPSAodGhpcy5pdGVtRWxtcy5sZW5ndGggKyBpbmRleCkgJSB0aGlzLml0ZW1FbG1zLmxlbmd0aDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgIHRoaXMuX2N1cnJlbnRJbmRleCA9IGluZGV4ICUgdGhpcy5pdGVtRWxtcy5sZW5ndGg7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGlzRnJvbUF1dG8gPSB0aGlzLmlzRnJvbUF1dG87XG4gICAgICAgIGlmICh0aGlzLnNhdmVUaW1lT3V0KSB7XG4gICAgICAgICAgdGhpcy5zYXZlVGltZU91dC51bnN1YnNjcmliZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5zYXZlVGltZU91dCA9IHRpbWVyKHRoaXMuYW5pVGltZSkucGlwZShcbiAgICAgICAgICBzd2l0Y2hNYXAoKCkgPT4ge1xuICAgICAgICAgICAgLy8gaWYgaXQgaXMgYW55IGxvb3AgY2Fyb3VzZWwsIHRoZSBuZXh0IGV2ZW50IG5lZWQgd2FpdCB0aGUgdGltZW91dCBjb21wbGV0ZVxuICAgICAgICAgICAgaWYgKHRoaXMuYW5pVGltZSA9PT0gdGhpcy5zcGVlZCkge1xuICAgICAgICAgICAgICB0aGlzLnJlbW92ZUNvbnRhaW5lclRyYW5zaXRpb24oKTtcbiAgICAgICAgICAgICAgdGhpcy5sZWZ0ID0gLSgodGhpcy5fY3VycmVudEluZGV4IC0gc3RhdGUpICogdGhpcy5lbG1XaWR0aCkgKyB0aGlzLmFsaWduRGlzdGFuY2U7XG4gICAgICAgICAgICAgIHJldHVybiB0aW1lcig1MCkucGlwZShcbiAgICAgICAgICAgICAgICB0YXAoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3Vmlldyh0aGlzLmN1cnJlbnRJbmRleCwgdGhpcy5oYXNJbml0V3JpdGVWYWx1ZSwgaXNGcm9tQXV0byk7XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHRoaXMuZHJhd1ZpZXcodGhpcy5jdXJyZW50SW5kZXgsIGZhbHNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBvZihudWxsKTtcbiAgICAgICAgICB9KSxcbiAgICAgICAgICB0YWtlVW50aWwodGhpcy5zdG9wRXZlbnQpXG4gICAgICAgICkuc3Vic2NyaWJlKCk7XG4gICAgICB9XG4gICAgfVxuXG4gIH1cblxuXG4gIHByaXZhdGUgb3V0T2ZCb3VuZCh0eXBlKSB7XG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICBjYXNlICdwYW5sZWZ0JzpcbiAgICAgICAgcmV0dXJuIHRoaXMuY3VycmVudEluZGV4ID49IHRoaXMubWF4UmlnaHRJbmRleDtcbiAgICAgIGNhc2UgJ3BhbnJpZ2h0JzpcbiAgICAgICAgcmV0dXJuIHRoaXMuY3VycmVudEluZGV4IDw9IDA7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBydW5Qcm9ncmVzcyhiZXR3ZWVuVGltZSk6IE9ic2VydmFibGU8YW55PiB7XG5cbiAgICByZXR1cm4gdGhpcy5fem9uZS5ydW5PdXRzaWRlQW5ndWxhcigoKSA9PiB7XG4gICAgICBjb25zdCBob3dUaW1lcyA9IHRoaXMuc3BlZWQgLyBiZXR3ZWVuVGltZTtcbiAgICAgIGNvbnN0IGV2ZXJ5SW5jcmVhc2UgPSAxMDAgLyB0aGlzLnNwZWVkICogYmV0d2VlblRpbWU7XG4gICAgICByZXR1cm4gaW50ZXJ2YWwoYmV0d2VlblRpbWUpLnBpcGUoXG4gICAgICAgIHRhcCh0ID0+IHtcbiAgICAgICAgICB0aGlzLnByb2dyZXNzV2lkdGggPSAodCAlIGhvd1RpbWVzKSAqIGV2ZXJ5SW5jcmVhc2U7XG4gICAgICAgIH0pLFxuICAgICAgICBidWZmZXJDb3VudChNYXRoLnJvdW5kKGhvd1RpbWVzKSwgMClcbiAgICAgICk7XG4gICAgfSk7XG4gIH1cblxuICBwcml2YXRlIGdldEF1dG9OdW0oKSB7XG4gICAgY29uc3QgY3VycldpZHRoID0gdGhpcy5yb290RWxtV2lkdGg7XG4gICAgLy8gY2hlY2sgdXNlciBoYXMgaGFkIHNldCBicmVha3BvaW50XG4gICAgaWYgKHRoaXMuYnJlYWtwb2ludC5sZW5ndGggPiAwKSB7XG4gICAgICAvLyBnZXQgdGhlIGxhc3QgYmlnZ2V0IHBvaW50XG4gICAgICBjb25zdCBub3cgPSB0aGlzLmJyZWFrcG9pbnQuZmluZCgoYikgPT4ge1xuICAgICAgICByZXR1cm4gYi53aWR0aCA+PSBjdXJyV2lkdGg7XG4gICAgICB9KTtcbiAgICAgIC8vIGlmIGZpbmQgdmFsdWUsIGl0IGlzIGN1cnJlbnQgd2lkdGhcbiAgICAgIGlmIChub3cpIHtcbiAgICAgICAgcmV0dXJuIG5vdy5udW1iZXI7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5icmVha3BvaW50W3RoaXMuYnJlYWtwb2ludC5sZW5ndGggLSAxXS5udW1iZXI7XG4gICAgfVxuXG4gICAgLy8gc3lzdGVtIGluaXQgc2hvdyBudW1iZXJcbiAgICBjb25zdCBpbml0TnVtID0gMztcbiAgICAvLyA2MTBcbiAgICBpZiAoY3VycldpZHRoID4gMzAwKSB7XG4gICAgICByZXR1cm4gTWF0aC5mbG9vcihpbml0TnVtICsgKGN1cnJXaWR0aCAvIDIwMCkpO1xuICAgIH1cbiAgICByZXR1cm4gaW5pdE51bTtcbiAgfVxuXG4gIHByaXZhdGUgYWRkU3R5bGUoZWxtOiBIVE1MRWxlbWVudCwgc3R5bGU6IHsgW2tleTogc3RyaW5nXTogc3RyaW5nIHwgbnVtYmVyIH0pIHtcbiAgICBpZiAoc3R5bGUpIHtcbiAgICAgIE9iamVjdC5rZXlzKHN0eWxlKS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBzdHlsZVtrZXldO1xuICAgICAgICB0aGlzLl9yZW5kZXJlci5zZXRTdHlsZShlbG0sIGtleSwgdmFsdWUpO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBzZXRTdHlsZShlbG06IEhUTUxFbGVtZW50LCBzdHlsZTogc3RyaW5nLCB2YWx1ZTogbnVtYmVyKSB7XG4gICAgaWYgKGlzUGxhdGZvcm1Ccm93c2VyKHRoaXMucGxhdGZvcm1JZCkpIHtcbiAgICAgIHRoaXMuX3JlbmRlcmVyLnNldFN0eWxlKGVsbSwgc3R5bGUsIGAke3ZhbHVlfXB4YCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX3JlbmRlcmVyLnNldFN0eWxlKGVsbSwgc3R5bGUsIGAke3ZhbHVlfSVgKTtcbiAgICB9XG4gIH1cblxufVxuXG5cbiJdfQ==